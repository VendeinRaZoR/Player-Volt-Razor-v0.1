/******************************************************************************
MMC/SD/SD HC card debug monitor example for the CodeVisionAVR V2.05.4+ compiler

The program is based on FAT file system sample project
for FatFs R0.07 (C)ChaN, 2008-2009

Modified & debugged by Pavel Haiduc, (C) 2009-2011 HP InfoTech s.r.l.

The example is intended to be run on the Mega128-Dev development board
from www.priio.com.
The development board uses an ATmega128 chip running at 14.745600 MHz

The SD card socket on the development board is connected to the
following I/O ports:

SD socket    CD4050    ATmega128
pin1  /CS -----<|----- PORTD bit6
pin2  SI  -----<|----- MOSI
pin3  GND
pin4  +3.3V
pin5  SCK -----<|----- SCK
pin6  GND
pin7  SO  ------------ MISO
pin9  GND
pin10 /CD ------------ PORTG bit4 with 10k pull-up resistor to +5V
pin11 WP  ------------ PORTG bit3 with 10k pull-up resistor to +5V
pin12 GND

The CD4050 CMOS buffer is powered from a +3.3V supply and
performs logic level translation from 5V (AVR) to 3.3V (SD card).

For other I/O port connections, you need to make appropriate changes in the
"Project|Configure|C Compiler|Libraries|MMC/SD/SD HC Card and FAT Support"
menu.

The development board also uses a PCF8563 RTC connected to the
following I/O ports:

PCF8563                ATmega128
pin5 SDA ------------- PORTD bit1 with 10k pull-up resistor to +5V
pin6 SCL ------------- PORTD bit0 with 10k pull-up resistor to +5V

For other I/O port connections, you need to make appropriate changes in
the rtc.c file.

The development board's serial socket P9 must be connected to the PC COM port.
The CodeVisionAVR Terminal is used for displaying data received from the
development board.
The Terminal must be configured for:
Baud Rate: 19200
Data Bits: 8
Parity: None
Stop Bits: 1
Emulation: TTY
Handshaking: None
Append LF on Reception: OFF
Appearance|Rows: 40
Appearance|Columns: 80

If you are using the CodeVisionAVR Evaluation version, you may program into
the FLASH the precompiled SDMON.HEX file found in the
\Examples\SD Card Monitor\EXE directory
******************************************************************************/

#include <io.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sdcard.h>
#include "interrupt.h"
#include "usart.h"
#include "rtc.h"

unsigned long acc_size;			/* Work register for fs command */
unsigned short acc_files, acc_dirs;
FILINFO finfo;

unsigned char line[120];			/* Console input buffer */

FATFS fatfs;			/* File system object for logical drive 0 */
unsigned char Buff[1024];			/* Working buffer */

#define TIMER_FREQ 100        /* Timer increment frequency [Hz] */
volatile unsigned short Timer;		/* 100Hz increment timer */


#if _MULTI_PARTITION != 0
const PARTITION Drives[] = { {0,0}, {0,1} };
#endif

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/
interrupt [TIM2_COMP] void timer_comp_isr(void)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}

/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */
void dump_line (const unsigned char *buff, uint32_t ofs, unsigned char cnt)
{
unsigned char n;

printf("%08lX ", ofs);
for(n = 0; n < cnt; n++) printf(" %02X", buff[n]);
for(n = cnt; n < 16; n++) printf("   ");
putchar(' ');
for(n = 0; n < cnt; n++)
   {
   if ((buff[n] < 0x20)||(buff[n] >= 0x7F)) putchar('.');
   else putchar(buff[n]);
   }
printf("\r\n");
}

void get_line (char *buff, int len)
{
	char c;
	int idx = 0;

	for (;;) {
		c = getchar();
		if (c == '\r') break;
		if ((c == '\b') && idx) {
			idx--; putchar(c);
		}
		if (((unsigned char)c >= ' ') && (idx < (len - 1))) {
				buff[idx++] = c; putchar(c);
		}
	}
	buff[idx] = 0;
	printf("%c\r\n",c);
}


FRESULT scan_files (char* path)
{
DIR dirs;
FRESULT res;
int i;

if ((res = f_opendir(&dirs, path)) == FR_OK)
   {
   i = strlen(path);
   while (((res = f_readdir(&dirs, &finfo)) == FR_OK) && finfo.fname[0])
         {
	    if (finfo.fattrib & AM_DIR)
            {
		  acc_dirs++;
            if (finfo.fname[0]!='.')
               {
		     if (*(path+i-1)!='/') *(path+i) = '/';
               strcpy(path+i+1, &finfo.fname[0]);
               res = scan_files(path);
		     *(path+i) = '\0';
		     if (res != FR_OK) break;
               }
		  }
         else
            {
		  acc_files++;
		  acc_size += finfo.fsize;
		  }
	    }
   }
return res;
}

char flash str[] =
		"OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
		"INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
		"INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0";

void display_result (FRESULT rc)
{
	flash char *p;
	FRESULT i;

	for (p = str, i = (FRESULT) 0; (i != rc) && (*p); i++) {
		while(*p++);
	}
	printf("rc=%u FR_%p\r\n", (unsigned short)rc, p);
}

void io_init ()
{
	usart_init();		// Initialize USART driver

	OCR2 = _MCU_CLOCK_FREQUENCY_/(1024L*TIMER_FREQ)-1; // Timer2: 100Hz interval (OC2)
     // Timer 2 clock prescaler=1024
     // Clear Timer 2 on OCR2 match
	TCCR2 = (1<<WGM21)+(1<<CS22)+(1<<CS20);

	TIMSK = 1 << OCIE2;	// Enable TC2.oc, interrupt

	rtc_initialize();	// Initialize RTC

	sei(); // Enable interrupts
}

unsigned char get_number(const char **str, unsigned long *res)
{
if (str==NULL) return 0;
if (*str==NULL) return 0;
if (res==NULL) return 0;
while (isspace(**str)) ++(*str);
if (!isdigit(**str)) return 0;
*res = atol(*str);
while (isdigit(**str)) ++(*str);
return 1;
}

/*-----------------------------------------------------------------------*/
/* Main                                                                  */

void main (void)
{
	char *ptr, *ptr2;
	unsigned long p1, p2, p3;
	unsigned char res, b1;
	unsigned short w1;
	unsigned int s1, s2, cnt;
	unsigned long ofs, sect = 0;
	RTC rtc;
	FATFS *fs;
	DIR dir;				/* Directory object */
	FIL file1, file2;		/* File object */


	io_init();
	printf("CodeVisionAVR SD CARD disk monitor V1.02 Build:%u\r\nEnter ? for a list of commands\r\n\r\n",__BUILD__);

	for (;;) {
		putchar('>');
		get_line(line, sizeof(line));
		ptr = line;

		switch (*ptr++) {

          case '?' :
               printf(
               "Low level commands:\r\n"
               "di - Initialize physical disk 0\r\n"
               "ds - Show disk status\r\n"
               "dd [<sector>] - Dump sector\r\n"
               "\r\n"

               "bd <addr> - Dump Read/Write buffer\r\n"
               "be <addr> [<data>] ... - Edit Read/Write buffer\r\n"
               "bf <data> - Fill Read/Write buffer with a value\r\n"
               "br <sector> [<count>] - Read count sector(s) to the Read/Write buffer\r\n"
               "bw <sector> [<count>] - Write count sector(s) to the Read/Write buffer\r\n"
               "\r\n"

               "High level commands:\r\n"
               "fi - Mount logical drive 0:\r\n"
               "fs [<path>] - Show logical drive status\r\n"
               "fl [<path>] - List directory\r\n"
               "fo <mode> <file_name> - Open a file\r\n"
               "   mode: 0 - Open existing, 1 - Read, 2 - Write, 4 - Create new\r\n"
               "fc - Close the currently opened file\r\n"
               "fe <position> - Seek file pointer\r\n"
               "fr <len> - Read len bytes from the opened file\r\n"
               "fd <len> - Read and dump len bytes from the opened file\r\n"
               "fw <len> <val> - Writes len bytes with value val to the file\r\n"
               "fv - Truncate the currently opened file\r\n"
               "fn <old_name> <new_name> - Rename file or directory\r\n"
               "fu <name> - Delete a file or directory\r\n"
               "fk <name> - Create a directory\r\n"
               "fa <attr> <mask> <name> - Change file or directory attribute\r\n"
               "   attr, mask: 1 - R, 2 - H, 4 - S, 8 - V, 16 - D, 32 - A\r\n"
               "fx <src_name> <dst_name> - Copy file\r\n"
               "ft <day> <month> <year> <hour> <min> <sec> <file_name> - Set file's date & time\r\n"
               #if _USE_MKFS
			   "fm <# of FATs> <bytes/cluster> - Partition (FDISK) and format drive\r\n"
               #endif
               "\r\n"
               "t [<day> <month> <year> <hour> <min> <sec>] - Set/display RTC date & time\r\n"
               "\r\n"
               );
               break;

		case 'd' :
			switch (*ptr++) {
			case 'd' :	/* dd [<sector>] - Dump sector */
				if (!get_number(&ptr, &p2)) p2 = sect;
				res = disk_read(0, Buff, p2, 1);
				if (res) { printf("rc=%d\r\n", (unsigned short)res); break; }
				sect = p2 + 1;
				printf("Sector:%lu\r\n", p2);
				for (ptr=Buff, ofs = 0; ofs < 0x200; ptr+=16, ofs+=16)
					dump_line(ptr, ofs, 16);
				break;

			case 'i' :	/* di - Initialize disk */
				printf("rc=%d\r\n", (unsigned short)disk_initialize(0));
				break;

			case 's' :	/* ds - Show disk status */
				if (disk_ioctl(0, GET_SECTOR_COUNT, &p2) == RES_OK)
					{ printf("Drive size: %lu sectors\r\n", p2); }
				if (disk_ioctl(0, GET_SECTOR_SIZE, &w1) == RES_OK)
					{ printf("Sector size: %u\r\n", w1); }
				if (disk_ioctl(0, GET_BLOCK_SIZE, &p2) == RES_OK)
					{ printf("Erase block size: %lu sectors\r\n", p2); }
				if (disk_ioctl(0, MMC_GET_TYPE, &b1) == RES_OK)
					{ printf("Card type: %u\r\n", b1); }
				if (disk_ioctl(0, MMC_GET_CSD, Buff) == RES_OK)
					{ printf("CSD:\r\n"); dump_line(Buff, 0, 16); }
				if (disk_ioctl(0, MMC_GET_CID, Buff) == RES_OK)
					{ printf("CID:\r\n"); dump_line(Buff, 0, 16); }
				if (disk_ioctl(0, MMC_GET_OCR, Buff) == RES_OK)
					{ printf("OCR:\r\n"); dump_line(Buff, 0, 4); }
				if (disk_ioctl(0, MMC_GET_SDSTAT, Buff) == RES_OK) {
					printf("SD Status:\r\n");
					for (s1 = 0; s1 < 64; s1 += 16) dump_line(Buff+s1, s1, 16);
				}
				break;
			}
			break;

		case 'b' :
			switch (*ptr++) {
			case 'd' :	/* bd <addr> - Dump R/W buffer */
				if (!get_number(&ptr, &p1)) break;
				for (ptr=&Buff[p1], ofs = p1, cnt = 32; cnt; cnt--, ptr+=16, ofs+=16)
					dump_line(ptr, ofs, 16);
				break;

			case 'e' :	/* be <addr> [<data>] ... - Edit R/W buffer */
				if (!get_number(&ptr, &p1)) break;
				if (get_number(&ptr, &p2)) {
					do {
						Buff[p1++] = (unsigned char)p2;
					} while (get_number(&ptr, &p2));
					break;
				}
				for (;;) {
					printf("%04X %02X-", (unsigned short)(p1), (unsigned short)Buff[p1]);
					get_line(line, sizeof(line));
					ptr = line;
					if (*ptr == '.') break;
					if (*ptr < ' ') { p1++; continue; }
					if (get_number(&ptr, &p2))
						Buff[p1++] = (unsigned char)p2;
					else
						printf("???\r\n");
				}
				break;

			case 'r' :	/* br <sector> [<n>] - Read disk into R/W buffer */
				if (!get_number(&ptr, &p2)) break;
				if (!get_number(&ptr, &p3)) p3 = 1;
				printf("rc=%u\r\n", (unsigned short)disk_read(0, Buff, p2, p3));
				break;

			case 'w' :	/* bw <sector> [<n>] - Write R/W buffer into disk */
				if (!get_number(&ptr, &p2)) break;
				if (!get_number(&ptr, &p3)) p3 = 1;
				printf("rc=%u\r\n", (unsigned short)disk_write(0, Buff, p2, p3));
				break;

			case 'f' :	/* bf <n> - Fill R/W buffer with a value */
				if (!get_number(&ptr, &p1)) break;
				memset(Buff, (unsigned char)p1, sizeof(Buff));
				break;

			}
			break;

		case 'f' :
			switch (*ptr++) {

			case 'i' :	/* fi - Initialize logical drive */
				display_result(f_mount(0, &fatfs));
				break;

			case 's' :	/* fs [<path>] - Show logical drive status */
				while (*ptr == ' ') ptr++;
				res = f_getfree(ptr, &p2, &fs);
				if (res) { display_result(res); break; }
				printf("FAT type = %u\r\nBytes/Cluster = %lu\r\nNumber of FATs = %u\r\n"
							 "Root DIR entries = %u\r\nSectors/FAT = %lu\r\nNumber of clusters = %lu\r\n"
							 "FAT start (lba) = %lu\r\nDIR start (lba,cluster) = %lu\r\nData start (lba) = %lu\r\n",
						fs->fs_type, (unsigned long)fs->csize * 512, fs->n_fats,
						fs->n_rootdir, fs->sects_fat, fs->max_clust - 2,
						fs->fatbase, fs->dirbase, fs->database
				);
				acc_size = acc_files = acc_dirs = 0;
				res = scan_files(ptr);
				if (res) { display_result(res); break; }
				printf("%u folders, %u files, %lu bytes.\r\n"
				       "%lu kB total disk space.\r\n"
                           "%lu kB available.\r\n",
					  acc_dirs, acc_files, acc_size,
					  (fs->max_clust - 2) * (fs->csize / 2), p2 * (fs->csize / 2)
				);
				break;

			case 'l' :	/* fl [<path>] - Directory listing */
				while (*ptr == ' ') ptr++;
				res = f_opendir(&dir, ptr);
				if (res) { display_result(res); break; }
				p1 = s1 = s2 = 0;
				for(;;) {
					res = f_readdir(&dir, &finfo);
					if ((res != FR_OK) || !finfo.fname[0]) break;
					if (finfo.fattrib & AM_DIR) {
						s2++;
					} else {
						s1++; p1 += finfo.fsize;
					}
					printf("%c%c%c%c%c %02u/%02u/%u %02u:%02u:%02u %9lu  %s\r\n",
								(finfo.fattrib & AM_DIR) ? 'D' : '-',
								(finfo.fattrib & AM_RDO) ? 'R' : '-',
								(finfo.fattrib & AM_HID) ? 'H' : '-',
								(finfo.fattrib & AM_SYS) ? 'S' : '-',
								(finfo.fattrib & AM_ARC) ? 'A' : '-',
								finfo.fdate & 0x1F, (finfo.fdate >> 5) & 0xF, (finfo.fdate >> 9) + 1980,
								(finfo.ftime >> 11), (finfo.ftime >> 5) & 0x3F, (finfo.ftime & 0xF) << 1,
								finfo.fsize, &(finfo.fname[0]));
				}
				printf("%4u File(s),%10lu bytes total\r\n%4u Dir(s)", s1, p1, s2);
				if (f_getfree(ptr, &p1, &fs) == FR_OK)
					printf(", %10lu kB free\r\n", p1 * fs->csize / 2);
				break;

			case 'o' :	/* fo <mode> <name> - Open a file */
				if (!get_number(&ptr, &p1)) break;
				while (*ptr == ' ') ptr++;
				display_result(f_open(&file1, ptr, (unsigned char)p1));
				break;

			case 'c' :	/* fc - Close a file */
				display_result(f_close(&file1));
				break;

			case 'e' :	/* fe - Seek file pointer */
				if (!get_number(&ptr, &p1)) break;
				res = f_lseek(&file1, p1);
				display_result(res);
				if (res == FR_OK)
					printf("fptr = %lu(0x%lX)\r\n", file1.fptr, file1.fptr);
				break;

			case 'r' :	/* fr <len> - read file */
				if (!get_number(&ptr, &p1)) break;
				p2 = 0;
				Timer = 0;
				while (p1) {
					if (p1 >= sizeof(Buff))	{ cnt = sizeof(Buff); p1 -= sizeof(Buff); }
					else 			{ cnt = (unsigned short)p1; p1 = 0; }
					res = f_read(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { display_result(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
                    if (s2 == 0) printf("%lu bytes read.\r\n", p2); /* handle correctly /0 for small read sizes */
				else printf("%lu bytes read with %lu bytes/sec.\r\n", p2, p2 * TIMER_FREQ / s2);
				break;

			case 'd' :	/* fd <len> - read and dump file from current fp */
				if (!get_number(&ptr, &p1)) break;
				ofs = file1.fptr;
				while (p1) {
					if (p1 >= 16)	{ cnt = 16; p1 -= 16; }
					else 			{ cnt = (unsigned short)p1; p1 = 0; }
					res = f_read(&file1, Buff, cnt, &cnt);
					if (res != FR_OK) { display_result(res); break; }
					if (!cnt) break;
					dump_line(Buff, ofs, cnt);
					ofs += 16;
				}
				break;

			case 'w' :	/* fw <len> <val> - write file */
				if ((!get_number(&ptr, &p1)) || (!get_number(&ptr, &p2))) break;
				memset(Buff, (unsigned char)p2, sizeof(Buff));
				p2 = 0;
				Timer = 0;
				while (p1) {
					if (p1 >= sizeof(Buff))	{ cnt = sizeof(Buff); p1 -= sizeof(Buff); }
					else { cnt = (unsigned short)p1; p1 = 0; }
					res = f_write(&file1, Buff, cnt, &s2);
					if (res != FR_OK) { display_result(res); break; }
					p2 += s2;
					if (cnt != s2) break;
				}
				s2 = Timer;
                    if (s2 == 0) printf("%lu bytes written.\r\n", p2); /* handle correctly /0 for small written sizes */
				else printf("%lu bytes written with %lu bytes/sec.\r\n", p2, p2 * TIMER_FREQ / s2);
				break;

			case 'v' :	/* fv - Truncate file */
				display_result(f_truncate(&file1));
				break;

			case 'n' :	/* fn <old_name> <new_name> - Change file/dir name */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				while (*ptr2 == ' ') ptr2++;
				display_result(f_rename(ptr, ptr2));
				break;

			case 'u' :	/* fu <name> - Delete a file or dir */
				while (*ptr == ' ') ptr++;
				display_result(f_unlink(ptr));
				break;

			case 'k' :	/* fk <name> - Create a directory */
				while (*ptr == ' ') ptr++;
				display_result(f_mkdir(ptr));
				break;

			case 'a' :	/* fa <attr> <mask> <name> - Change file/dir attribute */
				if ((!get_number(&ptr, &p1)) || (!get_number(&ptr, &p2))) break;
				while (*ptr == ' ') ptr++;
				display_result(f_chmod(ptr, p1, p2));
				break;

			case 'x' : /* fx <src_name> <dst_name> - Copy file */
				while (*ptr == ' ') ptr++;
				ptr2 = strchr(ptr, ' ');
				if (!ptr2) break;
				*ptr2++ = 0;
				printf("Opening \"%s\"", ptr);
				res = f_open(&file1, ptr, FA_OPEN_EXISTING | FA_READ);
				if (res) {
					display_result(res);
					break;
				}
				printf("\r\nCreating \"%s\"", ptr2);
				res = f_open(&file2, ptr2, FA_CREATE_ALWAYS | FA_WRITE);
				if (res) {
					display_result(res);
					f_close(&file1);
					break;
				}
				printf("\r\nCopying...");
				p1 = 0;
				for (;;) {
					res = f_read(&file1, Buff, sizeof(Buff), &s1);
					if (res || (s1 == 0)) break;   /* error or eof */
					res = f_write(&file2, Buff, s1, &s2);
					p1 += s2;
					if (res || (s2 < s1)) break;   /* error or disk full */
				}
				if (res) display_result(res);
				printf("\r\n%lu bytes copied.\r\n", p1);
				f_close(&file1);
				f_close(&file2);
				break;

			case 't' :	/* ft <day> <month> <year> <hour> <min> <sec> <name> */
				if ((!get_number(&ptr, &p1)) || (!get_number(&ptr, &p2)) || (!get_number(&ptr, &p3))) break;
				finfo.fdate = ((p3 - 1980) << 9) | ((p2 & 0xF) << 5) | (p1 & 0x1F);
				if (!get_number(&ptr, &p1) || !get_number(&ptr, &p2) || !get_number(&ptr, &p3)) break;
				finfo.ftime = ((p1 & 0x1F) << 11) | ((p2 & 0x3F) << 5) | ((p3 >> 1) & 0x1F);
                    while (*ptr == ' ') ptr++;
				display_result(f_utime(ptr, &finfo));
				break;

            #if _USE_MKFS
			case 'm' :	/* fm <# of FATs> <bytes/cluster> - Format drive */
				if ((!get_number(&ptr, &p1)) || (!get_number(&ptr, &p2))) break;
                if ((p1 != 1) && (p1 != 2))
                   {
                   printf("ERROR: Number of FATs must be 1 or 2\r\n");
                   break;
                   }
				printf("The drive will be formatted. Are you sure? (Y/n)=");
				get_line(ptr, sizeof(line));
				if (*ptr == 'Y')
                   {
                   printf("Formatting, please wait...\r\n");
                   display_result(f_mkfs(0,(unsigned short)p1,(unsigned short)p2));
                   }
				break;
            #endif
			}
			break;

		case 't' :	/* t [<day> <month> <year> <hour> <min> <sec>] */
			if (get_number(&ptr, &p1)) {
				rtc.mday = (unsigned char)p1;
				get_number(&ptr, &p1); rtc.month = (unsigned char)p1;
				get_number(&ptr, &p1); rtc.year = (unsigned short)p1;
				get_number(&ptr, &p1); rtc.hour = (unsigned char)p1;
				get_number(&ptr, &p1); rtc.min = (unsigned char)p1;
				if (!get_number(&ptr, &p1)) break;
				rtc.sec = (unsigned char)p1;
				rtc_settime(&rtc);
			}
			rtc_gettime(&rtc);
			printf("%u/%u/%u %02u:%02u:%02u\r\n", rtc.mday, rtc.month, rtc.year, rtc.hour, rtc.min, rtc.sec);
			break;
		}
	}

}

