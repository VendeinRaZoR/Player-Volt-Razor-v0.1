;
;//***************************************************************************
;//  File........: Nokia6610_1.c
;//  Author(s)...: Goncharenko Valery and Chiper
;//  URL(s)......: http://digitalchip.ru
;//  Device(s)...: ATMega8
;//  Compiler....: Winavr-20100110
;//  Description.: Demo LCD Nokia6610
;//  Data........: 08.06.12
;//  Version.....: 1.0
;//***************************************************************************
;#include "menu.c"
;#include <mega328p.h>
;PCODE: $00000000 VOL: 0
	#ifndef __SLEEP_DEFINED__
;PCODE: $00000001 VOL: 0
	#define __SLEEP_DEFINED__
;PCODE: $00000002 VOL: 0
	.EQU __se_bit=0x01
;PCODE: $00000003 VOL: 0
	.EQU __sm_mask=0x0E
;PCODE: $00000004 VOL: 0
	.EQU __sm_adc_noise_red=0x02
;PCODE: $00000005 VOL: 0
	.EQU __sm_powerdown=0x04
;PCODE: $00000006 VOL: 0
	.EQU __sm_powersave=0x06
;PCODE: $00000007 VOL: 0
	.EQU __sm_standby=0x0C
;PCODE: $00000008 VOL: 0
	.EQU __sm_ext_standby=0x0E
;PCODE: $00000009 VOL: 0
	.SET power_ctrl_reg=smcr
;PCODE: $0000000A VOL: 0
	#endif
;PCODE: $0000000B VOL: 0
;PCODE: $0000000C VOL: 0
;#include <io.h>              // Библиотека ввода-вывода
;#include <delay.h>          // Библиотека задержек
;#include <pgmspace.h>
;#include <stdio.h>
;#include <stdlib.h>
;#include "Nokia6610_lcd_lib.c"   // Подключаем драйвер LCD Nokia6610 ( ONLY PCF8833 )
;//***************************************************************************
;//  File........: Nokia6610_lcd_lib.c
;//  Author(s)...: Goncharenko Valery and Chiper
;//  URL(s)......: http://digitalchip.ru
;//  Device(s)...: ATMega8
;//  Compiler....: Winavr-20100110
;//  Description.: Драйвер LCD Nokia6610 ( ONLY PCF8833 )
;//  Data........: 08.06.12
;//  Version.....: 1.0
;//***************************************************************************
;//  Notice: Все управляющие контакты LCD-контроллера должны быть подключены к
;//  одному и тому же порту на микроконтроллере
;//***************************************************************************
;#include "Nokia6610_lcd_lib.h"
;#include <delay.h>
;#include <pgmspace.h> //на всякий случай
;#include "Nokia6610_fnt8x8.h"
;
;//******************************************************************************
;//  Инициализация контроллера PCF8833
;void nlcd_Init(void)
; 0000 000C {

	.CSEG
;PCODE: $0000000D VOL: 0
;PCODE: $0000000E VOL: 0
;
;	CS_LCD_RESET;
;PCODE: $0000000F VOL: 0
;PCODE: $00000010 VOL: 0
;	SDA_LCD_RESET;
;PCODE: $00000011 VOL: 0
;PCODE: $00000012 VOL: 0
;	SCLK_LCD_SET;
;PCODE: $00000013 VOL: 0
;PCODE: $00000014 VOL: 0
;
;	RST_LCD_SET;    //     **********************************************
;PCODE: $00000015 VOL: 0
;PCODE: $00000016 VOL: 0
;	RST_LCD_RESET;  //     *                                             *
;PCODE: $00000017 VOL: 0
;PCODE: $00000018 VOL: 0
;	delay_ms(1);   //     *  Задержка для отработки апаратного сброса   *
;PCODE: $00000019 VOL: 0
;PCODE: $0000001A VOL: 0
;PCODE: $0000001B VOL: 0
;	RST_LCD_SET;    //     *                                             *
;PCODE: $0000001C VOL: 0
;PCODE: $0000001D VOL: 0
;                    //     **********************************************
;  //  SCLK_LCD_SET;
;    SDA_LCD_SET;
;PCODE: $0000001E VOL: 0
;PCODE: $0000001F VOL: 0
;  //  SCLK_LCD_SET;
;     delay_ms(1);
;PCODE: $00000020 VOL: 0
;PCODE: $00000021 VOL: 0
;PCODE: $00000022 VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_SWRESET);   //    Программный сброс
;PCODE: $00000023 VOL: 0
;PCODE: $00000024 VOL: 0
;    delay_ms(1);
;PCODE: $00000025 VOL: 0
;PCODE: $00000026 VOL: 0
;PCODE: $00000027 VOL: 0
;	nlcd_SendCmd(LCD_PHILLIPS_SLEEPOUT);  //    Выход из режима сна
;PCODE: $00000028 VOL: 0
;PCODE: $00000029 VOL: 0
;     delay_ms(1);
;PCODE: $0000002A VOL: 0
;PCODE: $0000002B VOL: 0
;PCODE: $0000002C VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_BSTRON);    //    Вкл. повышающий преобразователь напряжения
;PCODE: $0000002D VOL: 0
;PCODE: $0000002E VOL: 0
;    delay_ms(1);                     //    Задержка для отработки команды и выравнивания напряжения
;PCODE: $0000002F VOL: 0
;PCODE: $00000030 VOL: 0
;PCODE: $00000031 VOL: 0
;	nlcd_SendCmd(LCD_PHILLIPS_DISPON);    //    Дисплей вкл.
;PCODE: $00000032 VOL: 0
;PCODE: $00000033 VOL: 0
;     delay_ms(1);
;PCODE: $00000034 VOL: 0
;PCODE: $00000035 VOL: 0
;PCODE: $00000036 VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_NORON);     //    Дисплей нормальный - вкл.
;PCODE: $00000037 VOL: 0
;PCODE: $00000038 VOL: 0
;    delay_ms(1);
;PCODE: $00000039 VOL: 0
;PCODE: $0000003A VOL: 0
;PCODE: $0000003B VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_SETCON);    //            Контрастность
;PCODE: $0000003C VOL: 0
;PCODE: $0000003D VOL: 0
;     delay_ms(1);
;PCODE: $0000003E VOL: 0
;PCODE: $0000003F VOL: 0
;PCODE: $00000040 VOL: 0
;    nlcd_SendDataByte(0x3F);     //         0x00-min   0x3F-max
;PCODE: $00000041 VOL: 0
;PCODE: $00000042 VOL: 0
;      delay_ms(1);
;PCODE: $00000043 VOL: 0
;PCODE: $00000044 VOL: 0
;PCODE: $00000045 VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_CASET);     //    Установка начального и конечного адреса колонки
;PCODE: $00000046 VOL: 0
;PCODE: $00000047 VOL: 0
;	nlcd_SendDataByte(0);        //
;PCODE: $00000048 VOL: 0
;PCODE: $00000049 VOL: 0
;	nlcd_SendDataByte(131);      //
;PCODE: $0000004A VOL: 0
;PCODE: $0000004B VOL: 0
;	nlcd_SendCmd(LCD_PHILLIPS_PASET);     //     Установка начального и конечного адреса страницы
;PCODE: $0000004C VOL: 0
;PCODE: $0000004D VOL: 0
;	nlcd_SendDataByte(0);        //
;PCODE: $0000004E VOL: 0
;PCODE: $0000004F VOL: 0
;	nlcd_SendDataByte(131);      //
;PCODE: $00000050 VOL: 0
;PCODE: $00000051 VOL: 0
;                                           //    ******************************************************
;    nlcd_SendCmd(LCD_PHILLIPS_COLMOD);    //   *               Вывод цвета:                          *
;PCODE: $00000052 VOL: 0
;PCODE: $00000053 VOL: 0
; // nlcd_SendByte(DATA_LCD_MODE,0x02);     //   *     8 бит на пиксель- 256 цветов RGB 4:4:4           *
;	nlcd_SendDataByte(0x03);     //  *     12 бит на пиксель- 4096 цветов RGB 3:3:2  (выигрыш в быстродекйствии)         *
;PCODE: $00000054 VOL: 0
;PCODE: $00000055 VOL: 0
;//  nlcd_SendByte(DATA_LCD_MODE,0x05);     //  *     16 бит на пиксель-65535 цветов RGB 5:6:5           *
;	                                       //  **********************************************************
;	delay_ms(1);
;PCODE: $00000056 VOL: 0
;PCODE: $00000057 VOL: 0
;PCODE: $00000058 VOL: 0
; // nlcd_SendByte(CMD_LCD_MODE,MADCTL);    //    Команда доступа к условиям отображения памяти RAM
;//  nlcd_SendByte(DATA_LCD_MODE,0x30);     //   1-byte, по умолчанию 0х00 - курим внимательно даташит
;	                                       //                на стр. 43
;	nlcd_SendCmd(LCD_PHILLIPS_RAMWR);     //    Запись данных в RAM дисплея
;PCODE: $00000059 VOL: 0
;PCODE: $0000005A VOL: 0
;	delay_ms(1);                          //    Немного ждем
;PCODE: $0000005B VOL: 0
;PCODE: $0000005C VOL: 0
;PCODE: $0000005D VOL: 0
;	nlcd_SendCmd(LCD_PHILLIPS_DISPOFF);   //    Выключаем дисплей чтобы не наблюдать мусор на экране
;PCODE: $0000005E VOL: 0
;PCODE: $0000005F VOL: 0
;	nlcd_Clear(WHITE);// очистка не нужна, так как есть буффер //nlcd_Clear(BLACK);   //    Заливаем весь дисплей будущим ф ...
;PCODE: $00000060 VOL: 0
;PCODE: $00000061 VOL: 0
;    nlcd_RenderPixelBuffer();
;PCODE: $00000062 VOL: 0
;    nlcd_SendCmd(LCD_PHILLIPS_DISPON);    //    Дисплей вкл.
;PCODE: $00000063 VOL: 0
;PCODE: $00000064 VOL: 0
;}
;PCODE: $00000065 VOL: 0
;PCODE: $00000066 VOL: 0
;
;//#if HARDWARE SPI
;void nlcd_InitSPI()
;{
;PCODE: $00000067 VOL: 0
;PCODE: $00000068 VOL: 0
;DDR_LCD |= (1<<SCLK_LCD_PIN)|(1<<SDA_LCD_PIN)|(1<<CS_LCD_PIN)|(1<<RST_LCD_PIN)|(1<<CS_SRAM_PIN);
;PCODE: $00000069 VOL: 0
;PCODE: $0000006A VOL: 0
;PCODE: $0000006B VOL: 0
;DDRC |= (1<<HOLD_SRAM_PIN);
;PCODE: $0000006C VOL: 0
;PCODE: $0000006D VOL: 0
;}
;PCODE: $0000006E VOL: 0
;PCODE: $0000006F VOL: 0
;
;//******************************************************************************
;//  Передача байта (команды или данных) на LCD-контроллер
;//  mode: CMD_LCD_MODE  - передаем команду
;//		  DATA_LCD_MODE - передаем данные
;//  c:    значение передаваемого байта
;
;/*void nlcd_SendByte(char mode,unsigned char c)
;{
;unsigned char i=0;
;   CS_LCD_RESET;
;   SCLK_LCD_RESET;
; if(mode) SDA_LCD_SET;
;	 else	 SDA_LCD_RESET;
;     SCLK_LCD_SET;
;// SPCR |= (1<<SPE);
;//   SPDR = c;
; //  while(!(SPSR & (1<<SPIF)));
;//   SPCR |= (0<<SPE);
;    for(i=0;i<8;i++)
;    {
;    	SCLK_LCD_RESET;
;        if(c & 0x80) SDA_LCD_SET;
;        else	     SDA_LCD_RESET;
;        SCLK_LCD_SET;
;        c <<= 1;
;        delay_us(NLCD_MIN_DELAY);
;    }
;   CS_LCD_SET;
;}      */
;
;void nlcd_SendCmd(unsigned char c)
;{
;PCODE: $00000070 VOL: 0
;PCODE: $00000071 VOL: 0
;#asm
;PCODE: $00000072 VOL: 0
;	c -> Y+0
;PCODE: $00000073 VOL: 0
{
;PCODE: $00000074 VOL: 0
	CBI  0x5,2
;PCODE: $00000075 VOL: 0
    CBI  0x5,5
;PCODE: $00000076 VOL: 0
    CBI  0x5,3
;PCODE: $00000077 VOL: 0
    SBI  0x5,5
;PCODE: $00000078 VOL: 0
}
;PCODE: $00000079 VOL: 0
;PCODE: $0000007A VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $0000007B VOL: 0
;PCODE: $0000007C VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $0000007D VOL: 0
;PCODE: $0000007E VOL: 0
;SPDR = c;
;PCODE: $0000007F VOL: 0
;PCODE: $00000080 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000081 VOL: 0
;PCODE: $00000082 VOL: 0
;PCODE: $00000083 VOL: 0
;PCODE: $00000084 VOL: 0
;PCODE: $00000085 VOL: 0
;PCODE: $00000086 VOL: 0
;SPCR = 0;
;PCODE: $00000087 VOL: 0
;PCODE: $00000088 VOL: 0
;SPSR = 0;
;PCODE: $00000089 VOL: 0
;PCODE: $0000008A VOL: 0
;#asm
;PCODE: $0000008B VOL: 0
{
;PCODE: $0000008C VOL: 0
SBI  0x5,2
;PCODE: $0000008D VOL: 0
CBI  0x5,5
;PCODE: $0000008E VOL: 0
}
;PCODE: $0000008F VOL: 0
;PCODE: $00000090 VOL: 0
;}
;PCODE: $00000091 VOL: 0
;PCODE: $00000092 VOL: 0
;PCODE: $00000093 VOL: 0
;
;void nlcd_SendDataByte(unsigned char c)
;{
;PCODE: $00000094 VOL: 0
;PCODE: $00000095 VOL: 0
;#asm
;PCODE: $00000096 VOL: 0
;	c -> Y+0
;PCODE: $00000097 VOL: 0
{
;PCODE: $00000098 VOL: 0
	CBI  0x5,2
;PCODE: $00000099 VOL: 0
    CBI  0x5,5
;PCODE: $0000009A VOL: 0
    SBI  0x5,3
;PCODE: $0000009B VOL: 0
    SBI  0x5,5
;PCODE: $0000009C VOL: 0
}
;PCODE: $0000009D VOL: 0
;PCODE: $0000009E VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $0000009F VOL: 0
;PCODE: $000000A0 VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $000000A1 VOL: 0
;PCODE: $000000A2 VOL: 0
;SPDR = c;
;PCODE: $000000A3 VOL: 0
;PCODE: $000000A4 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000000A5 VOL: 0
;PCODE: $000000A6 VOL: 0
;PCODE: $000000A7 VOL: 0
;PCODE: $000000A8 VOL: 0
;PCODE: $000000A9 VOL: 0
;PCODE: $000000AA VOL: 0
;SPCR = 0;
;PCODE: $000000AB VOL: 0
;PCODE: $000000AC VOL: 0
;SPSR = 0;
;PCODE: $000000AD VOL: 0
;PCODE: $000000AE VOL: 0
;#asm
;PCODE: $000000AF VOL: 0
{
;PCODE: $000000B0 VOL: 0
SBI  0x5,2
;PCODE: $000000B1 VOL: 0
}
;PCODE: $000000B2 VOL: 0
;PCODE: $000000B3 VOL: 0
;}
;PCODE: $000000B4 VOL: 0
;PCODE: $000000B5 VOL: 0
;PCODE: $000000B6 VOL: 0
;   /*
;void nlcd_SendDataByte2(unsigned char a,unsigned char b)
;{
;#asm
;{
;	CBI  0x5,2
;    CBI  0x5,5
;}
;#endasm
;//First byte
;#asm
;{
;    CBI  0x5,5
;    SBI  0x5,3
;    SBI  0x5,5
;}
;#endasm
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(0<<SPR1)|(0<<SPR0);
;SPSR = (1<<SPI2X);
;SPDR = a;
;while(!(SPSR & (1<<SPIF)));
;SPCR = 0;
;SPSR = 0;
;//Second byte
;#asm
;{
;    CBI  0x5,5
;    SBI  0x5,3
;    SBI  0x5,5
;}
;#endasm
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(0<<SPR1)|(0<<SPR0);
;SPSR = (1<<SPI2X);
;SPDR = b;
;while(!(SPSR & (1<<SPIF)));
;SPCR = 0;
;SPSR = 0;
;#asm
;{
;SBI  0x18,2
;}
;#endasm
;}
;
;void nlcd_SendDataByte3(unsigned char a,unsigned char b,unsigned char c)
;{
;#asm
;{
;	CBI  0x18,2
;}
;#endasm
;//First byte
;#asm
;{
;    CBI  0x18,5
;    SBI  0x18,3
;    SBI  0x18,5
;}
;#endasm
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(0<<SPR1)|(0<<SPR0);
;SPSR = (1<<SPI2X);
;SPDR = a;
;while(!(SPSR & (1<<SPIF)));
;SPCR = 0;
;SPSR = 0;
;//Second byte
;#asm
;{
;    CBI  0x18,5
;    SBI  0x18,3
;    SBI  0x18,5
;}
;#endasm
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(0<<SPR1)|(0<<SPR0);
;SPSR = (1<<SPI2X);
;SPDR = b;
;while(!(SPSR & (1<<SPIF)));
;SPCR = 0;
;SPSR = 0;
;//Third byte
;#asm
;{
;    CBI  0x18,5
;    SBI  0x18,3
;    SBI  0x18,5
;}
;#endasm
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(0<<SPR1)|(0<<SPR0);
;SPSR = (1<<SPI2X);
;SPDR = c;
;while(!(SPSR & (1<<SPIF)));
;SPCR = 0;
;SPSR = 0;
;#asm
;{
;SBI  0x18,2
;}
;#endasm
;} */
;
;//******************************************************************************
;//	Имя: 		 GotoXY(unsigned char x, unsigned char y)
;// 	Описание:    Переход в позицию x, y
;//           	 GotoXY( x, y)
;//	Параметры:   x: позиция 0-131
;//			     y: позиция 0-131
;//  Пример:		 GotoXY(32,17);
;//******************************************************************************
;void nlcd_GotoXY(unsigned char x, unsigned char y)
;{
;PCODE: $000000B7 VOL: 0
;PCODE: $000000B8 VOL: 0
;  /// Useful Anymore with buffer
;}
;PCODE: $000000B9 VOL: 0
;PCODE: $000000BA VOL: 0
;PCODE: $000000BB VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_Pixel(unsigned char x, unsigned char y, int color)
;// 	Описание:    Устанавливает Pixel в позицию x, y, цветом color
;//           	 nlcd_Pixel( x, y,color)
;//	Параметры:   x:     позиция 0-131
;//			     y:     позиция 0-131
;//               color: цвет (12-bit см. #define)
;//  Пример:		 nlcd_Pixel(21,45,BLACK);
;//******************************************************************************
;void nlcd_PixelBox2x2(unsigned char x, unsigned char y, int P1_color,int P2_color, int P3_color, int P4_color)   ///R сл ...
;{
;PCODE: $000000BC VOL: 0
;PCODE: $000000BD VOL: 0
;    unsigned char a = (P1_color >> 4);
;    unsigned char b = ((P1_color ) << 4) | ((P2_color >> 8) );
;    unsigned char c = P2_color;
;    unsigned char e = (P3_color >> 4);
;    unsigned char f = ((P3_color ) << 4) | ((P4_color >> 8) );
;    unsigned char g = P4_color;
;    unsigned char pBufferSlice[6];
;    pBufferSlice[0] = a;
;PCODE: $000000BE VOL: 0
;PCODE: $000000BF VOL: 0
;PCODE: $000000C0 VOL: 0
;	x -> Y+21
;	y -> Y+20
;	P1_color -> Y+18
;	P2_color -> Y+16
;	P3_color -> Y+14
;	P4_color -> Y+12
;	a -> R17
;	b -> R16
;	c -> R19
;	e -> R18
;	f -> R21
;	g -> R20
;	pBufferSlice -> Y+6
;PCODE: $000000C1 VOL: 0
;PCODE: $000000C2 VOL: 0
;PCODE: $000000C3 VOL: 0
;PCODE: $000000C4 VOL: 0
;PCODE: $000000C5 VOL: 0
;PCODE: $000000C6 VOL: 0
;PCODE: $000000C7 VOL: 0
;PCODE: $000000C8 VOL: 0
;PCODE: $000000C9 VOL: 0
;PCODE: $000000CA VOL: 0
;PCODE: $000000CB VOL: 0
;PCODE: $000000CC VOL: 0
;PCODE: $000000CD VOL: 0
;PCODE: $000000CE VOL: 0
;PCODE: $000000CF VOL: 0
;PCODE: $000000D0 VOL: 0
;PCODE: $000000D1 VOL: 0
;PCODE: $000000D2 VOL: 0
;PCODE: $000000D3 VOL: 0
;PCODE: $000000D4 VOL: 0
;PCODE: $000000D5 VOL: 0
;PCODE: $000000D6 VOL: 0
;PCODE: $000000D7 VOL: 0
;PCODE: $000000D8 VOL: 0
;PCODE: $000000D9 VOL: 0
;PCODE: $000000DA VOL: 0
;    pBufferSlice[1] = b;
;PCODE: $000000DB VOL: 0
;PCODE: $000000DC VOL: 0
;    pBufferSlice[2] = c;
;PCODE: $000000DD VOL: 0
;PCODE: $000000DE VOL: 0
;    pBufferSlice[3] = e;
;PCODE: $000000DF VOL: 0
;PCODE: $000000E0 VOL: 0
;    pBufferSlice[4] = f;
;PCODE: $000000E1 VOL: 0
;PCODE: $000000E2 VOL: 0
;    pBufferSlice[5] = g;
;PCODE: $000000E3 VOL: 0
;PCODE: $000000E4 VOL: 0
;    x /= 2;
;PCODE: $000000E5 VOL: 0
;PCODE: $000000E6 VOL: 0
;PCODE: $000000E7 VOL: 0
;PCODE: $000000E8 VOL: 0
;PCODE: $000000E9 VOL: 0
;  // Пишем в RAM
;   nlcd_WritePixelBuffer((y*3*(RESRAM_X) + 3*(x)),&pBufferSlice[0],3);
;PCODE: $000000EA VOL: 0
;PCODE: $000000EB VOL: 0
;PCODE: $000000EC VOL: 0
;PCODE: $000000ED VOL: 0
;PCODE: $000000EE VOL: 0
;PCODE: $000000EF VOL: 0
;PCODE: $000000F0 VOL: 0
;PCODE: $000000F1 VOL: 0
;PCODE: $000000F2 VOL: 0
;PCODE: $000000F3 VOL: 0
;PCODE: $000000F4 VOL: 0
;PCODE: $000000F5 VOL: 0
;PCODE: $000000F6 VOL: 0
;PCODE: $000000F7 VOL: 0
;PCODE: $000000F8 VOL: 0
;PCODE: $000000F9 VOL: 0
;   nlcd_WritePixelBuffer(((y+1)*3*(RESRAM_X) + 3*(x)),&pBufferSlice[3],3);
;PCODE: $000000FA VOL: 0
;PCODE: $000000FB VOL: 0
;PCODE: $000000FC VOL: 0
;PCODE: $000000FD VOL: 0
;PCODE: $000000FE VOL: 0
;PCODE: $000000FF VOL: 0
;PCODE: $00000100 VOL: 0
;PCODE: $00000101 VOL: 0
;PCODE: $00000102 VOL: 0
;PCODE: $00000103 VOL: 0
;PCODE: $00000104 VOL: 0
;PCODE: $00000105 VOL: 0
;PCODE: $00000106 VOL: 0
;PCODE: $00000107 VOL: 0
;PCODE: $00000108 VOL: 0
;PCODE: $00000109 VOL: 0
;PCODE: $0000010A VOL: 0
;PCODE: $0000010B VOL: 0
;}
;PCODE: $0000010C VOL: 0
;PCODE: $0000010D VOL: 0
;PCODE: $0000010E VOL: 0
;PCODE: $0000010F VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_Pixel(unsigned char x, unsigned char y, int color)
;// 	Описание:    Устанавливает Pixel в позицию x, y, цветом color
;//           	 nlcd_Pixel( x, y,color)
;//	Параметры:   x:     позиция 0-131
;//			     y:     позиция 0-131
;//               color: цвет (12-bit см. #define)
;//  Пример:		 nlcd_Pixel(21,45,BLACK);
;//******************************************************************************
;void nlcd_PixelLine2x1(unsigned char x, unsigned char y, int P1_color, int P2_color)   ///R следующие пикселя = 0
;{
;PCODE: $00000110 VOL: 0
;PCODE: $00000111 VOL: 0
;    unsigned char a = (P1_color >> 4);
;    unsigned char b = ((P1_color ) << 4) | ((P2_color >> 8) );
;    unsigned char c = P2_color;
;    unsigned char pBufferSlice[3];
;    pBufferSlice[0] = a;
;PCODE: $00000112 VOL: 0
;PCODE: $00000113 VOL: 0
;PCODE: $00000114 VOL: 0
;	x -> Y+12
;	y -> Y+11
;	P1_color -> Y+9
;	P2_color -> Y+7
;	a -> R17
;	b -> R16
;	c -> R19
;	pBufferSlice -> Y+4
;PCODE: $00000115 VOL: 0
;PCODE: $00000116 VOL: 0
;PCODE: $00000117 VOL: 0
;PCODE: $00000118 VOL: 0
;PCODE: $00000119 VOL: 0
;PCODE: $0000011A VOL: 0
;PCODE: $0000011B VOL: 0
;PCODE: $0000011C VOL: 0
;PCODE: $0000011D VOL: 0
;PCODE: $0000011E VOL: 0
;PCODE: $0000011F VOL: 0
;PCODE: $00000120 VOL: 0
;PCODE: $00000121 VOL: 0
;PCODE: $00000122 VOL: 0
;    pBufferSlice[1] = b;
;PCODE: $00000123 VOL: 0
;PCODE: $00000124 VOL: 0
;    pBufferSlice[2] = c;
;PCODE: $00000125 VOL: 0
;PCODE: $00000126 VOL: 0
;    x /= 2;
;PCODE: $00000127 VOL: 0
;PCODE: $00000128 VOL: 0
;PCODE: $00000129 VOL: 0
;PCODE: $0000012A VOL: 0
;PCODE: $0000012B VOL: 0
;   // iff(x%2)x/=2;
;  // Пишем в RAM
;   nlcd_WritePixelBuffer((y*3*(RESRAM_X) + 3*(x)),&pBufferSlice[0],3);
;PCODE: $0000012C VOL: 0
;PCODE: $0000012D VOL: 0
;PCODE: $0000012E VOL: 0
;PCODE: $0000012F VOL: 0
;PCODE: $00000130 VOL: 0
;PCODE: $00000131 VOL: 0
;PCODE: $00000132 VOL: 0
;PCODE: $00000133 VOL: 0
;PCODE: $00000134 VOL: 0
;PCODE: $00000135 VOL: 0
;PCODE: $00000136 VOL: 0
;PCODE: $00000137 VOL: 0
;PCODE: $00000138 VOL: 0
;PCODE: $00000139 VOL: 0
;PCODE: $0000013A VOL: 0
;PCODE: $0000013B VOL: 0
;}
;PCODE: $0000013C VOL: 0
;PCODE: $0000013D VOL: 0
;PCODE: $0000013E VOL: 0
;PCODE: $0000013F VOL: 0
;
;void nlcd_HorizontalLine(unsigned char y, int color)
;{
;PCODE: $00000140 VOL: 0
;PCODE: $00000141 VOL: 0
;int i = 0;
;for(i=0;i<131;i++)
;PCODE: $00000142 VOL: 0
;PCODE: $00000143 VOL: 0
;PCODE: $00000144 VOL: 0
;	y -> Y+4
;	color -> Y+2
;	i -> R16,R17
;PCODE: $00000145 VOL: 0
;PCODE: $00000146 VOL: 0
;PCODE: $00000147 VOL: 0
;PCODE: $00000148 VOL: 0
;PCODE: $00000149 VOL: 0
;PCODE: $0000014A VOL: 0
;PCODE: $0000014B VOL: 0
;PCODE: $0000014C VOL: 0
;PCODE: $0000014D VOL: 0
;PCODE: $0000014E VOL: 0
;PCODE: $0000014F VOL: 0
;nlcd_PixelLine2x1(i,y,color,color);
;PCODE: $00000150 VOL: 0
;PCODE: $00000151 VOL: 0
;PCODE: $00000152 VOL: 0
;PCODE: $00000153 VOL: 0
;PCODE: $00000154 VOL: 0
;PCODE: $00000155 VOL: 0
;PCODE: $00000156 VOL: 0
;PCODE: $00000157 VOL: 0
;PCODE: $00000158 VOL: 0
;PCODE: $00000159 VOL: 0
;PCODE: $0000015A VOL: 0
;PCODE: $0000015B VOL: 0
;PCODE: $0000015C VOL: 0
;PCODE: $0000015D VOL: 0
;PCODE: $0000015E VOL: 0
;PCODE: $0000015F VOL: 0
;PCODE: $00000160 VOL: 0
;PCODE: $00000161 VOL: 0
;PCODE: $00000162 VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_Line(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, int color)
;// 	Описание:    Рисует линию из координаты x0, y0 в координату x1, y1 цветом color
;//           	 nlcd_Line(x0, y0, x1, y1, color)
;//	Параметры:   x:     позиция 0-131
;//			     y:     позиция 0-131
;//               color: цвет (12-bit см. #define)
;//  Пример:		 nlcd_Pixel(25,60,25,80,RED);
;//******************************************************************************
;/*void nlcd_Line(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, int color)
;{
;
;   int dy = y1 - y0;
;   int dx = x1 - x0;
;   int stepx, stepy;
;   if (dy < 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }
;   if (dx < 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }
;
;   dy <<= 1;                              // dy is now 2*dy
;   dx <<= 1;                              // dx is now 2*dx
;
;
;   nlcd_Pixel(x0, y0, color);
;
;   if (dx > dy)
;   {
;       int fraction = dy - (dx >> 1);     // same as 2*dy - dx
;       while (x0 != x1)
;	   {
; 	       if (fraction >= 0)
;		   {
; 		       y0 += stepy;
;               fraction -= dx;            // same as fraction -= 2*dx
; 		   }
; 		x0 += stepx;
;        fraction += dy;                   // same as fraction -= 2*dy
;        nlcd_Pixel(x0, y0, color);
;       }
;   }
; 	else
;    {
; 	    int fraction = dx - (dy >> 1);
;        while (y0 != y1)
;		{
; 		    if (fraction >= 0)
;		    {
; 		        x0 += stepx;
; 				fraction -= dy;
;            }
;        y0 += stepy;
; 	    fraction += dx;
;        nlcd_Pixel(x0, y0, color);
;        }
; 	}
;
;}    */
;
;//******************************************************************************
;//	Имя: 		 nlcd_InitPixelBuffer(int mode)
;// 	Описание:    Инициализация пиксельного буффера, режим mode - в регистр статуса буффера
;//           	 nlcd_Lnlcd_InitPixelBufferine(mode)
;//	Параметры:
;//  Пример:		 nlcd_InitPixelBuffer(mode);
;//******************************************************************************
;// Работа с SRAM 23X256
;void nlcd_InitPixelBuffer(int mode)
;{
;PCODE: $00000163 VOL: 0
;PCODE: $00000164 VOL: 0
;unsigned char inst = mode<<__MODE_BITS;
;CS_SRAM_RESET;
;PCODE: $00000165 VOL: 0
;PCODE: $00000166 VOL: 0
;	mode -> Y+1
;	inst -> R17
;PCODE: $00000167 VOL: 0
;PCODE: $00000168 VOL: 0
;PCODE: $00000169 VOL: 0
;PCODE: $0000016A VOL: 0
;PCODE: $0000016B VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $0000016C VOL: 0
;PCODE: $0000016D VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $0000016E VOL: 0
;PCODE: $0000016F VOL: 0
;SPDR = __WRSR_INST;
;PCODE: $00000170 VOL: 0
;PCODE: $00000171 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000172 VOL: 0
;PCODE: $00000173 VOL: 0
;PCODE: $00000174 VOL: 0
;PCODE: $00000175 VOL: 0
;PCODE: $00000176 VOL: 0
;PCODE: $00000177 VOL: 0
;SPDR = inst & __MODE_MASK;
;PCODE: $00000178 VOL: 0
;PCODE: $00000179 VOL: 0
;PCODE: $0000017A VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $0000017B VOL: 0
;PCODE: $0000017C VOL: 0
;PCODE: $0000017D VOL: 0
;PCODE: $0000017E VOL: 0
;PCODE: $0000017F VOL: 0
;PCODE: $00000180 VOL: 0
;SPCR = 0;
;PCODE: $00000181 VOL: 0
;PCODE: $00000182 VOL: 0
;SPSR = 0;
;PCODE: $00000183 VOL: 0
;PCODE: $00000184 VOL: 0
;CS_SRAM_SET;
;PCODE: $00000185 VOL: 0
;PCODE: $00000186 VOL: 0
;}
;PCODE: $00000187 VOL: 0
;PCODE: $00000188 VOL: 0
;PCODE: $00000189 VOL: 0
;PCODE: $0000018A VOL: 0
;PCODE: $0000018B VOL: 0
;//******************************************************************************
;//	Имя: 		 nlcd_WritePixelBuffer(int startaddr, unsigned char* data, int length)
;// 	Описание:    Чтение в пиксельный буффер, режим чтения - непрерывный, массив (Stquently, array)
;//           	 nlcd_WritePixelBuffer(startaddr,&data[0],length)
;//	Параметры:
;//  Пример:		 nlcd_WritePixelBuffer(startaddr,&data[0],length);
;//******************************************************************************
;// Работа с SRAM 23X256
;void nlcd_WritePixelBuffer(int startaddr, unsigned char* data, int length)
;{
;PCODE: $0000018C VOL: 0
;PCODE: $0000018D VOL: 0
;int i;
;CS_SRAM_RESET;
;PCODE: $0000018E VOL: 0
;PCODE: $0000018F VOL: 0
;PCODE: $00000190 VOL: 0
;	startaddr -> Y+6
;	*data -> Y+4
;	length -> Y+2
;	i -> R16,R17
;PCODE: $00000191 VOL: 0
;PCODE: $00000192 VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $00000193 VOL: 0
;PCODE: $00000194 VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $00000195 VOL: 0
;PCODE: $00000196 VOL: 0
;SPDR = __WRITE_INST;
;PCODE: $00000197 VOL: 0
;PCODE: $00000198 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000199 VOL: 0
;PCODE: $0000019A VOL: 0
;PCODE: $0000019B VOL: 0
;PCODE: $0000019C VOL: 0
;PCODE: $0000019D VOL: 0
;PCODE: $0000019E VOL: 0
;SPDR = startaddr>>8;
;PCODE: $0000019F VOL: 0
;PCODE: $000001A0 VOL: 0
;PCODE: $000001A1 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001A2 VOL: 0
;PCODE: $000001A3 VOL: 0
;PCODE: $000001A4 VOL: 0
;PCODE: $000001A5 VOL: 0
;PCODE: $000001A6 VOL: 0
;PCODE: $000001A7 VOL: 0
;SPDR = startaddr;
;PCODE: $000001A8 VOL: 0
;PCODE: $000001A9 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001AA VOL: 0
;PCODE: $000001AB VOL: 0
;PCODE: $000001AC VOL: 0
;PCODE: $000001AD VOL: 0
;PCODE: $000001AE VOL: 0
;PCODE: $000001AF VOL: 0
;  for(i=0; i<length; i++)
;PCODE: $000001B0 VOL: 0
;PCODE: $000001B1 VOL: 0
;PCODE: $000001B2 VOL: 0
;PCODE: $000001B3 VOL: 0
;PCODE: $000001B4 VOL: 0
;PCODE: $000001B5 VOL: 0
;PCODE: $000001B6 VOL: 0
;PCODE: $000001B7 VOL: 0
;PCODE: $000001B8 VOL: 0
;  {
;SPDR = data[i];
;PCODE: $000001B9 VOL: 0
;PCODE: $000001BA VOL: 0
;PCODE: $000001BB VOL: 0
;PCODE: $000001BC VOL: 0
;PCODE: $000001BD VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001BE VOL: 0
;PCODE: $000001BF VOL: 0
;PCODE: $000001C0 VOL: 0
;PCODE: $000001C1 VOL: 0
;PCODE: $000001C2 VOL: 0
;PCODE: $000001C3 VOL: 0
;  }
;PCODE: $000001C4 VOL: 0
;PCODE: $000001C5 VOL: 0
;PCODE: $000001C6 VOL: 0
;PCODE: $000001C7 VOL: 0
;PCODE: $000001C8 VOL: 0
;SPCR = 0;
;PCODE: $000001C9 VOL: 0
;PCODE: $000001CA VOL: 0
;SPSR = 0;
;PCODE: $000001CB VOL: 0
;PCODE: $000001CC VOL: 0
;
;CS_SRAM_SET;
;PCODE: $000001CD VOL: 0
;PCODE: $000001CE VOL: 0
;}
;PCODE: $000001CF VOL: 0
;PCODE: $000001D0 VOL: 0
;PCODE: $000001D1 VOL: 0
;PCODE: $000001D2 VOL: 0
;PCODE: $000001D3 VOL: 0
;PCODE: $000001D4 VOL: 0
;PCODE: $000001D5 VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_ReadPixelBuffer(int startaddr, unsigned char* data, int length)
;// 	Описание:    Чтение в пиксельный буффер, режим чтения - непрерывный, массив (Stquently, array)
;//           	 nlcd_ReadPixelBuffer(startaddr,&data[0],length)
;//	Параметры:
;//  Пример:		 nlcd_ReadPixelBuffer(startaddr,&data[0],length);
;//******************************************************************************
;// Работа с SRAM 23X256
;void nlcd_ReadPixelBuffer(int startaddr, unsigned char* data, int length)
;{
;PCODE: $000001D6 VOL: 0
;PCODE: $000001D7 VOL: 0
;int i;
;CS_SRAM_RESET;
;PCODE: $000001D8 VOL: 0
;PCODE: $000001D9 VOL: 0
;PCODE: $000001DA VOL: 0
;	startaddr -> Y+6
;	*data -> Y+4
;	length -> Y+2
;	i -> R16,R17
;PCODE: $000001DB VOL: 0
;PCODE: $000001DC VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $000001DD VOL: 0
;PCODE: $000001DE VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $000001DF VOL: 0
;PCODE: $000001E0 VOL: 0
;SPDR = __READ_INST;
;PCODE: $000001E1 VOL: 0
;PCODE: $000001E2 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001E3 VOL: 0
;PCODE: $000001E4 VOL: 0
;PCODE: $000001E5 VOL: 0
;PCODE: $000001E6 VOL: 0
;PCODE: $000001E7 VOL: 0
;PCODE: $000001E8 VOL: 0
;SPDR = (startaddr)>>8;
;PCODE: $000001E9 VOL: 0
;PCODE: $000001EA VOL: 0
;PCODE: $000001EB VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001EC VOL: 0
;PCODE: $000001ED VOL: 0
;PCODE: $000001EE VOL: 0
;PCODE: $000001EF VOL: 0
;PCODE: $000001F0 VOL: 0
;PCODE: $000001F1 VOL: 0
;SPDR = startaddr;
;PCODE: $000001F2 VOL: 0
;PCODE: $000001F3 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000001F4 VOL: 0
;PCODE: $000001F5 VOL: 0
;PCODE: $000001F6 VOL: 0
;PCODE: $000001F7 VOL: 0
;PCODE: $000001F8 VOL: 0
;PCODE: $000001F9 VOL: 0
;  for(i=0; i<3; i++)
;PCODE: $000001FA VOL: 0
;PCODE: $000001FB VOL: 0
;PCODE: $000001FC VOL: 0
;PCODE: $000001FD VOL: 0
;PCODE: $000001FE VOL: 0
;PCODE: $000001FF VOL: 0
;PCODE: $00000200 VOL: 0
;PCODE: $00000201 VOL: 0
;PCODE: $00000202 VOL: 0
;  {
;  SPDR = __NULL_INST;
;PCODE: $00000203 VOL: 0
;PCODE: $00000204 VOL: 0
;  while(!(SPSR & (1<<SPIF)));
;PCODE: $00000205 VOL: 0
;PCODE: $00000206 VOL: 0
;PCODE: $00000207 VOL: 0
;PCODE: $00000208 VOL: 0
;PCODE: $00000209 VOL: 0
;PCODE: $0000020A VOL: 0
;  data[i] = SPDR;
;PCODE: $0000020B VOL: 0
;PCODE: $0000020C VOL: 0
;PCODE: $0000020D VOL: 0
;PCODE: $0000020E VOL: 0
;PCODE: $0000020F VOL: 0
;  }
;PCODE: $00000210 VOL: 0
;PCODE: $00000211 VOL: 0
;PCODE: $00000212 VOL: 0
;PCODE: $00000213 VOL: 0
;PCODE: $00000214 VOL: 0
;SPCR = 0;
;PCODE: $00000215 VOL: 0
;PCODE: $00000216 VOL: 0
;SPSR = 0;
;PCODE: $00000217 VOL: 0
;PCODE: $00000218 VOL: 0
;CS_SRAM_SET;
;PCODE: $00000219 VOL: 0
;PCODE: $0000021A VOL: 0
;}
;PCODE: $0000021B VOL: 0
;PCODE: $0000021C VOL: 0
;PCODE: $0000021D VOL: 0
;PCODE: $0000021E VOL: 0
;PCODE: $0000021F VOL: 0
;PCODE: $00000220 VOL: 0
;PCODE: $00000221 VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_RenderPixelBuffer()
;// 	Описание:    Рендер графического буффера
;//           	 nlcd_RenderPixelBuffer()
;//	Параметры:
;//  Пример:		 nlcd_RenderPixelBuffer();
;//******************************************************************************
;
;void nlcd_RenderPixelBuffer()
;{
;PCODE: $00000222 VOL: 0
;PCODE: $00000223 VOL: 0
;int i=0;
;int k=0;
;unsigned char ppBufferSlice[3];
;CS_SRAM_SET;
;PCODE: $00000224 VOL: 0
;PCODE: $00000225 VOL: 0
;	i -> R16,R17
;	k -> R18,R19
;	ppBufferSlice -> Y+4
;PCODE: $00000226 VOL: 0
;PCODE: $00000227 VOL: 0
;PCODE: $00000228 VOL: 0
;PCODE: $00000229 VOL: 0
;PCODE: $0000022A VOL: 0
;PCODE: $0000022B VOL: 0
;CS_LCD_RESET;
;PCODE: $0000022C VOL: 0
;PCODE: $0000022D VOL: 0
; nlcd_SendCmd(LCD_PHILLIPS_PASET);   // Команда адреса страницы RAM
;PCODE: $0000022E VOL: 0
;PCODE: $0000022F VOL: 0
;   nlcd_SendDataByte(0);      // Старт
;PCODE: $00000230 VOL: 0
;PCODE: $00000231 VOL: 0
;   nlcd_SendDataByte(131);
;PCODE: $00000232 VOL: 0
;PCODE: $00000233 VOL: 0
;   nlcd_SendCmd(LCD_PHILLIPS_CASET);
;PCODE: $00000234 VOL: 0
;PCODE: $00000235 VOL: 0
;   nlcd_SendDataByte(0);
;PCODE: $00000236 VOL: 0
;PCODE: $00000237 VOL: 0
;   nlcd_SendDataByte(131);      //
;PCODE: $00000238 VOL: 0
;PCODE: $00000239 VOL: 0
;nlcd_SendCmd(LCD_PHILLIPS_RAMWR);
;PCODE: $0000023A VOL: 0
;PCODE: $0000023B VOL: 0
;for(i=0;i < 8712;i++)
;PCODE: $0000023C VOL: 0
;PCODE: $0000023D VOL: 0
;PCODE: $0000023E VOL: 0
;PCODE: $0000023F VOL: 0
;PCODE: $00000240 VOL: 0
;PCODE: $00000241 VOL: 0
;PCODE: $00000242 VOL: 0
;PCODE: $00000243 VOL: 0
;PCODE: $00000244 VOL: 0
;{
;//First Read Pixel Buffer Slice (slice for 3 pixels)
;CS_LCD_SET;
;PCODE: $00000245 VOL: 0
;PCODE: $00000246 VOL: 0
;CS_SRAM_RESET;
;PCODE: $00000247 VOL: 0
;PCODE: $00000248 VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $00000249 VOL: 0
;PCODE: $0000024A VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $0000024B VOL: 0
;PCODE: $0000024C VOL: 0
;SPDR = __READ_INST;
;PCODE: $0000024D VOL: 0
;PCODE: $0000024E VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $0000024F VOL: 0
;PCODE: $00000250 VOL: 0
;PCODE: $00000251 VOL: 0
;PCODE: $00000252 VOL: 0
;PCODE: $00000253 VOL: 0
;PCODE: $00000254 VOL: 0
;SPDR = (i*3)>>8;
;PCODE: $00000255 VOL: 0
;PCODE: $00000256 VOL: 0
;PCODE: $00000257 VOL: 0
;PCODE: $00000258 VOL: 0
;PCODE: $00000259 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $0000025A VOL: 0
;PCODE: $0000025B VOL: 0
;PCODE: $0000025C VOL: 0
;PCODE: $0000025D VOL: 0
;PCODE: $0000025E VOL: 0
;PCODE: $0000025F VOL: 0
;SPDR = i*3;
;PCODE: $00000260 VOL: 0
;PCODE: $00000261 VOL: 0
;PCODE: $00000262 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000263 VOL: 0
;PCODE: $00000264 VOL: 0
;PCODE: $00000265 VOL: 0
;PCODE: $00000266 VOL: 0
;PCODE: $00000267 VOL: 0
;PCODE: $00000268 VOL: 0
;  for(k=0; k<3; k++)
;PCODE: $00000269 VOL: 0
;PCODE: $0000026A VOL: 0
;PCODE: $0000026B VOL: 0
;PCODE: $0000026C VOL: 0
;PCODE: $0000026D VOL: 0
;PCODE: $0000026E VOL: 0
;PCODE: $0000026F VOL: 0
;PCODE: $00000270 VOL: 0
;PCODE: $00000271 VOL: 0
;  {
;  SPDR = __NULL_INST;
;PCODE: $00000272 VOL: 0
;PCODE: $00000273 VOL: 0
;  while(!(SPSR & (1<<SPIF)));
;PCODE: $00000274 VOL: 0
;PCODE: $00000275 VOL: 0
;PCODE: $00000276 VOL: 0
;PCODE: $00000277 VOL: 0
;PCODE: $00000278 VOL: 0
;PCODE: $00000279 VOL: 0
;  ppBufferSlice[k] = SPDR;
;PCODE: $0000027A VOL: 0
;PCODE: $0000027B VOL: 0
;PCODE: $0000027C VOL: 0
;PCODE: $0000027D VOL: 0
;  }
;PCODE: $0000027E VOL: 0
;PCODE: $0000027F VOL: 0
;PCODE: $00000280 VOL: 0
;PCODE: $00000281 VOL: 0
;PCODE: $00000282 VOL: 0
;SPCR = 0;
;PCODE: $00000283 VOL: 0
;PCODE: $00000284 VOL: 0
;SPSR = 0;
;PCODE: $00000285 VOL: 0
;PCODE: $00000286 VOL: 0
;CS_SRAM_SET;
;PCODE: $00000287 VOL: 0
;PCODE: $00000288 VOL: 0
;CS_LCD_RESET;
;PCODE: $00000289 VOL: 0
;PCODE: $0000028A VOL: 0
;//First byte
;#asm
;PCODE: $0000028B VOL: 0
{
;PCODE: $0000028C VOL: 0
ldi r20,0b1001011
;PCODE: $0000028D VOL: 0
out 0x5,r20
;PCODE: $0000028E VOL: 0
SBI  0x5,5
;PCODE: $0000028F VOL: 0
CBI  0x5,5
;PCODE: $00000290 VOL: 0
}
;PCODE: $00000291 VOL: 0
;PCODE: $00000292 VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $00000293 VOL: 0
;PCODE: $00000294 VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $00000295 VOL: 0
;PCODE: $00000296 VOL: 0
;SPDR = ppBufferSlice[0];
;PCODE: $00000297 VOL: 0
;PCODE: $00000298 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000299 VOL: 0
;PCODE: $0000029A VOL: 0
;PCODE: $0000029B VOL: 0
;PCODE: $0000029C VOL: 0
;PCODE: $0000029D VOL: 0
;PCODE: $0000029E VOL: 0
;SPCR = 0;
;PCODE: $0000029F VOL: 0
;PCODE: $000002A0 VOL: 0
;SPSR = 0;
;PCODE: $000002A1 VOL: 0
;PCODE: $000002A2 VOL: 0
;//Second byte
;#asm
;PCODE: $000002A3 VOL: 0
{
;PCODE: $000002A4 VOL: 0
ldi r20,0b1001011
;PCODE: $000002A5 VOL: 0
out 0x5,r20
;PCODE: $000002A6 VOL: 0
SBI  0x5,5
;PCODE: $000002A7 VOL: 0
CBI  0x5,5
;PCODE: $000002A8 VOL: 0
}
;PCODE: $000002A9 VOL: 0
;PCODE: $000002AA VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $000002AB VOL: 0
;PCODE: $000002AC VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $000002AD VOL: 0
;PCODE: $000002AE VOL: 0
;SPDR = ppBufferSlice[1];
;PCODE: $000002AF VOL: 0
;PCODE: $000002B0 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000002B1 VOL: 0
;PCODE: $000002B2 VOL: 0
;PCODE: $000002B3 VOL: 0
;PCODE: $000002B4 VOL: 0
;PCODE: $000002B5 VOL: 0
;PCODE: $000002B6 VOL: 0
;SPCR = 0;
;PCODE: $000002B7 VOL: 0
;PCODE: $000002B8 VOL: 0
;SPSR = 0;
;PCODE: $000002B9 VOL: 0
;PCODE: $000002BA VOL: 0
;//Third byte
;#asm
;PCODE: $000002BB VOL: 0
{
;PCODE: $000002BC VOL: 0
ldi r20,0b1001011
;PCODE: $000002BD VOL: 0
out 0x5,r20
;PCODE: $000002BE VOL: 0
SBI  0x5,5
;PCODE: $000002BF VOL: 0
CBI  0x5,5
;PCODE: $000002C0 VOL: 0
}
;PCODE: $000002C1 VOL: 0
;PCODE: $000002C2 VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $000002C3 VOL: 0
;PCODE: $000002C4 VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $000002C5 VOL: 0
;PCODE: $000002C6 VOL: 0
;SPDR = ppBufferSlice[2];
;PCODE: $000002C7 VOL: 0
;PCODE: $000002C8 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $000002C9 VOL: 0
;PCODE: $000002CA VOL: 0
;PCODE: $000002CB VOL: 0
;PCODE: $000002CC VOL: 0
;PCODE: $000002CD VOL: 0
;PCODE: $000002CE VOL: 0
;SPCR = 0;
;PCODE: $000002CF VOL: 0
;PCODE: $000002D0 VOL: 0
;SPSR = 0;
;PCODE: $000002D1 VOL: 0
;PCODE: $000002D2 VOL: 0
;        }
;PCODE: $000002D3 VOL: 0
;PCODE: $000002D4 VOL: 0
;PCODE: $000002D5 VOL: 0
;PCODE: $000002D6 VOL: 0
;PCODE: $000002D7 VOL: 0
;CS_LCD_SET;
;PCODE: $000002D8 VOL: 0
;PCODE: $000002D9 VOL: 0
;}
;PCODE: $000002DA VOL: 0
;PCODE: $000002DB VOL: 0
;PCODE: $000002DC VOL: 0
;PCODE: $000002DD VOL: 0
;
;void nlcd_Clear(int color)
;{
;PCODE: $000002DE VOL: 0
;PCODE: $000002DF VOL: 0
;int i,j=0;
;unsigned char ppBufferSlice[3];
;ppBufferSlice[0] = color >> 4;
;PCODE: $000002E0 VOL: 0
;PCODE: $000002E1 VOL: 0
;PCODE: $000002E2 VOL: 0
;	color -> Y+7
;	i -> R16,R17
;	j -> R18,R19
;	ppBufferSlice -> Y+4
;PCODE: $000002E3 VOL: 0
;PCODE: $000002E4 VOL: 0
;PCODE: $000002E5 VOL: 0
;PCODE: $000002E6 VOL: 0
;PCODE: $000002E7 VOL: 0
;ppBufferSlice[1] = ((color ) << 4) | ((color >> 8));
;PCODE: $000002E8 VOL: 0
;PCODE: $000002E9 VOL: 0
;PCODE: $000002EA VOL: 0
;PCODE: $000002EB VOL: 0
;PCODE: $000002EC VOL: 0
;PCODE: $000002ED VOL: 0
;PCODE: $000002EE VOL: 0
;ppBufferSlice[2] = color;
;PCODE: $000002EF VOL: 0
;PCODE: $000002F0 VOL: 0
;        for(i=0;i < 8713;i++)
;PCODE: $000002F1 VOL: 0
;PCODE: $000002F2 VOL: 0
;PCODE: $000002F3 VOL: 0
;PCODE: $000002F4 VOL: 0
;PCODE: $000002F5 VOL: 0
;PCODE: $000002F6 VOL: 0
;PCODE: $000002F7 VOL: 0
;PCODE: $000002F8 VOL: 0
;PCODE: $000002F9 VOL: 0
;		{
;CS_SRAM_RESET;
;PCODE: $000002FA VOL: 0
;PCODE: $000002FB VOL: 0
;SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $000002FC VOL: 0
;PCODE: $000002FD VOL: 0
;SPSR = (1<<SPI2X);
;PCODE: $000002FE VOL: 0
;PCODE: $000002FF VOL: 0
;SPDR = __WRITE_INST;
;PCODE: $00000300 VOL: 0
;PCODE: $00000301 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000302 VOL: 0
;PCODE: $00000303 VOL: 0
;PCODE: $00000304 VOL: 0
;PCODE: $00000305 VOL: 0
;PCODE: $00000306 VOL: 0
;PCODE: $00000307 VOL: 0
;SPDR = (i*3)>>8;
;PCODE: $00000308 VOL: 0
;PCODE: $00000309 VOL: 0
;PCODE: $0000030A VOL: 0
;PCODE: $0000030B VOL: 0
;PCODE: $0000030C VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $0000030D VOL: 0
;PCODE: $0000030E VOL: 0
;PCODE: $0000030F VOL: 0
;PCODE: $00000310 VOL: 0
;PCODE: $00000311 VOL: 0
;PCODE: $00000312 VOL: 0
;SPDR = i*3;
;PCODE: $00000313 VOL: 0
;PCODE: $00000314 VOL: 0
;PCODE: $00000315 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000316 VOL: 0
;PCODE: $00000317 VOL: 0
;PCODE: $00000318 VOL: 0
;PCODE: $00000319 VOL: 0
;PCODE: $0000031A VOL: 0
;PCODE: $0000031B VOL: 0
;  for(j=0; j<3; j++)
;PCODE: $0000031C VOL: 0
;PCODE: $0000031D VOL: 0
;PCODE: $0000031E VOL: 0
;PCODE: $0000031F VOL: 0
;PCODE: $00000320 VOL: 0
;PCODE: $00000321 VOL: 0
;PCODE: $00000322 VOL: 0
;PCODE: $00000323 VOL: 0
;PCODE: $00000324 VOL: 0
;  {
;SPDR = ppBufferSlice[j];
;PCODE: $00000325 VOL: 0
;PCODE: $00000326 VOL: 0
;PCODE: $00000327 VOL: 0
;PCODE: $00000328 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000329 VOL: 0
;PCODE: $0000032A VOL: 0
;PCODE: $0000032B VOL: 0
;PCODE: $0000032C VOL: 0
;PCODE: $0000032D VOL: 0
;PCODE: $0000032E VOL: 0
;  }
;PCODE: $0000032F VOL: 0
;PCODE: $00000330 VOL: 0
;PCODE: $00000331 VOL: 0
;PCODE: $00000332 VOL: 0
;PCODE: $00000333 VOL: 0
;SPCR = 0;
;PCODE: $00000334 VOL: 0
;PCODE: $00000335 VOL: 0
;SPSR = 0;
;PCODE: $00000336 VOL: 0
;PCODE: $00000337 VOL: 0
;
;CS_SRAM_SET;
;PCODE: $00000338 VOL: 0
;PCODE: $00000339 VOL: 0
;        }
;PCODE: $0000033A VOL: 0
;PCODE: $0000033B VOL: 0
;PCODE: $0000033C VOL: 0
;PCODE: $0000033D VOL: 0
;PCODE: $0000033E VOL: 0
;}
;PCODE: $0000033F VOL: 0
;PCODE: $00000340 VOL: 0
;PCODE: $00000341 VOL: 0
;PCODE: $00000342 VOL: 0
;
;//*******************************************************************************************************
;//	Имя: 		 nlcd_Box(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char fill, int colo ...
;// 	Описание:    Рисует прямоугольник из координаты x0, y0 в координату x1, y1 с заливкой или нет, цветом color
;//           	 nlcd_Line(x0, y0, x1, y1, fill, color)
;//	Параметры:   x:     позиция 0-131
;//			     y:     позиция 0-131
;//               fill:  1-с заливкой, 0-без заливки
;//               color: цвет (12-bit см. #define)
;//  Пример:		 nlcd_Box(20,30,40,50,1,RED);  // С заливкой
;//*******************************************************************************************************
;
;void nlcd_Box(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char fill, int color,int  ...
;{
;PCODE: $00000343 VOL: 0
;PCODE: $00000344 VOL: 0
;    unsigned char   xmin, xmax, ymin, ymax;
;    int   i = 0,j = 0;
;    unsigned char a = (color >> 4);
;    unsigned char b = ((color ) << 4) | ((color >> 8) );
;    unsigned char c = color;
;    unsigned char ab = (colorborder >> 4);
;    unsigned char bb = ((colorborder ) << 4) | ((colorborder >> 8) );
;    unsigned char cb = colorborder;
;    unsigned char pBufferSlice[3];
;    unsigned char pBufferSliceBorder[3];
;    pBufferSlice[0] = a;
;PCODE: $00000345 VOL: 0
;PCODE: $00000346 VOL: 0
;PCODE: $00000347 VOL: 0
;PCODE: $00000348 VOL: 0
;PCODE: $00000349 VOL: 0
;PCODE: $0000034A VOL: 0
;PCODE: $0000034B VOL: 0
;	x0 -> Y+28
;	y0 -> Y+27
;	x1 -> Y+26
;	y1 -> Y+25
;	fill -> Y+24
;	color -> Y+22
;	colorborder -> Y+20
;	xmin -> R17
;	xmax -> R16
;	ymin -> R19
;	ymax -> R18
;	i -> R20,R21
;	j -> Y+18
;	a -> Y+17
;	b -> Y+16
;	c -> Y+15
;	ab -> Y+14
;	bb -> Y+13
;	cb -> Y+12
;	pBufferSlice -> Y+9
;	pBufferSliceBorder -> Y+6
;PCODE: $0000034C VOL: 0
;PCODE: $0000034D VOL: 0
;PCODE: $0000034E VOL: 0
;PCODE: $0000034F VOL: 0
;PCODE: $00000350 VOL: 0
;PCODE: $00000351 VOL: 0
;PCODE: $00000352 VOL: 0
;PCODE: $00000353 VOL: 0
;PCODE: $00000354 VOL: 0
;PCODE: $00000355 VOL: 0
;PCODE: $00000356 VOL: 0
;PCODE: $00000357 VOL: 0
;PCODE: $00000358 VOL: 0
;PCODE: $00000359 VOL: 0
;PCODE: $0000035A VOL: 0
;PCODE: $0000035B VOL: 0
;PCODE: $0000035C VOL: 0
;PCODE: $0000035D VOL: 0
;PCODE: $0000035E VOL: 0
;PCODE: $0000035F VOL: 0
;PCODE: $00000360 VOL: 0
;PCODE: $00000361 VOL: 0
;PCODE: $00000362 VOL: 0
;PCODE: $00000363 VOL: 0
;PCODE: $00000364 VOL: 0
;PCODE: $00000365 VOL: 0
;PCODE: $00000366 VOL: 0
;PCODE: $00000367 VOL: 0
;    pBufferSlice[1] = b;
;PCODE: $00000368 VOL: 0
;PCODE: $00000369 VOL: 0
;    pBufferSlice[2] = c;
;PCODE: $0000036A VOL: 0
;PCODE: $0000036B VOL: 0
;    pBufferSliceBorder[0] = ab;
;PCODE: $0000036C VOL: 0
;PCODE: $0000036D VOL: 0
;    pBufferSliceBorder[1] = bb;
;PCODE: $0000036E VOL: 0
;PCODE: $0000036F VOL: 0
;    pBufferSliceBorder[2] = cb;
;PCODE: $00000370 VOL: 0
;PCODE: $00000371 VOL: 0
;    if (fill == FILL)                          //  ******************************************************
;PCODE: $00000372 VOL: 0
;PCODE: $00000373 VOL: 0
;PCODE: $00000374 VOL: 0
;    {                                          //  * Проверяем - будет прямоугольник с заливкой или нет  *               ...
;        xmin = (x0 <= x1) ? x0 : x1;          //  *                                                     *
;PCODE: $00000375 VOL: 0
;PCODE: $00000376 VOL: 0
;PCODE: $00000377 VOL: 0
;PCODE: $00000378 VOL: 0
;PCODE: $00000379 VOL: 0
;PCODE: $0000037A VOL: 0
;PCODE: $0000037B VOL: 0
;PCODE: $0000037C VOL: 0
;PCODE: $0000037D VOL: 0
;PCODE: $0000037E VOL: 0
;PCODE: $0000037F VOL: 0
; 		xmax = (x0 > x1) ? x0 : x1;           //  *    Расчитываем максимум и минимум для X и Y         *
;PCODE: $00000380 VOL: 0
;PCODE: $00000381 VOL: 0
;PCODE: $00000382 VOL: 0
;PCODE: $00000383 VOL: 0
;PCODE: $00000384 VOL: 0
;PCODE: $00000385 VOL: 0
;PCODE: $00000386 VOL: 0
;PCODE: $00000387 VOL: 0
;PCODE: $00000388 VOL: 0
;PCODE: $00000389 VOL: 0
;PCODE: $0000038A VOL: 0
;		ymin = (y0 <= y1) ? y0 : y1;          //  *******************************************************
;PCODE: $0000038B VOL: 0
;PCODE: $0000038C VOL: 0
;PCODE: $0000038D VOL: 0
;PCODE: $0000038E VOL: 0
;PCODE: $0000038F VOL: 0
;PCODE: $00000390 VOL: 0
;PCODE: $00000391 VOL: 0
;PCODE: $00000392 VOL: 0
;PCODE: $00000393 VOL: 0
;PCODE: $00000394 VOL: 0
;PCODE: $00000395 VOL: 0
;		ymax = (y0 > y1) ? y0 : y1;
;PCODE: $00000396 VOL: 0
;PCODE: $00000397 VOL: 0
;PCODE: $00000398 VOL: 0
;PCODE: $00000399 VOL: 0
;PCODE: $0000039A VOL: 0
;PCODE: $0000039B VOL: 0
;PCODE: $0000039C VOL: 0
;PCODE: $0000039D VOL: 0
;PCODE: $0000039E VOL: 0
;PCODE: $0000039F VOL: 0
;PCODE: $000003A0 VOL: 0
;                                              //    *****************************************************
;  // Пишем в RAM
;  for( i = (((ymin)*RESRAM_X + xmin)*3);i < (((ymax)*RESRAM_X + xmax + 1)*3); i+=3*(RES_X)/2)
;PCODE: $000003A1 VOL: 0
;PCODE: $000003A2 VOL: 0
;PCODE: $000003A3 VOL: 0
;PCODE: $000003A4 VOL: 0
;PCODE: $000003A5 VOL: 0
;PCODE: $000003A6 VOL: 0
;PCODE: $000003A7 VOL: 0
;PCODE: $000003A8 VOL: 0
;PCODE: $000003A9 VOL: 0
;PCODE: $000003AA VOL: 0
;PCODE: $000003AB VOL: 0
;PCODE: $000003AC VOL: 0
;PCODE: $000003AD VOL: 0
;PCODE: $000003AE VOL: 0
;PCODE: $000003AF VOL: 0
;PCODE: $000003B0 VOL: 0
;PCODE: $000003B1 VOL: 0
;PCODE: $000003B2 VOL: 0
;PCODE: $000003B3 VOL: 0
;PCODE: $000003B4 VOL: 0
;PCODE: $000003B5 VOL: 0
;PCODE: $000003B6 VOL: 0
;  {
;     for(j = i; j < i + 3*(xmax-xmin+1);j+=3)
;PCODE: $000003B7 VOL: 0
;PCODE: $000003B8 VOL: 0
;PCODE: $000003B9 VOL: 0
;PCODE: $000003BA VOL: 0
;PCODE: $000003BB VOL: 0
;PCODE: $000003BC VOL: 0
;PCODE: $000003BD VOL: 0
;PCODE: $000003BE VOL: 0
;PCODE: $000003BF VOL: 0
;PCODE: $000003C0 VOL: 0
;PCODE: $000003C1 VOL: 0
;PCODE: $000003C2 VOL: 0
;PCODE: $000003C3 VOL: 0
;PCODE: $000003C4 VOL: 0
;PCODE: $000003C5 VOL: 0
;PCODE: $000003C6 VOL: 0
;PCODE: $000003C7 VOL: 0
;PCODE: $000003C8 VOL: 0
;PCODE: $000003C9 VOL: 0
;PCODE: $000003CA VOL: 0
;     {
;        nlcd_WritePixelBuffer(j,&pBufferSlice[0],3);
;PCODE: $000003CB VOL: 0
;PCODE: $000003CC VOL: 0
;PCODE: $000003CD VOL: 0
;PCODE: $000003CE VOL: 0
;PCODE: $000003CF VOL: 0
;PCODE: $000003D0 VOL: 0
;PCODE: $000003D1 VOL: 0
;     }
;PCODE: $000003D2 VOL: 0
;PCODE: $000003D3 VOL: 0
;PCODE: $000003D4 VOL: 0
;PCODE: $000003D5 VOL: 0
;PCODE: $000003D6 VOL: 0
;PCODE: $000003D7 VOL: 0
;  }
;PCODE: $000003D8 VOL: 0
;PCODE: $000003D9 VOL: 0
;PCODE: $000003DA VOL: 0
;PCODE: $000003DB VOL: 0
;PCODE: $000003DC VOL: 0
;
;    }
;    if(fill == BORDERFILL)
;PCODE: $000003DD VOL: 0
;PCODE: $000003DE VOL: 0
;PCODE: $000003DF VOL: 0
;PCODE: $000003E0 VOL: 0
;    {
;        xmin = (x0 <= x1) ? x0 : x1;
;PCODE: $000003E1 VOL: 0
;PCODE: $000003E2 VOL: 0
;PCODE: $000003E3 VOL: 0
;PCODE: $000003E4 VOL: 0
;PCODE: $000003E5 VOL: 0
;PCODE: $000003E6 VOL: 0
;PCODE: $000003E7 VOL: 0
;PCODE: $000003E8 VOL: 0
;PCODE: $000003E9 VOL: 0
;PCODE: $000003EA VOL: 0
;PCODE: $000003EB VOL: 0
; 		xmax = (x0 > x1) ? x0 : x1;
;PCODE: $000003EC VOL: 0
;PCODE: $000003ED VOL: 0
;PCODE: $000003EE VOL: 0
;PCODE: $000003EF VOL: 0
;PCODE: $000003F0 VOL: 0
;PCODE: $000003F1 VOL: 0
;PCODE: $000003F2 VOL: 0
;PCODE: $000003F3 VOL: 0
;PCODE: $000003F4 VOL: 0
;PCODE: $000003F5 VOL: 0
;PCODE: $000003F6 VOL: 0
;		ymin = (y0 <= y1) ? y0 : y1;
;PCODE: $000003F7 VOL: 0
;PCODE: $000003F8 VOL: 0
;PCODE: $000003F9 VOL: 0
;PCODE: $000003FA VOL: 0
;PCODE: $000003FB VOL: 0
;PCODE: $000003FC VOL: 0
;PCODE: $000003FD VOL: 0
;PCODE: $000003FE VOL: 0
;PCODE: $000003FF VOL: 0
;PCODE: $00000400 VOL: 0
;PCODE: $00000401 VOL: 0
;		ymax = (y0 > y1) ? y0 : y1;
;PCODE: $00000402 VOL: 0
;PCODE: $00000403 VOL: 0
;PCODE: $00000404 VOL: 0
;PCODE: $00000405 VOL: 0
;PCODE: $00000406 VOL: 0
;PCODE: $00000407 VOL: 0
;PCODE: $00000408 VOL: 0
;PCODE: $00000409 VOL: 0
;PCODE: $0000040A VOL: 0
;PCODE: $0000040B VOL: 0
;PCODE: $0000040C VOL: 0
;        // Пишем в RAM
;    for(i = (((ymin)*RESRAM_X + xmin)*3);i < (((ymin)*RESRAM_X + xmin)*3) + 3*(xmax-xmin+1);i+=3)
;PCODE: $0000040D VOL: 0
;PCODE: $0000040E VOL: 0
;PCODE: $0000040F VOL: 0
;PCODE: $00000410 VOL: 0
;PCODE: $00000411 VOL: 0
;PCODE: $00000412 VOL: 0
;PCODE: $00000413 VOL: 0
;PCODE: $00000414 VOL: 0
;PCODE: $00000415 VOL: 0
;PCODE: $00000416 VOL: 0
;PCODE: $00000417 VOL: 0
;PCODE: $00000418 VOL: 0
;PCODE: $00000419 VOL: 0
;PCODE: $0000041A VOL: 0
;PCODE: $0000041B VOL: 0
;PCODE: $0000041C VOL: 0
;PCODE: $0000041D VOL: 0
;PCODE: $0000041E VOL: 0
;PCODE: $0000041F VOL: 0
;PCODE: $00000420 VOL: 0
;PCODE: $00000421 VOL: 0
;PCODE: $00000422 VOL: 0
;PCODE: $00000423 VOL: 0
;PCODE: $00000424 VOL: 0
;PCODE: $00000425 VOL: 0
;PCODE: $00000426 VOL: 0
;PCODE: $00000427 VOL: 0
;PCODE: $00000428 VOL: 0
;PCODE: $00000429 VOL: 0
;PCODE: $0000042A VOL: 0
;     {
;        nlcd_WritePixelBuffer(i,&pBufferSliceBorder[0],3);
;PCODE: $0000042B VOL: 0
;PCODE: $0000042C VOL: 0
;PCODE: $0000042D VOL: 0
;PCODE: $0000042E VOL: 0
;PCODE: $0000042F VOL: 0
;PCODE: $00000430 VOL: 0
;     }
;PCODE: $00000431 VOL: 0
;PCODE: $00000432 VOL: 0
;PCODE: $00000433 VOL: 0
;PCODE: $00000434 VOL: 0
;PCODE: $00000435 VOL: 0
;  for( i = (((ymin)*RESRAM_X + xmin)*3) + 3*(RES_X)/2;i < (((ymax)*RESRAM_X + xmax + 1)*3)-3*(RES_X)/2; i+=3*(RES_X)/2)
;PCODE: $00000436 VOL: 0
;PCODE: $00000437 VOL: 0
;PCODE: $00000438 VOL: 0
;PCODE: $00000439 VOL: 0
;PCODE: $0000043A VOL: 0
;PCODE: $0000043B VOL: 0
;PCODE: $0000043C VOL: 0
;PCODE: $0000043D VOL: 0
;PCODE: $0000043E VOL: 0
;PCODE: $0000043F VOL: 0
;PCODE: $00000440 VOL: 0
;PCODE: $00000441 VOL: 0
;PCODE: $00000442 VOL: 0
;PCODE: $00000443 VOL: 0
;PCODE: $00000444 VOL: 0
;PCODE: $00000445 VOL: 0
;PCODE: $00000446 VOL: 0
;PCODE: $00000447 VOL: 0
;PCODE: $00000448 VOL: 0
;PCODE: $00000449 VOL: 0
;PCODE: $0000044A VOL: 0
;PCODE: $0000044B VOL: 0
;PCODE: $0000044C VOL: 0
;PCODE: $0000044D VOL: 0
;  {
;     for(j = i; j < i + 3*(xmax-xmin+1);j+=3)
;PCODE: $0000044E VOL: 0
;PCODE: $0000044F VOL: 0
;PCODE: $00000450 VOL: 0
;PCODE: $00000451 VOL: 0
;PCODE: $00000452 VOL: 0
;PCODE: $00000453 VOL: 0
;PCODE: $00000454 VOL: 0
;PCODE: $00000455 VOL: 0
;PCODE: $00000456 VOL: 0
;PCODE: $00000457 VOL: 0
;PCODE: $00000458 VOL: 0
;PCODE: $00000459 VOL: 0
;PCODE: $0000045A VOL: 0
;PCODE: $0000045B VOL: 0
;PCODE: $0000045C VOL: 0
;PCODE: $0000045D VOL: 0
;PCODE: $0000045E VOL: 0
;PCODE: $0000045F VOL: 0
;PCODE: $00000460 VOL: 0
;PCODE: $00000461 VOL: 0
;     {
;        if(j == i || j == i + 3*(xmax-xmin+1) - 3)
;PCODE: $00000462 VOL: 0
;PCODE: $00000463 VOL: 0
;PCODE: $00000464 VOL: 0
;PCODE: $00000465 VOL: 0
;PCODE: $00000466 VOL: 0
;PCODE: $00000467 VOL: 0
;PCODE: $00000468 VOL: 0
;PCODE: $00000469 VOL: 0
;PCODE: $0000046A VOL: 0
;PCODE: $0000046B VOL: 0
;PCODE: $0000046C VOL: 0
;PCODE: $0000046D VOL: 0
;PCODE: $0000046E VOL: 0
;PCODE: $0000046F VOL: 0
;PCODE: $00000470 VOL: 0
;PCODE: $00000471 VOL: 0
;PCODE: $00000472 VOL: 0
;PCODE: $00000473 VOL: 0
;PCODE: $00000474 VOL: 0
;        {
;        nlcd_WritePixelBuffer(j,&pBufferSliceBorder[0],3);
;PCODE: $00000475 VOL: 0
;PCODE: $00000476 VOL: 0
;PCODE: $00000477 VOL: 0
;PCODE: $00000478 VOL: 0
;PCODE: $00000479 VOL: 0
;PCODE: $0000047A VOL: 0
;PCODE: $0000047B VOL: 0
;        }
;        else
;PCODE: $0000047C VOL: 0
;PCODE: $0000047D VOL: 0
;        {
;        nlcd_WritePixelBuffer(j,&pBufferSlice[0],3);
;PCODE: $0000047E VOL: 0
;PCODE: $0000047F VOL: 0
;PCODE: $00000480 VOL: 0
;PCODE: $00000481 VOL: 0
;PCODE: $00000482 VOL: 0
;PCODE: $00000483 VOL: 0
;PCODE: $00000484 VOL: 0
;        }
;PCODE: $00000485 VOL: 0
;     }
;PCODE: $00000486 VOL: 0
;PCODE: $00000487 VOL: 0
;PCODE: $00000488 VOL: 0
;PCODE: $00000489 VOL: 0
;PCODE: $0000048A VOL: 0
;PCODE: $0000048B VOL: 0
;  }
;PCODE: $0000048C VOL: 0
;PCODE: $0000048D VOL: 0
;PCODE: $0000048E VOL: 0
;PCODE: $0000048F VOL: 0
;PCODE: $00000490 VOL: 0
;  for(i = (((ymin)*RESRAM_X + xmin)*3) + (ymax-ymin)*3*(RES_X)/2; i < (((ymin)*RESRAM_X + xmin)*3) + (ymax-ymin)*3*(RES_ ...
;PCODE: $00000491 VOL: 0
;PCODE: $00000492 VOL: 0
;PCODE: $00000493 VOL: 0
;PCODE: $00000494 VOL: 0
;PCODE: $00000495 VOL: 0
;PCODE: $00000496 VOL: 0
;PCODE: $00000497 VOL: 0
;PCODE: $00000498 VOL: 0
;PCODE: $00000499 VOL: 0
;PCODE: $0000049A VOL: 0
;PCODE: $0000049B VOL: 0
;PCODE: $0000049C VOL: 0
;PCODE: $0000049D VOL: 0
;PCODE: $0000049E VOL: 0
;PCODE: $0000049F VOL: 0
;PCODE: $000004A0 VOL: 0
;PCODE: $000004A1 VOL: 0
;PCODE: $000004A2 VOL: 0
;PCODE: $000004A3 VOL: 0
;PCODE: $000004A4 VOL: 0
;PCODE: $000004A5 VOL: 0
;PCODE: $000004A6 VOL: 0
;PCODE: $000004A7 VOL: 0
;PCODE: $000004A8 VOL: 0
;PCODE: $000004A9 VOL: 0
;PCODE: $000004AA VOL: 0
;PCODE: $000004AB VOL: 0
;PCODE: $000004AC VOL: 0
;PCODE: $000004AD VOL: 0
;PCODE: $000004AE VOL: 0
;PCODE: $000004AF VOL: 0
;PCODE: $000004B0 VOL: 0
;PCODE: $000004B1 VOL: 0
;PCODE: $000004B2 VOL: 0
;PCODE: $000004B3 VOL: 0
;PCODE: $000004B4 VOL: 0
;PCODE: $000004B5 VOL: 0
;PCODE: $000004B6 VOL: 0
;PCODE: $000004B7 VOL: 0
;PCODE: $000004B8 VOL: 0
;PCODE: $000004B9 VOL: 0
;PCODE: $000004BA VOL: 0
;PCODE: $000004BB VOL: 0
;PCODE: $000004BC VOL: 0
;PCODE: $000004BD VOL: 0
;PCODE: $000004BE VOL: 0
;PCODE: $000004BF VOL: 0
;PCODE: $000004C0 VOL: 0
;PCODE: $000004C1 VOL: 0
;PCODE: $000004C2 VOL: 0
;PCODE: $000004C3 VOL: 0
;PCODE: $000004C4 VOL: 0
;PCODE: $000004C5 VOL: 0
;PCODE: $000004C6 VOL: 0
;PCODE: $000004C7 VOL: 0
;PCODE: $000004C8 VOL: 0
;PCODE: $000004C9 VOL: 0
;PCODE: $000004CA VOL: 0
;     {
;        nlcd_WritePixelBuffer(i,&pBufferSliceBorder[0],3);
;PCODE: $000004CB VOL: 0
;PCODE: $000004CC VOL: 0
;PCODE: $000004CD VOL: 0
;PCODE: $000004CE VOL: 0
;PCODE: $000004CF VOL: 0
;PCODE: $000004D0 VOL: 0
;     }
;PCODE: $000004D1 VOL: 0
;PCODE: $000004D2 VOL: 0
;PCODE: $000004D3 VOL: 0
;PCODE: $000004D4 VOL: 0
;PCODE: $000004D5 VOL: 0
;
;    }
;}
;PCODE: $000004D6 VOL: 0
;PCODE: $000004D7 VOL: 0
;PCODE: $000004D8 VOL: 0
;PCODE: $000004D9 VOL: 0
;PCODE: $000004DA VOL: 0
;
;//******************************************************************************
;//	Имя: 		 nlcd_Circle(unsigned char x0, unsigned char y0, unsigned char radius, int color)
;// 	Описание:    Рисует круг из координаты x0, y0, с радиусом и цветом color
;//           	 nlcd_Circle(x0, y0, radius, color)
;//	Параметры:   x:       позиция 0-131
;//			     y:       позиция 0-131
;//               radius:  в пикселях
;//               color: цвет (12-bit см. #define)
;//  Пример:		 nlcd_Circle(10,55,2,BLUE);
;//******************************************************************************
;/*void nlcd_Circle(unsigned char x0, unsigned char y0, unsigned char radius, int color)
;{
;    int f = 1 - radius;
;	int ddF_x = 0;
;    int ddF_y = -2 * radius;
;    unsigned char x = 0;
;    unsigned char y = radius;
;
;    nlcd_Pixel(x0, y0 + radius, color);
;    nlcd_Pixel(x0, y0 - radius, color);
;    nlcd_Pixel(x0 + radius, y0, color);
;    nlcd_Pixel(x0 - radius, y0, color);
;
;    while (x < y)
;	{
;        if (f >= 0)
;		{
;
;            y--;
;            ddF_y += 2;
;            f += ddF_y;
;        }
;
;    x++;
;    ddF_x += 2;
;    f += ddF_x + 1;
;
;    nlcd_Pixel(x0 + x, y0 + y, color);
;    nlcd_Pixel(x0 - x, y0 + y, color);
;    nlcd_Pixel(x0 + x, y0 - y, color);
;    nlcd_Pixel(x0 - x, y0 - y, color);
;    nlcd_Pixel(x0 + y, y0 + x, color);
;    nlcd_Pixel(x0 - y, y0 + x, color);
;    nlcd_Pixel(x0 + y, y0 - x, color);
;    nlcd_Pixel(x0 - y, y0 - x, color);
;
;    }
;}      */
;
;//******************************************************************************
;//	Имя: 		nlcd_Char(char c, unsigned char x, unsigned char y, int fColor, int bColor)
;// 	Описание:
;//	Параметры:
;//  Пример:
;//******************************************************************************
;void nlcd_Char(char c, unsigned char y, unsigned char x, int fColor, int bColor)
;{
;PCODE: $000004DB VOL: 0
;PCODE: $000004DC VOL: 0
;   int    i;
;   int    j;
;   unsigned char   nCols;
;   unsigned char  nRows;
;   unsigned char  nBytes;
;   unsigned char   PixelRow;
;   unsigned char   Mask;
;   unsigned int   Word0, Word1;
;   unsigned char *pFont,   *pChar;
;   unsigned char a;
;    unsigned char b;
;    unsigned char d;
;    unsigned char pBufferSlice[3];
;
;   pFont = (unsigned char *)Nokia6610_fnt8x8;
;PCODE: $000004DD VOL: 0
;PCODE: $000004DE VOL: 0
;PCODE: $000004DF VOL: 0
;	c -> Y+29
;	y -> Y+28
;	x -> Y+27
;	fColor -> Y+25
;	bColor -> Y+23
;	i -> R16,R17
;	j -> R18,R19
;	nCols -> R21
;	nRows -> R20
;	nBytes -> Y+22
;	PixelRow -> Y+21
;	Mask -> Y+20
;	Word0 -> Y+18
;	Word1 -> Y+16
;	*pFont -> Y+14
;	*pChar -> Y+12
;	a -> Y+11
;	b -> Y+10
;	d -> Y+9
;	pBufferSlice -> Y+6
;PCODE: $000004E0 VOL: 0
;PCODE: $000004E1 VOL: 0
;
;   nCols = pgm_read_byte(pFont);
;PCODE: $000004E2 VOL: 0
;PCODE: $000004E3 VOL: 0
;
;   nRows = pgm_read_byte(pFont + 1);
;PCODE: $000004E4 VOL: 0
;PCODE: $000004E5 VOL: 0
;PCODE: $000004E6 VOL: 0
;
;   nBytes = pgm_read_byte(pFont + 2);
;PCODE: $000004E7 VOL: 0
;PCODE: $000004E8 VOL: 0
;PCODE: $000004E9 VOL: 0
;PCODE: $000004EA VOL: 0
;
;   pChar = pFont + (nBytes * (c - 0x1F));
;PCODE: $000004EB VOL: 0
;PCODE: $000004EC VOL: 0
;PCODE: $000004ED VOL: 0
;PCODE: $000004EE VOL: 0
;PCODE: $000004EF VOL: 0
;PCODE: $000004F0 VOL: 0
;PCODE: $000004F1 VOL: 0
;PCODE: $000004F2 VOL: 0
;PCODE: $000004F3 VOL: 0
;
;   for (i = 0; i<nRows; i++) // for 2x2 Box-Pixels !!!
;PCODE: $000004F4 VOL: 0
;PCODE: $000004F5 VOL: 0
;PCODE: $000004F6 VOL: 0
;PCODE: $000004F7 VOL: 0
;PCODE: $000004F8 VOL: 0
;PCODE: $000004F9 VOL: 0
;PCODE: $000004FA VOL: 0
;PCODE: $000004FB VOL: 0
;PCODE: $000004FC VOL: 0
;PCODE: $000004FD VOL: 0
;PCODE: $000004FE VOL: 0
;   {
;      PixelRow = pgm_read_byte(pChar++);
;PCODE: $000004FF VOL: 0
;PCODE: $00000500 VOL: 0
;PCODE: $00000501 VOL: 0
;PCODE: $00000502 VOL: 0
;      Mask = 0x80;
;PCODE: $00000503 VOL: 0
;PCODE: $00000504 VOL: 0
;      for (j = 0; j < nCols/2; j++)
;PCODE: $00000505 VOL: 0
;PCODE: $00000506 VOL: 0
;PCODE: $00000507 VOL: 0
;PCODE: $00000508 VOL: 0
;PCODE: $00000509 VOL: 0
;PCODE: $0000050A VOL: 0
;PCODE: $0000050B VOL: 0
;PCODE: $0000050C VOL: 0
;PCODE: $0000050D VOL: 0
;PCODE: $0000050E VOL: 0
;PCODE: $0000050F VOL: 0
;PCODE: $00000510 VOL: 0
;	  {
;         if ((PixelRow & Mask) == 0)
;PCODE: $00000511 VOL: 0
;PCODE: $00000512 VOL: 0
;PCODE: $00000513 VOL: 0
;PCODE: $00000514 VOL: 0
;         Word0 = bColor;
;PCODE: $00000515 VOL: 0
;PCODE: $00000516 VOL: 0
;         else
;PCODE: $00000517 VOL: 0
;PCODE: $00000518 VOL: 0
;         Word0 = fColor;
;PCODE: $00000519 VOL: 0
;PCODE: $0000051A VOL: 0
;         Mask = Mask >> 1;
;PCODE: $0000051B VOL: 0
;PCODE: $0000051C VOL: 0
;PCODE: $0000051D VOL: 0
;PCODE: $0000051E VOL: 0
;         if ((PixelRow & Mask) == 0)
;PCODE: $0000051F VOL: 0
;PCODE: $00000520 VOL: 0
;PCODE: $00000521 VOL: 0
;PCODE: $00000522 VOL: 0
;         Word1 = bColor;
;PCODE: $00000523 VOL: 0
;PCODE: $00000524 VOL: 0
;         else
;PCODE: $00000525 VOL: 0
;PCODE: $00000526 VOL: 0
;         Word1 = fColor;
;PCODE: $00000527 VOL: 0
;PCODE: $00000528 VOL: 0
;    a = (Word0 >> 4);
;PCODE: $00000529 VOL: 0
;PCODE: $0000052A VOL: 0
;PCODE: $0000052B VOL: 0
;PCODE: $0000052C VOL: 0
;    b = ((Word0 ) << 4) | ((Word1 >> 8) );
;PCODE: $0000052D VOL: 0
;PCODE: $0000052E VOL: 0
;PCODE: $0000052F VOL: 0
;PCODE: $00000530 VOL: 0
;PCODE: $00000531 VOL: 0
;PCODE: $00000532 VOL: 0
;PCODE: $00000533 VOL: 0
;    d = Word1;
;PCODE: $00000534 VOL: 0
;PCODE: $00000535 VOL: 0
;    pBufferSlice[0] = a;
;PCODE: $00000536 VOL: 0
;PCODE: $00000537 VOL: 0
;    pBufferSlice[1] = b;
;PCODE: $00000538 VOL: 0
;PCODE: $00000539 VOL: 0
;    pBufferSlice[2] = d;
;PCODE: $0000053A VOL: 0
;PCODE: $0000053B VOL: 0
;  // Пишем в RAM
;   nlcd_WritePixelBuffer(((y+i)*3*(RESRAM_X) + 3*(j + x/2)),&pBufferSlice[0],3);
;PCODE: $0000053C VOL: 0
;PCODE: $0000053D VOL: 0
;PCODE: $0000053E VOL: 0
;PCODE: $0000053F VOL: 0
;PCODE: $00000540 VOL: 0
;PCODE: $00000541 VOL: 0
;PCODE: $00000542 VOL: 0
;PCODE: $00000543 VOL: 0
;PCODE: $00000544 VOL: 0
;PCODE: $00000545 VOL: 0
;PCODE: $00000546 VOL: 0
;PCODE: $00000547 VOL: 0
;PCODE: $00000548 VOL: 0
;PCODE: $00000549 VOL: 0
;PCODE: $0000054A VOL: 0
;PCODE: $0000054B VOL: 0
;PCODE: $0000054C VOL: 0
;PCODE: $0000054D VOL: 0
;PCODE: $0000054E VOL: 0
;PCODE: $0000054F VOL: 0
;PCODE: $00000550 VOL: 0
;PCODE: $00000551 VOL: 0
;         Mask = Mask >> 1;
;PCODE: $00000552 VOL: 0
;PCODE: $00000553 VOL: 0
;PCODE: $00000554 VOL: 0
;      }
;PCODE: $00000555 VOL: 0
;PCODE: $00000556 VOL: 0
;PCODE: $00000557 VOL: 0
;PCODE: $00000558 VOL: 0
;PCODE: $00000559 VOL: 0
;   }
;PCODE: $0000055A VOL: 0
;PCODE: $0000055B VOL: 0
;PCODE: $0000055C VOL: 0
;PCODE: $0000055D VOL: 0
;PCODE: $0000055E VOL: 0
;}
;PCODE: $0000055F VOL: 0
;PCODE: $00000560 VOL: 0
;PCODE: $00000561 VOL: 0
;PCODE: $00000562 VOL: 0
;
;//******************************************************************************
;//	Имя: 		nlcd_String(char *pString, unsigned char x, unsigned char  y,  int fColor, int bColor)
;// 	Описание:
;//	Параметры:  x:       позиция 0-131
;//			    y:       позиция 0-131
;//              fColor:  цвет (12-bit см. #define)
;//              bColor:  цвет (12-bit см. #define)
;//  Пример:		nlcd_String("Hello",40,12,WHITE,BLACK);
;//******************************************************************************
;void nlcd_String(char *pString, unsigned char x, unsigned char  y,  int fColor, int bColor)
;{
;PCODE: $00000563 VOL: 0
;PCODE: $00000564 VOL: 0
;   while (*pString != 0x00)
;PCODE: $00000565 VOL: 0
;	*pString -> Y+6
;	x -> Y+5
;	y -> Y+4
;	fColor -> Y+2
;	bColor -> Y+0
;PCODE: $00000566 VOL: 0
;PCODE: $00000567 VOL: 0
;PCODE: $00000568 VOL: 0
;PCODE: $00000569 VOL: 0
;PCODE: $0000056A VOL: 0
;   {
;      nlcd_Char(*pString++, x, y, fColor, bColor);
;PCODE: $0000056B VOL: 0
;PCODE: $0000056C VOL: 0
;PCODE: $0000056D VOL: 0
;PCODE: $0000056E VOL: 0
;PCODE: $0000056F VOL: 0
;PCODE: $00000570 VOL: 0
;PCODE: $00000571 VOL: 0
;PCODE: $00000572 VOL: 0
;PCODE: $00000573 VOL: 0
;PCODE: $00000574 VOL: 0
;PCODE: $00000575 VOL: 0
;PCODE: $00000576 VOL: 0
;      y=y+8;
;PCODE: $00000577 VOL: 0
;PCODE: $00000578 VOL: 0
;PCODE: $00000579 VOL: 0
;      if (x > 131) break;
;PCODE: $0000057A VOL: 0
;PCODE: $0000057B VOL: 0
;PCODE: $0000057C VOL: 0
;PCODE: $0000057D VOL: 0
;   }
;PCODE: $0000057E VOL: 0
;PCODE: $0000057F VOL: 0
;PCODE: $00000580 VOL: 0
;}
;PCODE: $00000581 VOL: 0
;PCODE: $00000582 VOL: 0
;PCODE: $00000583 VOL: 0
;
;#include "FatFS/mmc.c"
;/*-----------------------------------------------------------------------*/
;/* MMCv3/SDv1/SDv2 (in SPI mode) control module                          */
;/*-----------------------------------------------------------------------*/
;/*
;/  Copyright (C) 2014, ChaN, all right reserved.
;/
;/ * This software is a free software and there is NO WARRANTY.
;/ * No restriction on use. You can use, modify and redistribute it for
;/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
;/ * Redistributions of source code must retain the above copyright notice.
;/
;/-------------------------------------------------------------------------*/
;
;#include <io.h>
;#include "diskio.h"
;#include "spi_2.c"
;//***************************************************************************
;//
;//  Author(s)...: Pashgan    http://ChipEnable.Ru
;//
;//  Target(s)...: Mega
;//
;//  Compiler....:
;//
;//  Description.: Драйвер SPI
;//
;//  Data........: 26.07.13
;//
;//***************************************************************************
;#include "spi_2.h"
;PCODE: $00000584 VOL: 0
;PCODE: $00000585 VOL: 0
;PCODE: $00000586 VOL: 0
;	data -> Y+0
;PCODE: $00000587 VOL: 0
;PCODE: $00000588 VOL: 0
;PCODE: $00000589 VOL: 0
;PCODE: $0000058A VOL: 0
;PCODE: $0000058B VOL: 0
;PCODE: $0000058C VOL: 0
;PCODE: $0000058D VOL: 0
;PCODE: $0000058E VOL: 0
;PCODE: $0000058F VOL: 0
;PCODE: $00000590 VOL: 0
;PCODE: $00000591 VOL: 0
;
;
;/*инициализация SPI*/
;void SPI_Init(BYTE hs)
;{
;PCODE: $00000592 VOL: 0
;PCODE: $00000593 VOL: 0
;  /*настройка портов ввода-вывода
;  все выводы, кроме MISO выходы*/
;// SPI_DDRXX |= (1<<SPI_MOSI)|(1<<SPI_SCK);
; // SPI_DDRXX &= ~(1<<SPI_MISO);
; SPI_DDRX |= (1<<SPI_SS);
;PCODE: $00000594 VOL: 0
;	hs -> Y+0
;PCODE: $00000595 VOL: 0
;PCODE: $00000596 VOL: 0
;
; // SPI_PORTXX |= (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_MISO);
;  SPI_PORTX |= (1<<SPI_SS);
;PCODE: $00000597 VOL: 0
;PCODE: $00000598 VOL: 0
;
;  /*разрешение spi,старший бит вперед,мастер, режим 0*/
; if(!hs)
;PCODE: $00000599 VOL: 0
;PCODE: $0000059A VOL: 0
;PCODE: $0000059B VOL: 0
; {
; SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(1<<SPR0);
;PCODE: $0000059C VOL: 0
;PCODE: $0000059D VOL: 0
; SPSR = (0<<SPI2X);
;PCODE: $0000059E VOL: 0
;PCODE: $0000059F VOL: 0
; }
; else
;PCODE: $000005A0 VOL: 0
;PCODE: $000005A1 VOL: 0
; {
; SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(0<<SPR1)|(0<<SPR0);
;PCODE: $000005A2 VOL: 0
;PCODE: $000005A3 VOL: 0
; SPSR = (1<<SPI2X);
;PCODE: $000005A4 VOL: 0
;PCODE: $000005A5 VOL: 0
; }
;PCODE: $000005A6 VOL: 0
;}
;PCODE: $000005A7 VOL: 0
;PCODE: $000005A8 VOL: 0
;PCODE: $000005A9 VOL: 0
;
;void SPI_Release(void)
;{
;PCODE: $000005AA VOL: 0
;PCODE: $000005AB VOL: 0
;  SPCR = 0;
;PCODE: $000005AC VOL: 0
;PCODE: $000005AD VOL: 0
;  SPSR = 0;
;PCODE: $000005AE VOL: 0
;PCODE: $000005AF VOL: 0
;}
;PCODE: $000005B0 VOL: 0
;PCODE: $000005B1 VOL: 0
;
;/*отослать байт данных по SPI*/
;void SPI_WriteByte(uint8_t data)
;{
;PCODE: $000005B2 VOL: 0
;PCODE: $000005B3 VOL: 0
;   SPDR = data;
;PCODE: $000005B4 VOL: 0
;	data -> Y+0
;PCODE: $000005B5 VOL: 0
;PCODE: $000005B6 VOL: 0
;   while(!(SPSR & (1<<SPIF)));
;PCODE: $000005B7 VOL: 0
;PCODE: $000005B8 VOL: 0
;PCODE: $000005B9 VOL: 0
;PCODE: $000005BA VOL: 0
;PCODE: $000005BB VOL: 0
;PCODE: $000005BC VOL: 0
;}
;PCODE: $000005BD VOL: 0
;PCODE: $000005BE VOL: 0
;PCODE: $000005BF VOL: 0
;
;/*получить байт данных по SPI*/
;uint8_t SPI_ReadByte(void)
;{
;PCODE: $000005C0 VOL: 0
;PCODE: $000005C1 VOL: 0
;   SPDR = 0xff;
;PCODE: $000005C2 VOL: 0
;PCODE: $000005C3 VOL: 0
;   while(!(SPSR & (1<<SPIF)));
;PCODE: $000005C4 VOL: 0
;PCODE: $000005C5 VOL: 0
;PCODE: $000005C6 VOL: 0
;PCODE: $000005C7 VOL: 0
;PCODE: $000005C8 VOL: 0
;PCODE: $000005C9 VOL: 0
;   return SPDR;
;PCODE: $000005CA VOL: 0
;PCODE: $000005CB VOL: 0
;}
;PCODE: $000005CC VOL: 0
;
;/*отослать и получить байт данных по SPI*/
;uint8_t SPI_WriteReadByte(uint8_t data)
;{
;PCODE: $000005CD VOL: 0
;PCODE: $000005CE VOL: 0
;   SPDR = data;
;PCODE: $000005CF VOL: 0
;	data -> Y+0
;PCODE: $000005D0 VOL: 0
;PCODE: $000005D1 VOL: 0
;   while(!(SPSR & (1<<SPIF)));
;PCODE: $000005D2 VOL: 0
;PCODE: $000005D3 VOL: 0
;PCODE: $000005D4 VOL: 0
;PCODE: $000005D5 VOL: 0
;PCODE: $000005D6 VOL: 0
;PCODE: $000005D7 VOL: 0
;   return SPDR;
;PCODE: $000005D8 VOL: 0
;PCODE: $000005D9 VOL: 0
;PCODE: $000005DA VOL: 0
;}
;PCODE: $000005DB VOL: 0
;
;/*отправить несколько байт данных по SPI*/
;void SPI_WriteArray(uint8_t num, uint8_t *data)
;{
;PCODE: $000005DC VOL: 0
;PCODE: $000005DD VOL: 0
;   while(num--){
;PCODE: $000005DE VOL: 0
;	num -> Y+2
;	*data -> Y+0
;PCODE: $000005DF VOL: 0
;PCODE: $000005E0 VOL: 0
;PCODE: $000005E1 VOL: 0
;PCODE: $000005E2 VOL: 0
;PCODE: $000005E3 VOL: 0
;PCODE: $000005E4 VOL: 0
;      SPDR = *data++;
;PCODE: $000005E5 VOL: 0
;PCODE: $000005E6 VOL: 0
;PCODE: $000005E7 VOL: 0
;PCODE: $000005E8 VOL: 0
;      while(!(SPSR & (1<<SPIF)));
;PCODE: $000005E9 VOL: 0
;PCODE: $000005EA VOL: 0
;PCODE: $000005EB VOL: 0
;PCODE: $000005EC VOL: 0
;PCODE: $000005ED VOL: 0
;PCODE: $000005EE VOL: 0
;   }
;PCODE: $000005EF VOL: 0
;PCODE: $000005F0 VOL: 0
;}
;PCODE: $000005F1 VOL: 0
;PCODE: $000005F2 VOL: 0
;PCODE: $000005F3 VOL: 0
;
;/*отправить и получить несколько байт данных по SPI*/
;void SPI_WriteReadArray(uint8_t num, uint8_t *data)
;{
;PCODE: $000005F4 VOL: 0
;PCODE: $000005F5 VOL: 0
;   while(num--){
;PCODE: $000005F6 VOL: 0
;	num -> Y+2
;	*data -> Y+0
;PCODE: $000005F7 VOL: 0
;PCODE: $000005F8 VOL: 0
;PCODE: $000005F9 VOL: 0
;PCODE: $000005FA VOL: 0
;PCODE: $000005FB VOL: 0
;PCODE: $000005FC VOL: 0
;      SPDR = *data;
;PCODE: $000005FD VOL: 0
;PCODE: $000005FE VOL: 0
;PCODE: $000005FF VOL: 0
;      while(!(SPSR & (1<<SPIF)));
;PCODE: $00000600 VOL: 0
;PCODE: $00000601 VOL: 0
;PCODE: $00000602 VOL: 0
;PCODE: $00000603 VOL: 0
;PCODE: $00000604 VOL: 0
;PCODE: $00000605 VOL: 0
;      *data++ = SPDR;
;PCODE: $00000606 VOL: 0
;PCODE: $00000607 VOL: 0
;PCODE: $00000608 VOL: 0
;PCODE: $00000609 VOL: 0
;PCODE: $0000060A VOL: 0
;PCODE: $0000060B VOL: 0
;   }
;PCODE: $0000060C VOL: 0
;PCODE: $0000060D VOL: 0
;}
;PCODE: $0000060E VOL: 0
;PCODE: $0000060F VOL: 0
;PCODE: $00000610 VOL: 0
;
;#define CT_MMC				0x01	/* MMC ver 3 */
;#define CT_SD1				0x02	/* SD ver 1 */
;#define CT_SD2				0x04	/* SD ver 2 */
;#define CT_SDC				(CT_SD1|CT_SD2)	/* SD */
;#define CT_BLOCK			0x08	/* Block addressing */
;
;
;/* Port controls  (Platform dependent) */
;#define CS_LOW()	SPI_EnableSS_m(SPI_SS)		/* CS=low */
;#define	CS_HIGH()	SPI_DisableSS_m(SPI_SS)			/* CS=high */
;//#define MMC_CD		(!(PINB & 0x10))	/* Card detected.   yes:true, no:false, default:true */
;//#define MMC_WP		(PINB & 0x20)		/* Write protected. yes:true, no:false, default:false */
;#define	FCLK_SLOW()	SPCR = 0x52		/* Set slow clock (F_CPU / 64) */
;#define	FCLK_FAST()	SPCR = 0x50		/* Set fast clock (F_CPU / 2) */
;#define	FCLK_STOP()	SPCR = 0		/* Set fast clock (F_CPU / 2) */
;
;#define SELECT()	SPI_EnableSS_m(SPI_SS)	/* CS = L */
;#define DESELECT()	SPI_DisableSS_m(SPI_SS)	/* CS = H */
;#define MMC_SEL	    SPI_StatSS_m(SPI_SS)   	/* CS status (true:CS == L) */
;#define FORWARD(d)	         		/* Data forwarding function (Console out in this example) */
;
;#define init_spi(hs)  SPI_Init(hs)    	/* Initialize SPI port (usi.S) */
;#define release_spi() SPI_Release()
;#define dly_100us() delay_us(100)	/* Delay 100 microseconds (usi.S) */
;#define xmit_spi(d) SPI_WriteByte_m(d) /* Send a byte to the MMC (usi.S) */
;#define rcv_spi()	SPI_ReadByte_i()   /* Send a 0xFF to the MMC and get the received byte (usi.S) */
;
;
;/*--------------------------------------------------------------------------
;
;   Module Private Functions
;
;---------------------------------------------------------------------------*/
;
;/* Definitions for MMC/SDC command */
;#define CMD0	(0x40+0)			/* GO_IDLE_STATE */
;#define CMD1	(0x40+1)			/* SEND_OP_COND (MMC) */
;#define	ACMD41	(0x40+0x80+41)	/* SEND_OP_COND (SDC) */
;#define CMD8	(0x40+8)			/* SEND_IF_COND */
;#define CMD9	(0x40+9)			/* SEND_CSD */
;#define CMD10	(0x40+10)		/* SEND_CID */
;#define CMD12	(0x40+12)		/* STOP_TRANSMISSION */
;#define ACMD13	(0x40+0x80+13)	/* SD_STATUS (SDC) */
;#define CMD16	(0x40+16)		/* SET_BLOCKLEN */
;#define CMD17	(0x40+17)		/* READ_SINGLE_BLOCK */
;#define CMD18	(0x40+18)		/* READ_MULTIPLE_BLOCK */
;#define CMD23	(0x40+23)		/* SET_BLOCK_COUNT (MMC) */
;#define	ACMD23	(0x40+0x80+23)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
;#define CMD24	(0x40+24)		/* WRITE_BLOCK */
;#define CMD25	(0x40+25)		/* WRITE_MULTIPLE_BLOCK */
;#define CMD32	(0x40+32)		/* ERASE_ER_BLK_START */
;#define CMD33	(0x40+33)		/* ERASE_ER_BLK_END */
;#define CMD38	(0x40+38)		/* ERASE */
;#define CMD55	(0x40+55)		/* APP_CMD */
;#define CMD58	(0x40+58)		/* READ_OCR */
;
;
;static volatile
;DSTATUS Stat = STA_NOINIT;	/* Disk status */

	.DSEG
;
;static volatile
;BYTE Timer1, Timer2;	/* 100Hz decrement timer */
;
;static
;BYTE CardType;			/* Card type flags */
;
;
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Transmit/Receive data from/to MMC via SPI  (Platform dependent)       */
;/*-----------------------------------------------------------------------*/
;
;/* Exchange a byte */
;static
;BYTE xchg_spi (		/* Returns received data */
;	BYTE dat		/* Data to be sent */
;)
;{

	.CSEG
;PCODE: $00000611 VOL: 0
;PCODE: $00000612 VOL: 0
;	SPDR = dat;
;PCODE: $00000613 VOL: 0
;	dat -> Y+0
;PCODE: $00000614 VOL: 0
;PCODE: $00000615 VOL: 0
;while(!(SPSR & (1<<SPIF)));
;PCODE: $00000616 VOL: 0
;PCODE: $00000617 VOL: 0
;PCODE: $00000618 VOL: 0
;PCODE: $00000619 VOL: 0
;PCODE: $0000061A VOL: 0
;PCODE: $0000061B VOL: 0
;	return SPDR;
;PCODE: $0000061C VOL: 0
;PCODE: $0000061D VOL: 0
;PCODE: $0000061E VOL: 0
;}
;PCODE: $0000061F VOL: 0
;
;/* Send a data block fast */
;static
;void xmit_spi_multi (
;	const BYTE *p,	/* Data block to be sent */
;	UINT cnt		/* Size of data block (must be multiple of 2) */
;)
;{
;PCODE: $00000620 VOL: 0
;PCODE: $00000621 VOL: 0
;	do {
;PCODE: $00000622 VOL: 0
;	*p -> Y+2
;	cnt -> Y+0
;PCODE: $00000623 VOL: 0
;		SPDR = *p++; while(!(SPSR & (1<<SPIF)));
;PCODE: $00000624 VOL: 0
;PCODE: $00000625 VOL: 0
;PCODE: $00000626 VOL: 0
;PCODE: $00000627 VOL: 0
;PCODE: $00000628 VOL: 0
;PCODE: $00000629 VOL: 0
;PCODE: $0000062A VOL: 0
;PCODE: $0000062B VOL: 0
;PCODE: $0000062C VOL: 0
;PCODE: $0000062D VOL: 0
;		SPDR = *p++; while(!(SPSR & (1<<SPIF)));
;PCODE: $0000062E VOL: 0
;PCODE: $0000062F VOL: 0
;PCODE: $00000630 VOL: 0
;PCODE: $00000631 VOL: 0
;PCODE: $00000632 VOL: 0
;PCODE: $00000633 VOL: 0
;PCODE: $00000634 VOL: 0
;PCODE: $00000635 VOL: 0
;PCODE: $00000636 VOL: 0
;PCODE: $00000637 VOL: 0
;	} while (cnt -= 2);
;PCODE: $00000638 VOL: 0
;PCODE: $00000639 VOL: 0
;PCODE: $0000063A VOL: 0
;PCODE: $0000063B VOL: 0
;PCODE: $0000063C VOL: 0
;PCODE: $0000063D VOL: 0
;PCODE: $0000063E VOL: 0
;}
;PCODE: $0000063F VOL: 0
;PCODE: $00000640 VOL: 0
;PCODE: $00000641 VOL: 0
;
;/* Receive a data block fast */
;static
;void rcvr_spi_multi (
;	BYTE *p,	/* Data buffer */
;	UINT cnt	/* Size of data block (must be multiple of 2) */
;)
;{
;PCODE: $00000642 VOL: 0
;PCODE: $00000643 VOL: 0
;	do {
;PCODE: $00000644 VOL: 0
;	*p -> Y+2
;	cnt -> Y+0
;PCODE: $00000645 VOL: 0
;		SPDR = 0xFF; while(!(SPSR & (1<<SPIF))); *p++ = SPDR;
;PCODE: $00000646 VOL: 0
;PCODE: $00000647 VOL: 0
;PCODE: $00000648 VOL: 0
;PCODE: $00000649 VOL: 0
;PCODE: $0000064A VOL: 0
;PCODE: $0000064B VOL: 0
;PCODE: $0000064C VOL: 0
;PCODE: $0000064D VOL: 0
;PCODE: $0000064E VOL: 0
;PCODE: $0000064F VOL: 0
;PCODE: $00000650 VOL: 0
;PCODE: $00000651 VOL: 0
;PCODE: $00000652 VOL: 0
;PCODE: $00000653 VOL: 0
;		SPDR = 0xFF; while(!(SPSR & (1<<SPIF))); *p++ = SPDR;
;PCODE: $00000654 VOL: 0
;PCODE: $00000655 VOL: 0
;PCODE: $00000656 VOL: 0
;PCODE: $00000657 VOL: 0
;PCODE: $00000658 VOL: 0
;PCODE: $00000659 VOL: 0
;PCODE: $0000065A VOL: 0
;PCODE: $0000065B VOL: 0
;PCODE: $0000065C VOL: 0
;PCODE: $0000065D VOL: 0
;PCODE: $0000065E VOL: 0
;PCODE: $0000065F VOL: 0
;PCODE: $00000660 VOL: 0
;PCODE: $00000661 VOL: 0
;	} while (cnt -= 2);
;PCODE: $00000662 VOL: 0
;PCODE: $00000663 VOL: 0
;PCODE: $00000664 VOL: 0
;PCODE: $00000665 VOL: 0
;PCODE: $00000666 VOL: 0
;PCODE: $00000667 VOL: 0
;PCODE: $00000668 VOL: 0
;}
;PCODE: $00000669 VOL: 0
;PCODE: $0000066A VOL: 0
;PCODE: $0000066B VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Wait for card ready                                                   */
;/*-----------------------------------------------------------------------*/
;
;static
;int wait_ready (	/* 1:Ready, 0:Timeout */
;	UINT wt			/* Timeout [ms] */
;)
;{
;PCODE: $0000066C VOL: 0
;PCODE: $0000066D VOL: 0
;	BYTE d;
;
;
;	WORD n = wt;
;	do
;PCODE: $0000066E VOL: 0
;PCODE: $0000066F VOL: 0
;	wt -> Y+4
;	d -> R17
;	n -> R18,R19
;PCODE: $00000670 VOL: 0
;PCODE: $00000671 VOL: 0
;PCODE: $00000672 VOL: 0
;    {
;	    d = xchg_spi(0xFF);
;PCODE: $00000673 VOL: 0
;PCODE: $00000674 VOL: 0
;PCODE: $00000675 VOL: 0
;    }
;	while (d != 0xFF && --wt);
;PCODE: $00000676 VOL: 0
;PCODE: $00000677 VOL: 0
;PCODE: $00000678 VOL: 0
;PCODE: $00000679 VOL: 0
;PCODE: $0000067A VOL: 0
;PCODE: $0000067B VOL: 0
;PCODE: $0000067C VOL: 0
;PCODE: $0000067D VOL: 0
;PCODE: $0000067E VOL: 0
;PCODE: $0000067F VOL: 0
;PCODE: $00000680 VOL: 0
;PCODE: $00000681 VOL: 0
;PCODE: $00000682 VOL: 0
;PCODE: $00000683 VOL: 0
;
;	return (d == 0xFF) ? 1 : 0;
;PCODE: $00000684 VOL: 0
;PCODE: $00000685 VOL: 0
;PCODE: $00000686 VOL: 0
;PCODE: $00000687 VOL: 0
;PCODE: $00000688 VOL: 0
;PCODE: $00000689 VOL: 0
;PCODE: $0000068A VOL: 0
;PCODE: $0000068B VOL: 0
;PCODE: $0000068C VOL: 0
;PCODE: $0000068D VOL: 0
;PCODE: $0000068E VOL: 0
;PCODE: $0000068F VOL: 0
;PCODE: $00000690 VOL: 0
;}
;PCODE: $00000691 VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Deselect the card and release SPI bus                                 */
;/*-----------------------------------------------------------------------*/
;
;static
;void deselect (void)
;{
;PCODE: $00000692 VOL: 0
;PCODE: $00000693 VOL: 0
;	CS_HIGH();
;PCODE: $00000694 VOL: 0
;PCODE: $00000695 VOL: 0
;	xchg_spi(0xFF);
;PCODE: $00000696 VOL: 0
;PCODE: $00000697 VOL: 0
;}
;PCODE: $00000698 VOL: 0
;PCODE: $00000699 VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Select the card and wait for ready                                    */
;/*-----------------------------------------------------------------------*/
;
;static
;int select (void)	/* 1:Successful, 0:Timeout */
;{
;PCODE: $0000069A VOL: 0
;PCODE: $0000069B VOL: 0
;	CS_LOW();		/* Set CS# low */
;PCODE: $0000069C VOL: 0
;PCODE: $0000069D VOL: 0
;	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
;PCODE: $0000069E VOL: 0
;PCODE: $0000069F VOL: 0
;    delay_ms(10);
;PCODE: $000006A0 VOL: 0
;PCODE: $000006A1 VOL: 0
;PCODE: $000006A2 VOL: 0
;    wait_ready(500);
;PCODE: $000006A3 VOL: 0
;PCODE: $000006A4 VOL: 0
;     return 1;	/* Wait for card ready */
;PCODE: $000006A5 VOL: 0
;PCODE: $000006A6 VOL: 0
;   // PORTD.0 = 1;
;	deselect();
;PCODE: $000006A7 VOL: 0
;	return 0;	/* Timeout */
;PCODE: $000006A8 VOL: 0
;PCODE: $000006A9 VOL: 0
;}
;PCODE: $000006AA VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Receive a data packet from MMC                                        */
;/*-----------------------------------------------------------------------*/
;
;static
;int rcvr_datablock (
;	BYTE *buff,			/* Data buffer to store received data */
;	UINT btr			/* Byte count (must be multiple of 4) */
;)
;{
;PCODE: $000006AB VOL: 0
;PCODE: $000006AC VOL: 0
;	BYTE token;
;    WORD n = 20;
;  //  release_spi();
;  //  init_spi(1);
;
;	do {							/* Wait for data packet in timeout of 200ms */
;PCODE: $000006AD VOL: 0
;PCODE: $000006AE VOL: 0
;	*buff -> Y+6
;	btr -> Y+4
;	token -> R17
;	n -> R18,R19
;PCODE: $000006AF VOL: 0
;PCODE: $000006B0 VOL: 0
;PCODE: $000006B1 VOL: 0
;		token = rcv_spi();
;PCODE: $000006B2 VOL: 0
;PCODE: $000006B3 VOL: 0
;PCODE: $000006B4 VOL: 0
;PCODE: $000006B5 VOL: 0
;PCODE: $000006B6 VOL: 0
;PCODE: $000006B7 VOL: 0
;PCODE: $000006B8 VOL: 0
;PCODE: $000006B9 VOL: 0
;PCODE: $000006BA VOL: 0
;PCODE: $000006BB VOL: 0
;PCODE: $000006BC VOL: 0
;PCODE: $000006BD VOL: 0
;PCODE: $000006BE VOL: 0
;PCODE: $000006BF VOL: 0
;        sprintf(terror,"error: %x",token);
;PCODE: $000006C0 VOL: 0
;PCODE: $000006C1 VOL: 0
;PCODE: $000006C2 VOL: 0
;PCODE: $000006C3 VOL: 0
;PCODE: $000006C4 VOL: 0
;PCODE: $000006C5 VOL: 0
;PCODE: $000006C6 VOL: 0
;PCODE: $000006C7 VOL: 0
;PCODE: $000006C8 VOL: 0
;PCODE: $000006C9 VOL: 0
;PCODE: $000006CA VOL: 0
;PCODE: $000006CB VOL: 0
;	} while ((token == 0xFF) && --n);
;PCODE: $000006CC VOL: 0
;PCODE: $000006CD VOL: 0
;PCODE: $000006CE VOL: 0
;PCODE: $000006CF VOL: 0
;PCODE: $000006D0 VOL: 0
;PCODE: $000006D1 VOL: 0
;PCODE: $000006D2 VOL: 0
;PCODE: $000006D3 VOL: 0
;PCODE: $000006D4 VOL: 0
;PCODE: $000006D5 VOL: 0
;PCODE: $000006D6 VOL: 0
;PCODE: $000006D7 VOL: 0
;PCODE: $000006D8 VOL: 0
;	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
;PCODE: $000006D9 VOL: 0
;PCODE: $000006DA VOL: 0
;PCODE: $000006DB VOL: 0
;PCODE: $000006DC VOL: 0
;PCODE: $000006DD VOL: 0
;PCODE: $000006DE VOL: 0
;PCODE: $000006DF VOL: 0
;
;	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
;PCODE: $000006E0 VOL: 0
;PCODE: $000006E1 VOL: 0
;PCODE: $000006E2 VOL: 0
;PCODE: $000006E3 VOL: 0
;PCODE: $000006E4 VOL: 0
;	xchg_spi(0xFF);					/* Discard CRC */
;PCODE: $000006E5 VOL: 0
;PCODE: $000006E6 VOL: 0
;	xchg_spi(0xFF);
;PCODE: $000006E7 VOL: 0
;PCODE: $000006E8 VOL: 0
;
;	return 1;						/* Return with success */
;PCODE: $000006E9 VOL: 0
;PCODE: $000006EA VOL: 0
;PCODE: $000006EB VOL: 0
;PCODE: $000006EC VOL: 0
;}
;PCODE: $000006ED VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Send a data packet to MMC                                             */
;/*-----------------------------------------------------------------------*/
;
;#if	_USE_WRITE
;static
;int xmit_datablock (
;	const BYTE *buff,	/* 512 byte data block to be transmitted */
;	BYTE token			/* Data/Stop token */
;)
;{
;PCODE: $000006EE VOL: 0
;PCODE: $000006EF VOL: 0
;	BYTE resp;
;
;
;	if (!wait_ready(500)) return 0;
;PCODE: $000006F0 VOL: 0
;PCODE: $000006F1 VOL: 0
;	*buff -> Y+2
;	token -> Y+1
;	resp -> R17
;PCODE: $000006F2 VOL: 0
;PCODE: $000006F3 VOL: 0
;PCODE: $000006F4 VOL: 0
;PCODE: $000006F5 VOL: 0
;PCODE: $000006F6 VOL: 0
;PCODE: $000006F7 VOL: 0
;PCODE: $000006F8 VOL: 0
;PCODE: $000006F9 VOL: 0
;PCODE: $000006FA VOL: 0
;
;	xchg_spi(token);					/* Xmit data token */
;PCODE: $000006FB VOL: 0
;PCODE: $000006FC VOL: 0
;PCODE: $000006FD VOL: 0
;	if (token != 0xFD) {	/* Is data token */
;PCODE: $000006FE VOL: 0
;PCODE: $000006FF VOL: 0
;PCODE: $00000700 VOL: 0
;		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
;PCODE: $00000701 VOL: 0
;PCODE: $00000702 VOL: 0
;PCODE: $00000703 VOL: 0
;PCODE: $00000704 VOL: 0
;		xchg_spi(0xFF);					/* CRC (Dummy) */
;PCODE: $00000705 VOL: 0
;PCODE: $00000706 VOL: 0
;		xchg_spi(0xFF);
;PCODE: $00000707 VOL: 0
;PCODE: $00000708 VOL: 0
;		resp = xchg_spi(0xFF);			/* Reveive data response */
;PCODE: $00000709 VOL: 0
;PCODE: $0000070A VOL: 0
;PCODE: $0000070B VOL: 0
;		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
;PCODE: $0000070C VOL: 0
;PCODE: $0000070D VOL: 0
;PCODE: $0000070E VOL: 0
;PCODE: $0000070F VOL: 0
;			return 0;
;PCODE: $00000710 VOL: 0
;PCODE: $00000711 VOL: 0
;PCODE: $00000712 VOL: 0
;PCODE: $00000713 VOL: 0
;PCODE: $00000714 VOL: 0
;	}
;PCODE: $00000715 VOL: 0
;
;	return 1;
;PCODE: $00000716 VOL: 0
;PCODE: $00000717 VOL: 0
;PCODE: $00000718 VOL: 0
;PCODE: $00000719 VOL: 0
;PCODE: $0000071A VOL: 0
;PCODE: $0000071B VOL: 0
;}
;PCODE: $0000071C VOL: 0
;#endif
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Send a command packet to MMC                                          */
;/*-----------------------------------------------------------------------*/
;
;static
;BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
;	BYTE cmd,		/* Command index */
;	DWORD arg		/* Argument */
;)
;{
;PCODE: $0000071D VOL: 0
;PCODE: $0000071E VOL: 0
;	BYTE n, res;
;	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
;PCODE: $0000071F VOL: 0
;PCODE: $00000720 VOL: 0
;PCODE: $00000721 VOL: 0
;	cmd -> Y+6
;	arg -> Y+2
;	n -> R17
;	res -> R16
;PCODE: $00000722 VOL: 0
;PCODE: $00000723 VOL: 0
;PCODE: $00000724 VOL: 0
;		cmd &= 0x7F;
;PCODE: $00000725 VOL: 0
;PCODE: $00000726 VOL: 0
;PCODE: $00000727 VOL: 0
;		res = send_cmd(CMD55, 0);
;PCODE: $00000728 VOL: 0
;PCODE: $00000729 VOL: 0
;PCODE: $0000072A VOL: 0
;PCODE: $0000072B VOL: 0
;PCODE: $0000072C VOL: 0
;		if (res > 1) return res;
;PCODE: $0000072D VOL: 0
;PCODE: $0000072E VOL: 0
;PCODE: $0000072F VOL: 0
;PCODE: $00000730 VOL: 0
;PCODE: $00000731 VOL: 0
;PCODE: $00000732 VOL: 0
;PCODE: $00000733 VOL: 0
;PCODE: $00000734 VOL: 0
;PCODE: $00000735 VOL: 0
;PCODE: $00000736 VOL: 0
;	}
;PCODE: $00000737 VOL: 0
;
;	/* Select the card */
;	if (cmd != CMD12) {
;PCODE: $00000738 VOL: 0
;PCODE: $00000739 VOL: 0
;PCODE: $0000073A VOL: 0
;PCODE: $0000073B VOL: 0
;		deselect();
;PCODE: $0000073C VOL: 0
;		if (!select()) return 0xFF;
;PCODE: $0000073D VOL: 0
;PCODE: $0000073E VOL: 0
;PCODE: $0000073F VOL: 0
;PCODE: $00000740 VOL: 0
;PCODE: $00000741 VOL: 0
;PCODE: $00000742 VOL: 0
;PCODE: $00000743 VOL: 0
;PCODE: $00000744 VOL: 0
;PCODE: $00000745 VOL: 0
;PCODE: $00000746 VOL: 0
;	}
;PCODE: $00000747 VOL: 0
;
;/* Send command packet */
;	xchg_spi(cmd);				/* Start + Command index */
;PCODE: $00000748 VOL: 0
;PCODE: $00000749 VOL: 0
;PCODE: $0000074A VOL: 0
;	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
;PCODE: $0000074B VOL: 0
;PCODE: $0000074C VOL: 0
;PCODE: $0000074D VOL: 0
;PCODE: $0000074E VOL: 0
;PCODE: $0000074F VOL: 0
;	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
;PCODE: $00000750 VOL: 0
;PCODE: $00000751 VOL: 0
;PCODE: $00000752 VOL: 0
;PCODE: $00000753 VOL: 0
;	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
;PCODE: $00000754 VOL: 0
;PCODE: $00000755 VOL: 0
;PCODE: $00000756 VOL: 0
;PCODE: $00000757 VOL: 0
;PCODE: $00000758 VOL: 0
;	xchg_spi((BYTE)arg);				/* Argument[7..0] */
;PCODE: $00000759 VOL: 0
;PCODE: $0000075A VOL: 0
;	n = 0x01;							/* Dummy CRC + Stop */
;PCODE: $0000075B VOL: 0
;PCODE: $0000075C VOL: 0
;	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
;PCODE: $0000075D VOL: 0
;PCODE: $0000075E VOL: 0
;PCODE: $0000075F VOL: 0
;PCODE: $00000760 VOL: 0
;PCODE: $00000761 VOL: 0
;	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
;PCODE: $00000762 VOL: 0
;PCODE: $00000763 VOL: 0
;PCODE: $00000764 VOL: 0
;PCODE: $00000765 VOL: 0
;PCODE: $00000766 VOL: 0
;PCODE: $00000767 VOL: 0
;	xchg_spi(n);
;PCODE: $00000768 VOL: 0
;PCODE: $00000769 VOL: 0
;PCODE: $0000076A VOL: 0
;
;	/* Receive command response */
;	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
;PCODE: $0000076B VOL: 0
;PCODE: $0000076C VOL: 0
;PCODE: $0000076D VOL: 0
;PCODE: $0000076E VOL: 0
;PCODE: $0000076F VOL: 0
;	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
;PCODE: $00000770 VOL: 0
;PCODE: $00000771 VOL: 0
;PCODE: $00000772 VOL: 0
;	do
;PCODE: $00000773 VOL: 0
;		res = xchg_spi(0xFF);
;PCODE: $00000774 VOL: 0
;PCODE: $00000775 VOL: 0
;PCODE: $00000776 VOL: 0
;	while ((res & 0x80) && --n);
;PCODE: $00000777 VOL: 0
;PCODE: $00000778 VOL: 0
;PCODE: $00000779 VOL: 0
;PCODE: $0000077A VOL: 0
;PCODE: $0000077B VOL: 0
;PCODE: $0000077C VOL: 0
;PCODE: $0000077D VOL: 0
;PCODE: $0000077E VOL: 0
;PCODE: $0000077F VOL: 0
;PCODE: $00000780 VOL: 0
;PCODE: $00000781 VOL: 0
;PCODE: $00000782 VOL: 0
;PCODE: $00000783 VOL: 0
;	return res;			/* Return with the response value */
;PCODE: $00000784 VOL: 0
;PCODE: $00000785 VOL: 0
;PCODE: $00000786 VOL: 0
;PCODE: $00000787 VOL: 0
;PCODE: $00000788 VOL: 0
;PCODE: $00000789 VOL: 0
;PCODE: $0000078A VOL: 0
;}
;PCODE: $0000078B VOL: 0
;
;
;
;/*--------------------------------------------------------------------------
;
;   Public Functions
;
;---------------------------------------------------------------------------*/
;
;
;/*-----------------------------------------------------------------------*/
;/* Initialize Disk Drive                                                 */
;/*-----------------------------------------------------------------------*/
;
;DSTATUS disk_initialize (
;	BYTE pdrv		/* Physical drive nmuber (0) */
;)
;{
;PCODE: $0000078C VOL: 0
;PCODE: $0000078D VOL: 0
;		BYTE n, cmd, ty, ocr[4];
;	UINT tmr;
;
;
;	if (pdrv) return STA_NOINIT;		/* Supports only single drive */
;PCODE: $0000078E VOL: 0
;PCODE: $0000078F VOL: 0
;PCODE: $00000790 VOL: 0
;	pdrv -> Y+10
;	n -> R17
;	cmd -> R16
;	ty -> R19
;	ocr -> Y+6
;	tmr -> R20,R21
;PCODE: $00000791 VOL: 0
;PCODE: $00000792 VOL: 0
;PCODE: $00000793 VOL: 0
;PCODE: $00000794 VOL: 0
;PCODE: $00000795 VOL: 0
;PCODE: $00000796 VOL: 0
;PCODE: $00000797 VOL: 0
;	//power_off();						/* Turn off the socket power to reset the card */
;	//if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
;	//power_on();							/* Turn on the socket power */
;	//FCLK_SLOW();
;    init_spi(0);
;PCODE: $00000798 VOL: 0
;PCODE: $00000799 VOL: 0
;PCODE: $0000079A VOL: 0
;	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
;PCODE: $0000079B VOL: 0
;PCODE: $0000079C VOL: 0
;PCODE: $0000079D VOL: 0
;PCODE: $0000079E VOL: 0
;PCODE: $0000079F VOL: 0
;PCODE: $000007A0 VOL: 0
;PCODE: $000007A1 VOL: 0
;PCODE: $000007A2 VOL: 0
;PCODE: $000007A3 VOL: 0
;PCODE: $000007A4 VOL: 0
;PCODE: $000007A5 VOL: 0
;PCODE: $000007A6 VOL: 0
;PCODE: $000007A7 VOL: 0
;PCODE: $000007A8 VOL: 0
;PCODE: $000007A9 VOL: 0
;PCODE: $000007AA VOL: 0
;PCODE: $000007AB VOL: 0
;		if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
;PCODE: $000007AC VOL: 0
;PCODE: $000007AD VOL: 0
;PCODE: $000007AE VOL: 0
;PCODE: $000007AF VOL: 0
;PCODE: $000007B0 VOL: 0
;PCODE: $000007B1 VOL: 0
;		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2 */
;PCODE: $000007B2 VOL: 0
;PCODE: $000007B3 VOL: 0
;PCODE: $000007B4 VOL: 0
;PCODE: $000007B5 VOL: 0
;PCODE: $000007B6 VOL: 0
;PCODE: $000007B7 VOL: 0
;			for (n = 0; n < 4; n++)
;PCODE: $000007B8 VOL: 0
;PCODE: $000007B9 VOL: 0
;PCODE: $000007BA VOL: 0
;PCODE: $000007BB VOL: 0
;PCODE: $000007BC VOL: 0
;PCODE: $000007BD VOL: 0
;PCODE: $000007BE VOL: 0
;PCODE: $000007BF VOL: 0
;PCODE: $000007C0 VOL: 0
;            {
;             ocr[n] = rcv_spi();
;PCODE: $000007C1 VOL: 0
;PCODE: $000007C2 VOL: 0
;PCODE: $000007C3 VOL: 0
;PCODE: $000007C4 VOL: 0
;PCODE: $000007C5 VOL: 0
;PCODE: $000007C6 VOL: 0
;PCODE: $000007C7 VOL: 0
;PCODE: $000007C8 VOL: 0
;PCODE: $000007C9 VOL: 0
;PCODE: $000007CA VOL: 0
;PCODE: $000007CB VOL: 0
;PCODE: $000007CC VOL: 0
;PCODE: $000007CD VOL: 0
;PCODE: $000007CE VOL: 0
;PCODE: $000007CF VOL: 0
;PCODE: $000007D0 VOL: 0
;PCODE: $000007D1 VOL: 0
;PCODE: $000007D2 VOL: 0
;             }		/* Get trailing return value of R7 resp */
;PCODE: $000007D3 VOL: 0
;PCODE: $000007D4 VOL: 0
;PCODE: $000007D5 VOL: 0
;PCODE: $000007D6 VOL: 0
;PCODE: $000007D7 VOL: 0
;			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {			/* The card can work at vdd range of 2.7-3.6V */
;PCODE: $000007D8 VOL: 0
;PCODE: $000007D9 VOL: 0
;PCODE: $000007DA VOL: 0
;PCODE: $000007DB VOL: 0
;PCODE: $000007DC VOL: 0
;PCODE: $000007DD VOL: 0
;PCODE: $000007DE VOL: 0
;PCODE: $000007DF VOL: 0
;PCODE: $000007E0 VOL: 0
;PCODE: $000007E1 VOL: 0
;				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) dly_100us();	/* Wait for leaving idle state (ACMD41 wit ...
;PCODE: $000007E2 VOL: 0
;PCODE: $000007E3 VOL: 0
;PCODE: $000007E4 VOL: 0
;PCODE: $000007E5 VOL: 0
;PCODE: $000007E6 VOL: 0
;PCODE: $000007E7 VOL: 0
;PCODE: $000007E8 VOL: 0
;PCODE: $000007E9 VOL: 0
;PCODE: $000007EA VOL: 0
;PCODE: $000007EB VOL: 0
;PCODE: $000007EC VOL: 0
;PCODE: $000007ED VOL: 0
;PCODE: $000007EE VOL: 0
;PCODE: $000007EF VOL: 0
;PCODE: $000007F0 VOL: 0
;PCODE: $000007F1 VOL: 0
;PCODE: $000007F2 VOL: 0
;PCODE: $000007F3 VOL: 0
;PCODE: $000007F4 VOL: 0
;PCODE: $000007F5 VOL: 0
;PCODE: $000007F6 VOL: 0
;PCODE: $000007F7 VOL: 0
;PCODE: $000007F8 VOL: 0
;PCODE: $000007F9 VOL: 0
;PCODE: $000007FA VOL: 0
;PCODE: $000007FB VOL: 0
;PCODE: $000007FC VOL: 0
;PCODE: $000007FD VOL: 0
;PCODE: $000007FE VOL: 0
;PCODE: $000007FF VOL: 0
;PCODE: $00000800 VOL: 0
;PCODE: $00000801 VOL: 0
;PCODE: $00000802 VOL: 0
;PCODE: $00000803 VOL: 0
;PCODE: $00000804 VOL: 0
;PCODE: $00000805 VOL: 0
;					for (n = 0; n < 4; n++)
;PCODE: $00000806 VOL: 0
;PCODE: $00000807 VOL: 0
;PCODE: $00000808 VOL: 0
;PCODE: $00000809 VOL: 0
;PCODE: $0000080A VOL: 0
;PCODE: $0000080B VOL: 0
;PCODE: $0000080C VOL: 0
;PCODE: $0000080D VOL: 0
;PCODE: $0000080E VOL: 0
;                    {
;                    ocr[n] = rcv_spi();
;PCODE: $0000080F VOL: 0
;PCODE: $00000810 VOL: 0
;PCODE: $00000811 VOL: 0
;PCODE: $00000812 VOL: 0
;PCODE: $00000813 VOL: 0
;PCODE: $00000814 VOL: 0
;PCODE: $00000815 VOL: 0
;PCODE: $00000816 VOL: 0
;PCODE: $00000817 VOL: 0
;PCODE: $00000818 VOL: 0
;PCODE: $00000819 VOL: 0
;PCODE: $0000081A VOL: 0
;PCODE: $0000081B VOL: 0
;PCODE: $0000081C VOL: 0
;PCODE: $0000081D VOL: 0
;PCODE: $0000081E VOL: 0
;PCODE: $0000081F VOL: 0
;PCODE: $00000820 VOL: 0
;                    }
;PCODE: $00000821 VOL: 0
;PCODE: $00000822 VOL: 0
;PCODE: $00000823 VOL: 0
;PCODE: $00000824 VOL: 0
;PCODE: $00000825 VOL: 0
;					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 (HC or SC) */
;PCODE: $00000826 VOL: 0
;PCODE: $00000827 VOL: 0
;PCODE: $00000828 VOL: 0
;PCODE: $00000829 VOL: 0
;PCODE: $0000082A VOL: 0
;PCODE: $0000082B VOL: 0
;PCODE: $0000082C VOL: 0
;PCODE: $0000082D VOL: 0
;PCODE: $0000082E VOL: 0
;PCODE: $0000082F VOL: 0
;				}
;			}
;PCODE: $00000830 VOL: 0
;		} else {							/* SDv1 or MMCv3 */
;PCODE: $00000831 VOL: 0
;PCODE: $00000832 VOL: 0
;PCODE: $00000833 VOL: 0
;			if (send_cmd(ACMD41, 0) <= 1) 	{
;PCODE: $00000834 VOL: 0
;PCODE: $00000835 VOL: 0
;PCODE: $00000836 VOL: 0
;PCODE: $00000837 VOL: 0
;PCODE: $00000838 VOL: 0
;PCODE: $00000839 VOL: 0
;				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
;PCODE: $0000083A VOL: 0
;PCODE: $0000083B VOL: 0
;PCODE: $0000083C VOL: 0
;PCODE: $0000083D VOL: 0
;			} else {
;PCODE: $0000083E VOL: 0
;PCODE: $0000083F VOL: 0
;				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
;PCODE: $00000840 VOL: 0
;PCODE: $00000841 VOL: 0
;PCODE: $00000842 VOL: 0
;PCODE: $00000843 VOL: 0
;			}
;PCODE: $00000844 VOL: 0
;			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--) dly_100us();	/* Wait for leaving idle state */
;PCODE: $00000845 VOL: 0
;PCODE: $00000846 VOL: 0
;PCODE: $00000847 VOL: 0
;PCODE: $00000848 VOL: 0
;PCODE: $00000849 VOL: 0
;PCODE: $0000084A VOL: 0
;PCODE: $0000084B VOL: 0
;PCODE: $0000084C VOL: 0
;PCODE: $0000084D VOL: 0
;PCODE: $0000084E VOL: 0
;PCODE: $0000084F VOL: 0
;PCODE: $00000850 VOL: 0
;PCODE: $00000851 VOL: 0
;PCODE: $00000852 VOL: 0
;PCODE: $00000853 VOL: 0
;PCODE: $00000854 VOL: 0
;PCODE: $00000855 VOL: 0
;PCODE: $00000856 VOL: 0
;PCODE: $00000857 VOL: 0
;PCODE: $00000858 VOL: 0
;PCODE: $00000859 VOL: 0
;PCODE: $0000085A VOL: 0
;PCODE: $0000085B VOL: 0
;PCODE: $0000085C VOL: 0
;PCODE: $0000085D VOL: 0
;PCODE: $0000085E VOL: 0
;PCODE: $0000085F VOL: 0
;PCODE: $00000860 VOL: 0
;PCODE: $00000861 VOL: 0
;PCODE: $00000862 VOL: 0
;PCODE: $00000863 VOL: 0
;PCODE: $00000864 VOL: 0
;PCODE: $00000865 VOL: 0
;				ty = 0;
;PCODE: $00000866 VOL: 0
;PCODE: $00000867 VOL: 0
;		}
;PCODE: $00000868 VOL: 0
;PCODE: $00000869 VOL: 0
;	}
;	CardType = ty;
;PCODE: $0000086A VOL: 0
;PCODE: $0000086B VOL: 0
;PCODE: $0000086C VOL: 0
;	deselect();
;PCODE: $0000086D VOL: 0
;
;	if (ty) {			/* Initialization succeded */
;PCODE: $0000086E VOL: 0
;PCODE: $0000086F VOL: 0
;		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
;PCODE: $00000870 VOL: 1
;PCODE: $00000871 VOL: 0
;PCODE: $00000872 VOL: 1
;		release_spi();
;PCODE: $00000873 VOL: 0
;	} else {			/* Initialization failed */
;PCODE: $00000874 VOL: 0
;PCODE: $00000875 VOL: 0
;		//power_off();
;	}
;PCODE: $00000876 VOL: 0
;
;	return Stat;
;PCODE: $00000877 VOL: 1
;PCODE: $00000878 VOL: 0
;PCODE: $00000879 VOL: 0
;PCODE: $0000087A VOL: 0
;}
;PCODE: $0000087B VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get Disk Status                                                       */
;/*-----------------------------------------------------------------------*/
;
;DSTATUS disk_status (
;	BYTE pdrv		/* Physical drive nmuber (0) */
;)
;{
;PCODE: $0000087C VOL: 0
;PCODE: $0000087D VOL: 0
;	if (pdrv) return STA_NOINIT;	/* Supports only single drive */
;PCODE: $0000087E VOL: 0
;	pdrv -> Y+0
;PCODE: $0000087F VOL: 0
;PCODE: $00000880 VOL: 0
;PCODE: $00000881 VOL: 0
;PCODE: $00000882 VOL: 0
;PCODE: $00000883 VOL: 0
;PCODE: $00000884 VOL: 0
;	return Stat;
;PCODE: $00000885 VOL: 0
;PCODE: $00000886 VOL: 1
;PCODE: $00000887 VOL: 0
;PCODE: $00000888 VOL: 0
;}
;PCODE: $00000889 VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read Sector(s)                                                        */
;/*-----------------------------------------------------------------------*/
;
;DRESULT disk_read (
;	BYTE pdrv,			/* Physical drive nmuber (0) */
;	BYTE *buff,			/* Pointer to the data buffer to store read data */
;	DWORD sector,		/* Start sector number (LBA) */
;	UINT count			/* Sector count (1..128) */
;)
;{
;PCODE: $0000088A VOL: 0
;PCODE: $0000088B VOL: 0
;		BYTE cmd;
;    init_spi(1);
;PCODE: $0000088C VOL: 0
;PCODE: $0000088D VOL: 0
;	pdrv -> Y+9
;	*buff -> Y+7
;	sector -> Y+3
;	count -> Y+1
;	cmd -> R17
;PCODE: $0000088E VOL: 0
;PCODE: $0000088F VOL: 0
;
;	if (pdrv || !count) return RES_PARERR;
;PCODE: $00000890 VOL: 0
;PCODE: $00000891 VOL: 0
;PCODE: $00000892 VOL: 0
;PCODE: $00000893 VOL: 0
;PCODE: $00000894 VOL: 0
;PCODE: $00000895 VOL: 0
;PCODE: $00000896 VOL: 0
;PCODE: $00000897 VOL: 0
;PCODE: $00000898 VOL: 0
;PCODE: $00000899 VOL: 0
;PCODE: $0000089A VOL: 0
;PCODE: $0000089B VOL: 0
;PCODE: $0000089C VOL: 0
;	if (Stat & STA_NOINIT) return RES_NOTRDY;
;PCODE: $0000089D VOL: 0
;PCODE: $0000089E VOL: 1
;PCODE: $0000089F VOL: 0
;PCODE: $000008A0 VOL: 0
;PCODE: $000008A1 VOL: 0
;PCODE: $000008A2 VOL: 0
;PCODE: $000008A3 VOL: 0
;PCODE: $000008A4 VOL: 0
;PCODE: $000008A5 VOL: 0
;
;	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
;PCODE: $000008A6 VOL: 0
;PCODE: $000008A7 VOL: 0
;PCODE: $000008A8 VOL: 0
;PCODE: $000008A9 VOL: 0
;PCODE: $000008AA VOL: 0
;PCODE: $000008AB VOL: 0
;PCODE: $000008AC VOL: 0
;PCODE: $000008AD VOL: 0
;
;	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
;PCODE: $000008AE VOL: 0
;PCODE: $000008AF VOL: 0
;PCODE: $000008B0 VOL: 0
;PCODE: $000008B1 VOL: 0
;PCODE: $000008B2 VOL: 0
;PCODE: $000008B3 VOL: 0
;PCODE: $000008B4 VOL: 0
;PCODE: $000008B5 VOL: 0
;PCODE: $000008B6 VOL: 0
;PCODE: $000008B7 VOL: 0
;PCODE: $000008B8 VOL: 0
;	if (send_cmd(cmd, sector) == 0) {
;PCODE: $000008B9 VOL: 0
;PCODE: $000008BA VOL: 0
;PCODE: $000008BB VOL: 0
;PCODE: $000008BC VOL: 0
;PCODE: $000008BD VOL: 0
;		do {
;PCODE: $000008BE VOL: 0
;			if (!rcvr_datablock(buff, 512)) break;
;PCODE: $000008BF VOL: 0
;PCODE: $000008C0 VOL: 0
;PCODE: $000008C1 VOL: 0
;PCODE: $000008C2 VOL: 0
;PCODE: $000008C3 VOL: 0
;PCODE: $000008C4 VOL: 0
;PCODE: $000008C5 VOL: 0
;			buff += 512;
;PCODE: $000008C6 VOL: 0
;PCODE: $000008C7 VOL: 0
;PCODE: $000008C8 VOL: 0
;PCODE: $000008C9 VOL: 0
;		} while (--count);
;PCODE: $000008CA VOL: 0
;PCODE: $000008CB VOL: 0
;PCODE: $000008CC VOL: 0
;PCODE: $000008CD VOL: 0
;PCODE: $000008CE VOL: 0
;PCODE: $000008CF VOL: 0
;PCODE: $000008D0 VOL: 0
;		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
;PCODE: $000008D1 VOL: 0
;PCODE: $000008D2 VOL: 0
;PCODE: $000008D3 VOL: 0
;PCODE: $000008D4 VOL: 0
;PCODE: $000008D5 VOL: 0
;PCODE: $000008D6 VOL: 0
;PCODE: $000008D7 VOL: 0
;	}
;PCODE: $000008D8 VOL: 0
;	deselect();
;PCODE: $000008D9 VOL: 0
;PCODE: $000008DA VOL: 0
;    release_spi();
;PCODE: $000008DB VOL: 0
;	return count ? RES_ERROR : RES_OK;
;PCODE: $000008DC VOL: 0
;PCODE: $000008DD VOL: 0
;PCODE: $000008DE VOL: 0
;PCODE: $000008DF VOL: 0
;PCODE: $000008E0 VOL: 0
;PCODE: $000008E1 VOL: 0
;PCODE: $000008E2 VOL: 0
;PCODE: $000008E3 VOL: 0
;PCODE: $000008E4 VOL: 0
;PCODE: $000008E5 VOL: 0
;PCODE: $000008E6 VOL: 0
;PCODE: $000008E7 VOL: 0
;PCODE: $000008E8 VOL: 0
;}
;PCODE: $000008E9 VOL: 0
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Write Sector(s)                                                       */
;/*-----------------------------------------------------------------------*/
;
;#if _USE_WRITE
;DRESULT disk_write (
;	BYTE pdrv,			/* Physical drive nmuber (0) */
;	const BYTE *buff,	/* Pointer to the data to be written */
;	DWORD sector,		/* Start sector number (LBA) */
;	UINT count			/* Sector count (1..128) */
;)
;{
;PCODE: $000008EA VOL: 0
;PCODE: $000008EB VOL: 0
;    init_spi(1);
;PCODE: $000008EC VOL: 0
;	pdrv -> Y+8
;	*buff -> Y+6
;	sector -> Y+2
;	count -> Y+0
;PCODE: $000008ED VOL: 0
;PCODE: $000008EE VOL: 0
;	if (pdrv || !count) return RES_PARERR;
;PCODE: $000008EF VOL: 0
;PCODE: $000008F0 VOL: 0
;PCODE: $000008F1 VOL: 0
;PCODE: $000008F2 VOL: 0
;PCODE: $000008F3 VOL: 0
;PCODE: $000008F4 VOL: 0
;PCODE: $000008F5 VOL: 0
;PCODE: $000008F6 VOL: 0
;PCODE: $000008F7 VOL: 0
;PCODE: $000008F8 VOL: 0
;PCODE: $000008F9 VOL: 0
;	if (Stat & STA_NOINIT) return RES_NOTRDY;
;PCODE: $000008FA VOL: 0
;PCODE: $000008FB VOL: 1
;PCODE: $000008FC VOL: 0
;PCODE: $000008FD VOL: 0
;PCODE: $000008FE VOL: 0
;PCODE: $000008FF VOL: 0
;PCODE: $00000900 VOL: 0
;	if (Stat & STA_PROTECT) return RES_WRPRT;
;PCODE: $00000901 VOL: 0
;PCODE: $00000902 VOL: 1
;PCODE: $00000903 VOL: 0
;PCODE: $00000904 VOL: 0
;PCODE: $00000905 VOL: 0
;PCODE: $00000906 VOL: 0
;PCODE: $00000907 VOL: 0
;
;	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
;PCODE: $00000908 VOL: 0
;PCODE: $00000909 VOL: 0
;PCODE: $0000090A VOL: 0
;PCODE: $0000090B VOL: 0
;PCODE: $0000090C VOL: 0
;PCODE: $0000090D VOL: 0
;PCODE: $0000090E VOL: 0
;PCODE: $0000090F VOL: 0
;
;	if (count == 1) {	/* Single block write */
;PCODE: $00000910 VOL: 0
;PCODE: $00000911 VOL: 0
;PCODE: $00000912 VOL: 0
;PCODE: $00000913 VOL: 0
;		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
;           && xmit_datablock(buff, 0xFE))
;PCODE: $00000914 VOL: 0
;PCODE: $00000915 VOL: 0
;PCODE: $00000916 VOL: 0
;PCODE: $00000917 VOL: 0
;PCODE: $00000918 VOL: 0
;PCODE: $00000919 VOL: 0
;PCODE: $0000091A VOL: 0
;PCODE: $0000091B VOL: 0
;PCODE: $0000091C VOL: 0
;PCODE: $0000091D VOL: 0
;PCODE: $0000091E VOL: 0
;PCODE: $0000091F VOL: 0
;PCODE: $00000920 VOL: 0
;PCODE: $00000921 VOL: 0
;PCODE: $00000922 VOL: 0
;PCODE: $00000923 VOL: 0
;			count = 0;
;PCODE: $00000924 VOL: 0
;PCODE: $00000925 VOL: 0
;	}
;PCODE: $00000926 VOL: 0
;	else {				/* Multiple block write */
;PCODE: $00000927 VOL: 0
;PCODE: $00000928 VOL: 0
;		if (CardType & CT_SDC) send_cmd(ACMD23, count);
;PCODE: $00000929 VOL: 0
;PCODE: $0000092A VOL: 0
;PCODE: $0000092B VOL: 0
;PCODE: $0000092C VOL: 0
;PCODE: $0000092D VOL: 0
;PCODE: $0000092E VOL: 0
;PCODE: $0000092F VOL: 0
;PCODE: $00000930 VOL: 0
;		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
;PCODE: $00000931 VOL: 0
;PCODE: $00000932 VOL: 0
;PCODE: $00000933 VOL: 0
;PCODE: $00000934 VOL: 0
;PCODE: $00000935 VOL: 0
;PCODE: $00000936 VOL: 0
;PCODE: $00000937 VOL: 0
;			do {
;PCODE: $00000938 VOL: 0
;				if (!xmit_datablock(buff, 0xFC)) break;
;PCODE: $00000939 VOL: 0
;PCODE: $0000093A VOL: 0
;PCODE: $0000093B VOL: 0
;PCODE: $0000093C VOL: 0
;PCODE: $0000093D VOL: 0
;PCODE: $0000093E VOL: 0
;PCODE: $0000093F VOL: 0
;				buff += 512;
;PCODE: $00000940 VOL: 0
;PCODE: $00000941 VOL: 0
;PCODE: $00000942 VOL: 0
;PCODE: $00000943 VOL: 0
;			} while (--count);
;PCODE: $00000944 VOL: 0
;PCODE: $00000945 VOL: 0
;PCODE: $00000946 VOL: 0
;PCODE: $00000947 VOL: 0
;PCODE: $00000948 VOL: 0
;PCODE: $00000949 VOL: 0
;PCODE: $0000094A VOL: 0
;			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
;PCODE: $0000094B VOL: 0
;PCODE: $0000094C VOL: 0
;PCODE: $0000094D VOL: 0
;PCODE: $0000094E VOL: 0
;PCODE: $0000094F VOL: 0
;PCODE: $00000950 VOL: 0
;				count = 1;
;PCODE: $00000951 VOL: 0
;PCODE: $00000952 VOL: 0
;		}
;PCODE: $00000953 VOL: 0
;	}
;PCODE: $00000954 VOL: 0
;PCODE: $00000955 VOL: 0
;	deselect();
;PCODE: $00000956 VOL: 0
;    release_spi();
;PCODE: $00000957 VOL: 0
;	return count ? RES_ERROR : RES_OK;
;PCODE: $00000958 VOL: 0
;PCODE: $00000959 VOL: 0
;PCODE: $0000095A VOL: 0
;PCODE: $0000095B VOL: 0
;PCODE: $0000095C VOL: 0
;PCODE: $0000095D VOL: 0
;PCODE: $0000095E VOL: 0
;PCODE: $0000095F VOL: 0
;PCODE: $00000960 VOL: 0
;PCODE: $00000961 VOL: 0
;PCODE: $00000962 VOL: 0
;}
;PCODE: $00000963 VOL: 0
;#endif
;
;
;/*-----------------------------------------------------------------------*/
;/* Miscellaneous Functions                                               */
;/*-----------------------------------------------------------------------*/
;
;#if _USE_IOCTL
;DRESULT disk_ioctl (
;	BYTE pdrv,		/* Physical drive nmuber (0) */
;	BYTE cmd,		/* Control code */
;	void *buff		/* Buffer to send/receive control data */
;)
;{
;PCODE: $00000964 VOL: 0
;PCODE: $00000965 VOL: 0
;	DRESULT res;
;	BYTE n, csd[16], *ptr = buff;
;	DWORD csize;
;
;    init_spi(1);
;PCODE: $00000966 VOL: 0
;PCODE: $00000967 VOL: 0
;PCODE: $00000968 VOL: 0
;	pdrv -> Y+27
;	cmd -> Y+26
;	*buff -> Y+24
;	res -> R17
;	n -> R16
;	csd -> Y+8
;	*ptr -> R18,R19
;	csize -> Y+4
;PCODE: $00000969 VOL: 0
;PCODE: $0000096A VOL: 0
;PCODE: $0000096B VOL: 0
;PCODE: $0000096C VOL: 0
;	if (pdrv) return RES_PARERR;
;PCODE: $0000096D VOL: 0
;PCODE: $0000096E VOL: 0
;PCODE: $0000096F VOL: 0
;PCODE: $00000970 VOL: 0
;PCODE: $00000971 VOL: 0
;PCODE: $00000972 VOL: 0
;PCODE: $00000973 VOL: 0
;
;	res = RES_ERROR;
;PCODE: $00000974 VOL: 0
;PCODE: $00000975 VOL: 0
;PCODE: $00000976 VOL: 0
;
;	if (Stat & STA_NOINIT) return RES_NOTRDY;
;PCODE: $00000977 VOL: 1
;PCODE: $00000978 VOL: 0
;PCODE: $00000979 VOL: 0
;PCODE: $0000097A VOL: 0
;PCODE: $0000097B VOL: 0
;PCODE: $0000097C VOL: 0
;PCODE: $0000097D VOL: 0
;
;	switch (cmd) {
;PCODE: $0000097E VOL: 0
;PCODE: $0000097F VOL: 0
;PCODE: $00000980 VOL: 0
;	case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updat ...
;PCODE: $00000981 VOL: 0
;PCODE: $00000982 VOL: 0
;		if (select()) res = RES_OK;
;PCODE: $00000983 VOL: 0
;PCODE: $00000984 VOL: 0
;PCODE: $00000985 VOL: 0
;PCODE: $00000986 VOL: 0
;PCODE: $00000987 VOL: 0
;		break;
;PCODE: $00000988 VOL: 0
;PCODE: $00000989 VOL: 0
;
;	case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;PCODE: $0000098A VOL: 0
;PCODE: $0000098B VOL: 0
;PCODE: $0000098C VOL: 0
;		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
;PCODE: $0000098D VOL: 0
;PCODE: $0000098E VOL: 0
;PCODE: $0000098F VOL: 0
;PCODE: $00000990 VOL: 0
;PCODE: $00000991 VOL: 0
;PCODE: $00000992 VOL: 0
;PCODE: $00000993 VOL: 0
;PCODE: $00000994 VOL: 0
;PCODE: $00000995 VOL: 0
;PCODE: $00000996 VOL: 0
;PCODE: $00000997 VOL: 0
;PCODE: $00000998 VOL: 0
;PCODE: $00000999 VOL: 0
;PCODE: $0000099A VOL: 0
;PCODE: $0000099B VOL: 0
;PCODE: $0000099C VOL: 0
;PCODE: $0000099D VOL: 0
;			if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
;PCODE: $0000099E VOL: 0
;PCODE: $0000099F VOL: 0
;PCODE: $000009A0 VOL: 0
;PCODE: $000009A1 VOL: 0
;PCODE: $000009A2 VOL: 0
;PCODE: $000009A3 VOL: 0
;				csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
;PCODE: $000009A4 VOL: 0
;PCODE: $000009A5 VOL: 0
;PCODE: $000009A6 VOL: 0
;PCODE: $000009A7 VOL: 0
;PCODE: $000009A8 VOL: 0
;PCODE: $000009A9 VOL: 0
;PCODE: $000009AA VOL: 0
;PCODE: $000009AB VOL: 0
;PCODE: $000009AC VOL: 0
;PCODE: $000009AD VOL: 0
;PCODE: $000009AE VOL: 0
;PCODE: $000009AF VOL: 0
;PCODE: $000009B0 VOL: 0
;				*(DWORD*)buff = csize << 10;
;PCODE: $000009B1 VOL: 0
;PCODE: $000009B2 VOL: 0
;PCODE: $000009B3 VOL: 0
;PCODE: $000009B4 VOL: 0
;PCODE: $000009B5 VOL: 0
;			} else {					/* SDC ver 1.XX or MMC*/
;PCODE: $000009B6 VOL: 0
;PCODE: $000009B7 VOL: 0
;				n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
;PCODE: $000009B8 VOL: 0
;PCODE: $000009B9 VOL: 0
;PCODE: $000009BA VOL: 0
;PCODE: $000009BB VOL: 0
;PCODE: $000009BC VOL: 0
;PCODE: $000009BD VOL: 0
;PCODE: $000009BE VOL: 0
;PCODE: $000009BF VOL: 0
;PCODE: $000009C0 VOL: 0
;PCODE: $000009C1 VOL: 0
;PCODE: $000009C2 VOL: 0
;PCODE: $000009C3 VOL: 0
;PCODE: $000009C4 VOL: 0
;PCODE: $000009C5 VOL: 0
;PCODE: $000009C6 VOL: 0
;				csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
;PCODE: $000009C7 VOL: 0
;PCODE: $000009C8 VOL: 0
;PCODE: $000009C9 VOL: 0
;PCODE: $000009CA VOL: 0
;PCODE: $000009CB VOL: 0
;PCODE: $000009CC VOL: 0
;PCODE: $000009CD VOL: 0
;PCODE: $000009CE VOL: 0
;PCODE: $000009CF VOL: 0
;PCODE: $000009D0 VOL: 0
;PCODE: $000009D1 VOL: 0
;PCODE: $000009D2 VOL: 0
;PCODE: $000009D3 VOL: 0
;PCODE: $000009D4 VOL: 0
;PCODE: $000009D5 VOL: 0
;PCODE: $000009D6 VOL: 0
;PCODE: $000009D7 VOL: 0
;PCODE: $000009D8 VOL: 0
;				*(DWORD*)buff = csize << (n - 9);
;PCODE: $000009D9 VOL: 0
;PCODE: $000009DA VOL: 0
;PCODE: $000009DB VOL: 0
;PCODE: $000009DC VOL: 0
;PCODE: $000009DD VOL: 0
;PCODE: $000009DE VOL: 0
;			}
;PCODE: $000009DF VOL: 0
;			res = RES_OK;
;PCODE: $000009E0 VOL: 0
;PCODE: $000009E1 VOL: 0
;		}
;		break;
;PCODE: $000009E2 VOL: 0
;PCODE: $000009E3 VOL: 0
;
;	case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;PCODE: $000009E4 VOL: 0
;PCODE: $000009E5 VOL: 0
;PCODE: $000009E6 VOL: 0
;		if (CardType & CT_SD2) {	/* SDv2? */
;PCODE: $000009E7 VOL: 0
;PCODE: $000009E8 VOL: 0
;PCODE: $000009E9 VOL: 0
;			if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
;PCODE: $000009EA VOL: 0
;PCODE: $000009EB VOL: 0
;PCODE: $000009EC VOL: 0
;PCODE: $000009ED VOL: 0
;PCODE: $000009EE VOL: 0
;PCODE: $000009EF VOL: 0
;				xchg_spi(0xFF);
;PCODE: $000009F0 VOL: 0
;PCODE: $000009F1 VOL: 0
;				if (rcvr_datablock(csd, 16)) {				/* Read partial block */
;PCODE: $000009F2 VOL: 0
;PCODE: $000009F3 VOL: 0
;PCODE: $000009F4 VOL: 0
;PCODE: $000009F5 VOL: 0
;PCODE: $000009F6 VOL: 0
;PCODE: $000009F7 VOL: 0
;PCODE: $000009F8 VOL: 0
;					for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
;PCODE: $000009F9 VOL: 0
;PCODE: $000009FA VOL: 0
;PCODE: $000009FB VOL: 0
;PCODE: $000009FC VOL: 0
;PCODE: $000009FD VOL: 0
;PCODE: $000009FE VOL: 0
;PCODE: $000009FF VOL: 0
;PCODE: $00000A00 VOL: 0
;PCODE: $00000A01 VOL: 0
;PCODE: $00000A02 VOL: 0
;PCODE: $00000A03 VOL: 0
;PCODE: $00000A04 VOL: 0
;PCODE: $00000A05 VOL: 0
;PCODE: $00000A06 VOL: 0
;PCODE: $00000A07 VOL: 0
;PCODE: $00000A08 VOL: 0
;PCODE: $00000A09 VOL: 0
;PCODE: $00000A0A VOL: 0
;PCODE: $00000A0B VOL: 0
;PCODE: $00000A0C VOL: 0
;PCODE: $00000A0D VOL: 0
;					res = RES_OK;
;PCODE: $00000A0E VOL: 0
;PCODE: $00000A0F VOL: 0
;				}
;			}
;PCODE: $00000A10 VOL: 0
;		} else {					/* SDv1 or MMCv3 */
;PCODE: $00000A11 VOL: 0
;PCODE: $00000A12 VOL: 0
;PCODE: $00000A13 VOL: 0
;			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
;PCODE: $00000A14 VOL: 0
;PCODE: $00000A15 VOL: 0
;PCODE: $00000A16 VOL: 0
;PCODE: $00000A17 VOL: 0
;PCODE: $00000A18 VOL: 0
;PCODE: $00000A19 VOL: 0
;PCODE: $00000A1A VOL: 0
;PCODE: $00000A1B VOL: 0
;PCODE: $00000A1C VOL: 0
;PCODE: $00000A1D VOL: 0
;PCODE: $00000A1E VOL: 0
;PCODE: $00000A1F VOL: 0
;PCODE: $00000A20 VOL: 0
;PCODE: $00000A21 VOL: 0
;PCODE: $00000A22 VOL: 0
;PCODE: $00000A23 VOL: 0
;PCODE: $00000A24 VOL: 0
;				if (CardType & CT_SD1) {	/* SDv1 */
;PCODE: $00000A25 VOL: 0
;PCODE: $00000A26 VOL: 0
;PCODE: $00000A27 VOL: 0
;					*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
;PCODE: $00000A28 VOL: 0
;PCODE: $00000A29 VOL: 0
;PCODE: $00000A2A VOL: 0
;PCODE: $00000A2B VOL: 0
;PCODE: $00000A2C VOL: 0
;PCODE: $00000A2D VOL: 0
;PCODE: $00000A2E VOL: 0
;PCODE: $00000A2F VOL: 0
;PCODE: $00000A30 VOL: 0
;PCODE: $00000A31 VOL: 0
;PCODE: $00000A32 VOL: 0
;PCODE: $00000A33 VOL: 0
;PCODE: $00000A34 VOL: 0
;PCODE: $00000A35 VOL: 0
;PCODE: $00000A36 VOL: 0
;PCODE: $00000A37 VOL: 0
;PCODE: $00000A38 VOL: 0
;PCODE: $00000A39 VOL: 0
;PCODE: $00000A3A VOL: 0
;				} else {					/* MMCv3 */
;PCODE: $00000A3B VOL: 0
;PCODE: $00000A3C VOL: 0
;					*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
;PCODE: $00000A3D VOL: 0
;PCODE: $00000A3E VOL: 0
;PCODE: $00000A3F VOL: 0
;PCODE: $00000A40 VOL: 0
;PCODE: $00000A41 VOL: 0
;PCODE: $00000A42 VOL: 0
;PCODE: $00000A43 VOL: 0
;PCODE: $00000A44 VOL: 0
;PCODE: $00000A45 VOL: 0
;PCODE: $00000A46 VOL: 0
;PCODE: $00000A47 VOL: 0
;PCODE: $00000A48 VOL: 0
;PCODE: $00000A49 VOL: 0
;PCODE: $00000A4A VOL: 0
;PCODE: $00000A4B VOL: 0
;PCODE: $00000A4C VOL: 0
;PCODE: $00000A4D VOL: 0
;PCODE: $00000A4E VOL: 0
;PCODE: $00000A4F VOL: 0
;PCODE: $00000A50 VOL: 0
;PCODE: $00000A51 VOL: 0
;PCODE: $00000A52 VOL: 0
;PCODE: $00000A53 VOL: 0
;				}
;PCODE: $00000A54 VOL: 0
;				res = RES_OK;
;PCODE: $00000A55 VOL: 0
;PCODE: $00000A56 VOL: 0
;			}
;		}
;PCODE: $00000A57 VOL: 0
;PCODE: $00000A58 VOL: 0
;		break;
;PCODE: $00000A59 VOL: 0
;
;	/* Following commands are never used by FatFs module */
;
;	case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
;PCODE: $00000A5A VOL: 0
;PCODE: $00000A5B VOL: 0
;PCODE: $00000A5C VOL: 0
;		*ptr = CardType;
;PCODE: $00000A5D VOL: 0
;PCODE: $00000A5E VOL: 0
;PCODE: $00000A5F VOL: 0
;		res = RES_OK;
;PCODE: $00000A60 VOL: 0
;PCODE: $00000A61 VOL: 0
;		break;
;PCODE: $00000A62 VOL: 0
;
;	case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
;PCODE: $00000A63 VOL: 0
;PCODE: $00000A64 VOL: 0
;PCODE: $00000A65 VOL: 0
;		if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
;			&& rcvr_datablock(ptr, 16))
;PCODE: $00000A66 VOL: 0
;PCODE: $00000A67 VOL: 0
;PCODE: $00000A68 VOL: 0
;PCODE: $00000A69 VOL: 0
;PCODE: $00000A6A VOL: 0
;PCODE: $00000A6B VOL: 0
;PCODE: $00000A6C VOL: 0
;PCODE: $00000A6D VOL: 0
;PCODE: $00000A6E VOL: 0
;PCODE: $00000A6F VOL: 0
;PCODE: $00000A70 VOL: 0
;PCODE: $00000A71 VOL: 0
;PCODE: $00000A72 VOL: 0
;PCODE: $00000A73 VOL: 0
;PCODE: $00000A74 VOL: 0
;PCODE: $00000A75 VOL: 0
;			res = RES_OK;
;PCODE: $00000A76 VOL: 0
;PCODE: $00000A77 VOL: 0
;		break;
;PCODE: $00000A78 VOL: 0
;PCODE: $00000A79 VOL: 0
;
;	case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
;PCODE: $00000A7A VOL: 0
;PCODE: $00000A7B VOL: 0
;PCODE: $00000A7C VOL: 0
;		if (send_cmd(CMD10, 0) == 0		/* READ_CID */
;			&& rcvr_datablock(ptr, 16))
;PCODE: $00000A7D VOL: 0
;PCODE: $00000A7E VOL: 0
;PCODE: $00000A7F VOL: 0
;PCODE: $00000A80 VOL: 0
;PCODE: $00000A81 VOL: 0
;PCODE: $00000A82 VOL: 0
;PCODE: $00000A83 VOL: 0
;PCODE: $00000A84 VOL: 0
;PCODE: $00000A85 VOL: 0
;PCODE: $00000A86 VOL: 0
;PCODE: $00000A87 VOL: 0
;PCODE: $00000A88 VOL: 0
;PCODE: $00000A89 VOL: 0
;PCODE: $00000A8A VOL: 0
;PCODE: $00000A8B VOL: 0
;PCODE: $00000A8C VOL: 0
;			res = RES_OK;
;PCODE: $00000A8D VOL: 0
;PCODE: $00000A8E VOL: 0
;		break;
;PCODE: $00000A8F VOL: 0
;PCODE: $00000A90 VOL: 0
;
;	case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
;PCODE: $00000A91 VOL: 0
;PCODE: $00000A92 VOL: 0
;PCODE: $00000A93 VOL: 0
;		if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
;PCODE: $00000A94 VOL: 0
;PCODE: $00000A95 VOL: 0
;PCODE: $00000A96 VOL: 0
;PCODE: $00000A97 VOL: 0
;PCODE: $00000A98 VOL: 0
;PCODE: $00000A99 VOL: 0
;			for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
;PCODE: $00000A9A VOL: 0
;PCODE: $00000A9B VOL: 0
;PCODE: $00000A9C VOL: 0
;PCODE: $00000A9D VOL: 0
;PCODE: $00000A9E VOL: 0
;PCODE: $00000A9F VOL: 0
;PCODE: $00000AA0 VOL: 0
;PCODE: $00000AA1 VOL: 0
;PCODE: $00000AA2 VOL: 0
;PCODE: $00000AA3 VOL: 0
;PCODE: $00000AA4 VOL: 0
;PCODE: $00000AA5 VOL: 0
;PCODE: $00000AA6 VOL: 0
;PCODE: $00000AA7 VOL: 0
;PCODE: $00000AA8 VOL: 0
;PCODE: $00000AA9 VOL: 0
;PCODE: $00000AAA VOL: 0
;PCODE: $00000AAB VOL: 0
;PCODE: $00000AAC VOL: 0
;PCODE: $00000AAD VOL: 0
;PCODE: $00000AAE VOL: 0
;PCODE: $00000AAF VOL: 0
;		}
;		break;
;PCODE: $00000AB0 VOL: 0
;PCODE: $00000AB1 VOL: 0
;
;	case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
;PCODE: $00000AB2 VOL: 0
;PCODE: $00000AB3 VOL: 0
;PCODE: $00000AB4 VOL: 0
;		if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
;PCODE: $00000AB5 VOL: 0
;PCODE: $00000AB6 VOL: 0
;PCODE: $00000AB7 VOL: 0
;PCODE: $00000AB8 VOL: 0
;PCODE: $00000AB9 VOL: 0
;PCODE: $00000ABA VOL: 0
;			xchg_spi(0xFF);
;PCODE: $00000ABB VOL: 0
;PCODE: $00000ABC VOL: 0
;			if (rcvr_datablock(ptr, 64))
;PCODE: $00000ABD VOL: 0
;PCODE: $00000ABE VOL: 0
;PCODE: $00000ABF VOL: 0
;PCODE: $00000AC0 VOL: 0
;PCODE: $00000AC1 VOL: 0
;PCODE: $00000AC2 VOL: 0
;				res = RES_OK;
;PCODE: $00000AC3 VOL: 0
;PCODE: $00000AC4 VOL: 0
;		}
;PCODE: $00000AC5 VOL: 0
;		break;
;PCODE: $00000AC6 VOL: 0
;PCODE: $00000AC7 VOL: 0
;
;	//case CTRL_POWER_OFF :	/* Power off */
;	//	power_off();
;	//	Stat |= STA_NOINIT;
;	//	res = RES_OK;
;	//	break;
;
;	default:
;PCODE: $00000AC8 VOL: 0
;		res = RES_PARERR;
;PCODE: $00000AC9 VOL: 0
;PCODE: $00000ACA VOL: 0
;	}
;PCODE: $00000ACB VOL: 0
;
;	deselect();
;PCODE: $00000ACC VOL: 0
;    release_spi();
;PCODE: $00000ACD VOL: 0
;	return res;
;PCODE: $00000ACE VOL: 0
;PCODE: $00000ACF VOL: 0
;PCODE: $00000AD0 VOL: 0
;PCODE: $00000AD1 VOL: 0
;}
;PCODE: $00000AD2 VOL: 0
;#endif
;
;
;/*-----------------------------------------------------------------------*/
;/* Device Timer Interrupt Procedure                                      */
;/*-----------------------------------------------------------------------*/
;/* This function must be called in period of 10ms                        */
;
;void disk_timerproc (void)
;{
;PCODE: $00000AD3 VOL: 0
;PCODE: $00000AD4 VOL: 0
;	BYTE n, s;
;
;
;	n = Timer1;				/* 100Hz decrement timer */
;PCODE: $00000AD5 VOL: 0
;PCODE: $00000AD6 VOL: 0
;	n -> R17
;	s -> R16
;PCODE: $00000AD7 VOL: 0
;PCODE: $00000AD8 VOL: 1
;	if (n) Timer1 = --n;
;PCODE: $00000AD9 VOL: 0
;PCODE: $00000ADA VOL: 0
;PCODE: $00000ADB VOL: 0
;PCODE: $00000ADC VOL: 0
;PCODE: $00000ADD VOL: 1
;PCODE: $00000ADE VOL: 0
;	n = Timer2;
;PCODE: $00000ADF VOL: 0
;PCODE: $00000AE0 VOL: 0
;PCODE: $00000AE1 VOL: 1
;	if (n) Timer2 = --n;
;PCODE: $00000AE2 VOL: 0
;PCODE: $00000AE3 VOL: 0
;PCODE: $00000AE4 VOL: 0
;PCODE: $00000AE5 VOL: 0
;PCODE: $00000AE6 VOL: 1
;PCODE: $00000AE7 VOL: 0
;
;	s = Stat;
;PCODE: $00000AE8 VOL: 0
;PCODE: $00000AE9 VOL: 0
;PCODE: $00000AEA VOL: 1
;
;	//if (MMC_WP)				/* Write protected */
;	//	s |= STA_PROTECT;
;	//else					/* Write enabled */
;		s &= ~STA_PROTECT;
;PCODE: $00000AEB VOL: 0
;PCODE: $00000AEC VOL: 0
;
;	//if (MMC_CD)				/* Card inserted */
;	//	s &= ~STA_NODISK;
;	//else					/* Socket empty */
;		s |= (STA_NODISK | STA_NOINIT);
;PCODE: $00000AED VOL: 0
;PCODE: $00000AEE VOL: 0
;
;	Stat = s;				/* Update MMC status */
;PCODE: $00000AEF VOL: 1
;PCODE: $00000AF0 VOL: 0
;}
;PCODE: $00000AF1 VOL: 0
;PCODE: $00000AF2 VOL: 0
;PCODE: $00000AF3 VOL: 0
;#include "vrgl_primitives.c"
;#include "Nokia6610_lcd_lib.h"
;#include "vrgl_primitives.h"
;#include <delay.h>
;
;
;void VRGL_CreateBox(unsigned char nX,unsigned char nY, unsigned char sX,unsigned char sY,int nColor,unsigned char bFill)
;{
;PCODE: $00000AF4 VOL: 0
;PCODE: $00000AF5 VOL: 0
;nlcd_Box(nX,nY,nX+sX,nY+sY,bFill,nColor,0);
;PCODE: $00000AF6 VOL: 0
;	nX -> Y+6
;	nY -> Y+5
;	sX -> Y+4
;	sY -> Y+3
;	nColor -> Y+1
;	bFill -> Y+0
;PCODE: $00000AF7 VOL: 0
;PCODE: $00000AF8 VOL: 0
;PCODE: $00000AF9 VOL: 0
;PCODE: $00000AFA VOL: 0
;PCODE: $00000AFB VOL: 0
;PCODE: $00000AFC VOL: 0
;PCODE: $00000AFD VOL: 0
;PCODE: $00000AFE VOL: 0
;PCODE: $00000AFF VOL: 0
;PCODE: $00000B00 VOL: 0
;PCODE: $00000B01 VOL: 0
;PCODE: $00000B02 VOL: 0
;PCODE: $00000B03 VOL: 0
;PCODE: $00000B04 VOL: 0
;PCODE: $00000B05 VOL: 0
;PCODE: $00000B06 VOL: 0
;PCODE: $00000B07 VOL: 0
;PCODE: $00000B08 VOL: 0
;PCODE: $00000B09 VOL: 0
;}
;PCODE: $00000B0A VOL: 0
;PCODE: $00000B0B VOL: 0
;PCODE: $00000B0C VOL: 0
;
;void VRGL_CreateLine(unsigned char nX0,unsigned char nY0, unsigned char nX1,unsigned char nY1,int nColor)
;{
;PCODE: $00000B0D VOL: 0
;PCODE: $00000B0E VOL: 0
;//nlcd_Line(nX0,nY0,nX1,nY1,nColor);
;}
;PCODE: $00000B0F VOL: 0
;PCODE: $00000B10 VOL: 0
;PCODE: $00000B11 VOL: 0
;
;#include "twi/twim.c"
;//***************************************************************************
;//
;//  Author(s)...: Павел Бобков  http://ChipEnable.Ru
;//
;//  Target(s)...: mega16
;//
;//  Compiler....: CodeVision
;//
;//  Description.: Драйвер ведущего TWI устройства.
;//                Код основан на Atmel`овских доках - AVR315.
;//
;//  Data........: 13.11.13
;//
;//***************************************************************************
;#include "twim.h"
;
;#define TWSR_MASK     0xfc
;
;volatile static uint8_t twiBuf[TWI_BUFFER_SIZE];
;volatile static uint8_t twiState = TWI_NO_STATE;

	.DSEG
;volatile static uint8_t twiMsgSize;
;
;/*предделители для установки скорости обмена twi модуля*/
;uint8_t pre[4] = {2, 8, 32, 128};
;
;/****************************************************************************
; Инициализация и установка частоты SCL сигнала
;****************************************************************************/
;uint8_t TWI_MasterInit(uint16_t fr)
;{

	.CSEG
;PCODE: $00000B12 VOL: 0
;PCODE: $00000B13 VOL: 0
;  uint8_t i;
;  uint16_t twbrValue;
;
;  for(i = 0; i<4; i++){
;PCODE: $00000B14 VOL: 0
;PCODE: $00000B15 VOL: 0
;	fr -> Y+4
;	i -> R17
;	twbrValue -> R18,R19
;PCODE: $00000B16 VOL: 0
;PCODE: $00000B17 VOL: 0
;PCODE: $00000B18 VOL: 0
;PCODE: $00000B19 VOL: 0
;PCODE: $00000B1A VOL: 0
;PCODE: $00000B1B VOL: 0
;PCODE: $00000B1C VOL: 0
;PCODE: $00000B1D VOL: 0
;PCODE: $00000B1E VOL: 0
;    twbrValue = ((((F_CPU)/1000UL)/fr)-16)/pre[i];
;PCODE: $00000B1F VOL: 0
;PCODE: $00000B20 VOL: 0
;PCODE: $00000B21 VOL: 0
;PCODE: $00000B22 VOL: 0
;PCODE: $00000B23 VOL: 0
;PCODE: $00000B24 VOL: 0
;PCODE: $00000B25 VOL: 0
;PCODE: $00000B26 VOL: 0
;PCODE: $00000B27 VOL: 0
;PCODE: $00000B28 VOL: 0
;PCODE: $00000B29 VOL: 0
;PCODE: $00000B2A VOL: 0
;    if ((twbrValue > 0)&& (twbrValue < 256)){
;PCODE: $00000B2B VOL: 0
;PCODE: $00000B2C VOL: 0
;PCODE: $00000B2D VOL: 0
;PCODE: $00000B2E VOL: 0
;PCODE: $00000B2F VOL: 0
;PCODE: $00000B30 VOL: 0
;PCODE: $00000B31 VOL: 0
;PCODE: $00000B32 VOL: 0
;PCODE: $00000B33 VOL: 0
;       TWBR = (uint8_t)twbrValue;
;PCODE: $00000B34 VOL: 0
;PCODE: $00000B35 VOL: 0
;       TWSR = i;
;PCODE: $00000B36 VOL: 0
;PCODE: $00000B37 VOL: 0
;       TWDR = 0xFF;
;PCODE: $00000B38 VOL: 0
;PCODE: $00000B39 VOL: 0
;       TWCR = (1<<TWEN);
;PCODE: $00000B3A VOL: 0
;PCODE: $00000B3B VOL: 0
;       return TWI_SUCCESS;
;PCODE: $00000B3C VOL: 0
;PCODE: $00000B3D VOL: 0
;PCODE: $00000B3E VOL: 0
;PCODE: $00000B3F VOL: 0
;    }
;  }
;PCODE: $00000B40 VOL: 0
;PCODE: $00000B41 VOL: 0
;PCODE: $00000B42 VOL: 0
;PCODE: $00000B43 VOL: 0
;PCODE: $00000B44 VOL: 0
;PCODE: $00000B45 VOL: 0
;  return 0;
;PCODE: $00000B46 VOL: 0
;PCODE: $00000B47 VOL: 0
;PCODE: $00000B48 VOL: 0
;PCODE: $00000B49 VOL: 0
;}
;PCODE: $00000B4A VOL: 0
;
;/****************************************************************************
; Проверка - не занят ли TWI модуль. Используется внутри модуля
;****************************************************************************/
;static uint8_t TWI_TransceiverBusy(void)
;{
;PCODE: $00000B4B VOL: 0
;PCODE: $00000B4C VOL: 0
;  return (TWCR & (1<<TWIE));
;PCODE: $00000B4D VOL: 0
;PCODE: $00000B4E VOL: 0
;PCODE: $00000B4F VOL: 0
;}
;PCODE: $00000B50 VOL: 0
;
;/****************************************************************************
; Взять статус TWI модуля
;****************************************************************************/
;uint8_t TWI_GetState(void)
;{
;PCODE: $00000B51 VOL: 0
;PCODE: $00000B52 VOL: 0
;  while (TWI_TransceiverBusy());
;PCODE: $00000B53 VOL: 0
;PCODE: $00000B54 VOL: 0
;PCODE: $00000B55 VOL: 0
;PCODE: $00000B56 VOL: 0
;PCODE: $00000B57 VOL: 0
;PCODE: $00000B58 VOL: 0
;  return twiState;
;PCODE: $00000B59 VOL: 1
;PCODE: $00000B5A VOL: 0
;}
;PCODE: $00000B5B VOL: 0
;
;/****************************************************************************
; Передать сообщение msg из msgSize байтов на TWI шину
;****************************************************************************/
;void TWI_SendData(uint8_t *msg, uint8_t msgSize)
;{
;PCODE: $00000B5C VOL: 0
;PCODE: $00000B5D VOL: 0
;  uint8_t i;
;
;  while(TWI_TransceiverBusy());   //ждем, когда TWI модуль освободится
;PCODE: $00000B5E VOL: 0
;PCODE: $00000B5F VOL: 0
;	*msg -> Y+2
;	msgSize -> Y+1
;	i -> R17
;PCODE: $00000B60 VOL: 0
;PCODE: $00000B61 VOL: 0
;PCODE: $00000B62 VOL: 0
;PCODE: $00000B63 VOL: 0
;PCODE: $00000B64 VOL: 0
;PCODE: $00000B65 VOL: 0
;
;  twiMsgSize = msgSize;           //сохряняем кол. байт для передачи
;PCODE: $00000B66 VOL: 0
;PCODE: $00000B67 VOL: 1
;  twiBuf[0]  = msg[0];            //и первый байт сообщения
;PCODE: $00000B68 VOL: 0
;PCODE: $00000B69 VOL: 0
;PCODE: $00000B6A VOL: 1
;
;  if (!(msg[0] & (TRUE<<TWI_READ_BIT))){   //если первый байт типа SLA+W
;PCODE: $00000B6B VOL: 0
;PCODE: $00000B6C VOL: 0
;PCODE: $00000B6D VOL: 0
;PCODE: $00000B6E VOL: 0
;    for (i = 1; i < msgSize; i++){         //то сохряняем остальную часть сообщения
;PCODE: $00000B6F VOL: 0
;PCODE: $00000B70 VOL: 0
;PCODE: $00000B71 VOL: 0
;PCODE: $00000B72 VOL: 0
;PCODE: $00000B73 VOL: 0
;PCODE: $00000B74 VOL: 0
;PCODE: $00000B75 VOL: 0
;PCODE: $00000B76 VOL: 0
;PCODE: $00000B77 VOL: 0
;      twiBuf[i] = msg[i];
;PCODE: $00000B78 VOL: 0
;PCODE: $00000B79 VOL: 0
;PCODE: $00000B7A VOL: 1
;PCODE: $00000B7B VOL: 0
;PCODE: $00000B7C VOL: 0
;PCODE: $00000B7D VOL: 0
;PCODE: $00000B7E VOL: 0
;PCODE: $00000B7F VOL: 0
;PCODE: $00000B80 VOL: 0
;    }
;PCODE: $00000B81 VOL: 0
;PCODE: $00000B82 VOL: 0
;PCODE: $00000B83 VOL: 0
;PCODE: $00000B84 VOL: 0
;PCODE: $00000B85 VOL: 0
;  }
;
;  twiState = TWI_NO_STATE ;
;PCODE: $00000B86 VOL: 0
;PCODE: $00000B87 VOL: 0
;PCODE: $00000B88 VOL: 1
;  TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA); //разрешаем прерывание и формируем состояние старт
;PCODE: $00000B89 VOL: 0
;PCODE: $00000B8A VOL: 0
;}
;PCODE: $00000B8B VOL: 0
;PCODE: $00000B8C VOL: 0
;PCODE: $00000B8D VOL: 0
;PCODE: $00000B8E VOL: 0
;PCODE: $00000B8F VOL: 0
;
;/****************************************************************************
; Переписать полученные данные в буфер msg в количестве msgSize байт.
;****************************************************************************/
;uint8_t TWI_GetData(uint8_t *msg, uint8_t msgSize)
;{
;PCODE: $00000B90 VOL: 0
;PCODE: $00000B91 VOL: 0
;  uint8_t i;
;
;  while(TWI_TransceiverBusy());    //ждем, когда TWI модуль освободится
;PCODE: $00000B92 VOL: 0
;PCODE: $00000B93 VOL: 0
;	*msg -> Y+2
;	msgSize -> Y+1
;	i -> R17
;PCODE: $00000B94 VOL: 0
;PCODE: $00000B95 VOL: 0
;PCODE: $00000B96 VOL: 0
;PCODE: $00000B97 VOL: 0
;PCODE: $00000B98 VOL: 0
;PCODE: $00000B99 VOL: 0
;
;  if(twiState == TWI_SUCCESS){     //если сообщение успешно принято,
;PCODE: $00000B9A VOL: 1
;PCODE: $00000B9B VOL: 0
;PCODE: $00000B9C VOL: 0
;    for(i = 0; i < msgSize; i++){  //то переписываем его из внутреннего буфера в переданный
;PCODE: $00000B9D VOL: 0
;PCODE: $00000B9E VOL: 0
;PCODE: $00000B9F VOL: 0
;PCODE: $00000BA0 VOL: 0
;PCODE: $00000BA1 VOL: 0
;PCODE: $00000BA2 VOL: 0
;PCODE: $00000BA3 VOL: 0
;PCODE: $00000BA4 VOL: 0
;PCODE: $00000BA5 VOL: 0
;      msg[i] = twiBuf[i];
;PCODE: $00000BA6 VOL: 0
;PCODE: $00000BA7 VOL: 0
;PCODE: $00000BA8 VOL: 0
;PCODE: $00000BA9 VOL: 0
;PCODE: $00000BAA VOL: 1
;PCODE: $00000BAB VOL: 0
;PCODE: $00000BAC VOL: 0
;    }
;PCODE: $00000BAD VOL: 0
;PCODE: $00000BAE VOL: 0
;PCODE: $00000BAF VOL: 0
;PCODE: $00000BB0 VOL: 0
;PCODE: $00000BB1 VOL: 0
;  }
;
;  return twiState;
;PCODE: $00000BB2 VOL: 0
;PCODE: $00000BB3 VOL: 1
;PCODE: $00000BB4 VOL: 0
;PCODE: $00000BB5 VOL: 0
;PCODE: $00000BB6 VOL: 0
;PCODE: $00000BB7 VOL: 0
;}
;PCODE: $00000BB8 VOL: 0
;
;/****************************************************************************
; Обработчик прерывания TWI модуля
;****************************************************************************/
;interrupt [TWI] void TWI_Isr(void)
;{
;PCODE: $00000BB9 VOL: 0
;PCODE: $00000BBA VOL: 0
;  static uint8_t ptr;
;  uint8_t stat = TWSR & TWSR_MASK;
;
;  switch (stat){
;PCODE: $00000BBB VOL: 0
;	stat -> R17
;PCODE: $00000BBC VOL: 0
;PCODE: $00000BBD VOL: 0
;PCODE: $00000BBE VOL: 0
;PCODE: $00000BBF VOL: 0
;PCODE: $00000BC0 VOL: 0
;
;    case TWI_START:                   // состояние START сформировано
;PCODE: $00000BC1 VOL: 0
;PCODE: $00000BC2 VOL: 0
;    case TWI_REP_START:               // состояние повторный START сформировано
;PCODE: $00000BC3 VOL: 0
;PCODE: $00000BC4 VOL: 0
;PCODE: $00000BC5 VOL: 0
;PCODE: $00000BC6 VOL: 0
;PCODE: $00000BC7 VOL: 0
;       ptr = 0;
;PCODE: $00000BC8 VOL: 0
;PCODE: $00000BC9 VOL: 0
;
;    case TWI_MTX_ADR_ACK:             // был передан пакет SLA+W и получено подтверждение
;PCODE: $00000BCA VOL: 0
;PCODE: $00000BCB VOL: 0
;PCODE: $00000BCC VOL: 0
;PCODE: $00000BCD VOL: 0
;PCODE: $00000BCE VOL: 0
;    case TWI_MTX_DATA_ACK:            // был передан байт данных и получено подтверждение
;PCODE: $00000BCF VOL: 0
;PCODE: $00000BD0 VOL: 0
;PCODE: $00000BD1 VOL: 0
;PCODE: $00000BD2 VOL: 0
;PCODE: $00000BD3 VOL: 0
;       if (ptr < twiMsgSize){
;PCODE: $00000BD4 VOL: 1
;PCODE: $00000BD5 VOL: 0
;PCODE: $00000BD6 VOL: 0
;PCODE: $00000BD7 VOL: 0
;          TWDR = twiBuf[ptr];                    //загружаем в регистр данных следующий байт
;PCODE: $00000BD8 VOL: 0
;PCODE: $00000BD9 VOL: 0
;PCODE: $00000BDA VOL: 1
;PCODE: $00000BDB VOL: 0
;PCODE: $00000BDC VOL: 0
;          TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT); //сбрасываем флаг TWINT
;PCODE: $00000BDD VOL: 0
;PCODE: $00000BDE VOL: 0
;          ptr++;
;PCODE: $00000BDF VOL: 0
;PCODE: $00000BE0 VOL: 0
;PCODE: $00000BE1 VOL: 0
;       }
;       else{
;PCODE: $00000BE2 VOL: 0
;PCODE: $00000BE3 VOL: 0
;          twiState = TWI_SUCCESS;
;PCODE: $00000BE4 VOL: 0
;PCODE: $00000BE5 VOL: 1
;          TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWSTO)|(0<<TWIE); //формируем состояние СТОП, сбрасываем флаг, запрещаем преры ...
;PCODE: $00000BE6 VOL: 0
;PCODE: $00000BE7 VOL: 0
;       }
;PCODE: $00000BE8 VOL: 0
;       break;
;PCODE: $00000BE9 VOL: 0
;
;    case TWI_MRX_DATA_ACK:          //байт данных принят и передано подтверждение
;PCODE: $00000BEA VOL: 0
;PCODE: $00000BEB VOL: 0
;PCODE: $00000BEC VOL: 0
;       twiBuf[ptr] = TWDR;
;PCODE: $00000BED VOL: 0
;PCODE: $00000BEE VOL: 0
;PCODE: $00000BEF VOL: 1
;PCODE: $00000BF0 VOL: 0
;PCODE: $00000BF1 VOL: 0
;       ptr++;
;PCODE: $00000BF2 VOL: 0
;PCODE: $00000BF3 VOL: 0
;PCODE: $00000BF4 VOL: 0
;
;    case TWI_MRX_ADR_ACK:           //был передан пакет SLA+R и получено подтвеждение
;PCODE: $00000BF5 VOL: 0
;PCODE: $00000BF6 VOL: 0
;PCODE: $00000BF7 VOL: 0
;PCODE: $00000BF8 VOL: 0
;PCODE: $00000BF9 VOL: 0
;      if (ptr < (twiMsgSize-1)){
;PCODE: $00000BFA VOL: 1
;PCODE: $00000BFB VOL: 0
;PCODE: $00000BFC VOL: 0
;PCODE: $00000BFD VOL: 0
;PCODE: $00000BFE VOL: 0
;PCODE: $00000BFF VOL: 0
;PCODE: $00000C00 VOL: 0
;        TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);  //если это не предпоследний принятый байт, формируем подтвержд ...
;PCODE: $00000C01 VOL: 0
;PCODE: $00000C02 VOL: 0
;      }
;      else {
;PCODE: $00000C03 VOL: 0
;PCODE: $00000C04 VOL: 0
;        TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT);            //если приняли предпоследний байт, подтверждение не формируем
;PCODE: $00000C05 VOL: 0
;PCODE: $00000C06 VOL: 0
;      }
;PCODE: $00000C07 VOL: 0
;      break;
;PCODE: $00000C08 VOL: 0
;
;    case TWI_MRX_DATA_NACK:       //был принят байт данных без подтверждения
;PCODE: $00000C09 VOL: 0
;PCODE: $00000C0A VOL: 0
;PCODE: $00000C0B VOL: 0
;      twiBuf[ptr] = TWDR;
;PCODE: $00000C0C VOL: 0
;PCODE: $00000C0D VOL: 0
;PCODE: $00000C0E VOL: 1
;PCODE: $00000C0F VOL: 0
;PCODE: $00000C10 VOL: 0
;      twiState = TWI_SUCCESS;
;PCODE: $00000C11 VOL: 0
;PCODE: $00000C12 VOL: 1
;      TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWSTO); //формируем состояние стоп
;PCODE: $00000C13 VOL: 0
;PCODE: $00000C14 VOL: 0
;      break;
;PCODE: $00000C15 VOL: 0
;
;    case TWI_ARB_LOST:          //был потерян приоритет
;PCODE: $00000C16 VOL: 0
;PCODE: $00000C17 VOL: 0
;PCODE: $00000C18 VOL: 0
;      TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA); // сбрасываем флаг TWINT, формируем повторный СТАРТ
;PCODE: $00000C19 VOL: 0
;PCODE: $00000C1A VOL: 0
;      break;
;PCODE: $00000C1B VOL: 0
;
;    case TWI_MTX_ADR_NACK:      // был передан пает SLA+W и не получено подтверждение
;PCODE: $00000C1C VOL: 0
;PCODE: $00000C1D VOL: 0
;PCODE: $00000C1E VOL: 0
;    case TWI_MRX_ADR_NACK:      // был передан пакет SLA+R и не получено подтверждение
;PCODE: $00000C1F VOL: 0
;PCODE: $00000C20 VOL: 0
;PCODE: $00000C21 VOL: 0
;PCODE: $00000C22 VOL: 0
;PCODE: $00000C23 VOL: 0
;    case TWI_MTX_DATA_NACK:     // был передан байт данных и не получено подтверждение
;PCODE: $00000C24 VOL: 0
;PCODE: $00000C25 VOL: 0
;PCODE: $00000C26 VOL: 0
;PCODE: $00000C27 VOL: 0
;PCODE: $00000C28 VOL: 0
;    case TWI_BUS_ERROR:         // ошибка на шине из-за некоректных состояний СТАРТ или СТОП
;PCODE: $00000C29 VOL: 0
;PCODE: $00000C2A VOL: 0
;PCODE: $00000C2B VOL: 0
;PCODE: $00000C2C VOL: 0
;PCODE: $00000C2D VOL: 0
;    default:
;PCODE: $00000C2E VOL: 0
;      twiState = stat;
;PCODE: $00000C2F VOL: 1
;PCODE: $00000C30 VOL: 0
;      TWCR = (1<<TWEN)|(0<<TWIE)|(0<<TWINT)|(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC); //запретить прерывание
;PCODE: $00000C31 VOL: 0
;PCODE: $00000C32 VOL: 0
;  }
;PCODE: $00000C33 VOL: 0
;}
;PCODE: $00000C34 VOL: 0
;PCODE: $00000C35 VOL: 0
;PCODE: $00000C36 VOL: 0
;PCODE: $00000C37 VOL: 0
;#include "FatFS/ff.c"
;/*----------------------------------------------------------------------------/
;/  FatFs - FAT file system module  R0.10                 (C)ChaN, 2013
;/-----------------------------------------------------------------------------/
;/ FatFs module is a generic FAT file system module for small embedded systems.
;/ This is a free software that opened for education, research and commercial
;/ developments under license policy of following terms.
;/
;/  Copyright (C) 2013, ChaN, all right reserved.
;/
;/ * The FatFs module is a free software and there is NO WARRANTY.
;/ * No restriction on use. You can use, modify and redistribute it for
;/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
;/ * Redistributions of source code must retain the above copyright notice.
;/
;/-----------------------------------------------------------------------------/
;/ Feb 26,'06 R0.00  Prototype.
;/
;/ Apr 29,'06 R0.01  First stable version.
;/
;/ Jun 01,'06 R0.02  Added FAT12 support.
;/                   Removed unbuffered mode.
;/                   Fixed a problem on small (<32M) partition.
;/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
;/
;/ Sep 22,'06 R0.03  Added f_rename().
;/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
;/ Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
;/                   Fixed f_mkdir() creates incorrect directory on FAT32.
;/
;/ Feb 04,'07 R0.04  Supported multiple drive system.
;/                   Changed some interfaces for multiple drive system.
;/                   Changed f_mountdrv() to f_mount().
;/                   Added f_mkfs().
;/ Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
;/                   Added a capability of extending file size to f_lseek().
;/                   Added minimization level 3.
;/                   Fixed an endian sensitive code in f_mkfs().
;/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
;/                   Added FSINFO support.
;/                   Fixed DBCS name can result FR_INVALID_NAME.
;/                   Fixed short seek (<= csize) collapses the file object.
;/
;/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
;/                   Fixed f_mkfs() on FAT32 creates incorrect FSINFO.
;/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
;/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
;/                   Fixed off by one error at FAT sub-type determination.
;/                   Fixed btr in f_read() can be mistruncated.
;/                   Fixed cached sector is not flushed when create and close without write.
;/
;/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
;/                   Improved performance of f_lseek() on moving to the same or following cluster.
;/
;/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
;/                   Added long file name feature.
;/                   Added multiple code page feature.
;/                   Added re-entrancy for multitask operation.
;/                   Added auto cluster size selection to f_mkfs().
;/                   Added rewind option to f_readdir().
;/                   Changed result code of critical errors.
;/                   Renamed string functions to avoid name collision.
;/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
;/                   Added multiple sector size feature.
;/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
;/                   Fixed wrong cache control in f_lseek().
;/                   Added relative path feature.
;/                   Added f_chdir() and f_chdrive().
;/                   Added proper case conversion to extended character.
;/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
;/                   Fixed f_unlink() fails to remove a sub-directory on _FS_RPATH.
;/                   Fixed name matching error on the 13 character boundary.
;/                   Added a configuration option, _LFN_UNICODE.
;/                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
;/
;/ May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
;/                   Added file lock feature. (_FS_SHARE)
;/                   Added fast seek feature. (_USE_FASTSEEK)
;/                   Changed some types on the API, XCHAR->TCHAR.
;/                   Changed .fname in the FILINFO structure on Unicode cfg.
;/                   String functions support UTF-8 encoding files on Unicode cfg.
;/ Aug 16,'10 R0.08a Added f_getcwd().
;/                   Added sector erase feature. (_USE_ERASE)
;/                   Moved file lock semaphore table from fs object to the bss.
;/                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
;/                   Fixed f_mkfs() creates wrong FAT32 volume.
;/ Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
;/                   f_lseek() reports required table size on creating CLMP.
;/                   Extended format syntax of f_printf().
;/                   Ignores duplicated directory separators in given path name.
;/
;/ Sep 06,'11 R0.09  f_mkfs() supports multiple partition to complete the multiple partition feature.
;/                   Added f_fdisk().
;/ Aug 27,'12 R0.09a Changed f_open() and f_opendir() reject null object pointer to avoid crash.
;/                   Changed option name _FS_SHARE to _FS_LOCK.
;/                   Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
;/ Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel().
;/
;/ Oct 02,'13 R0.10  Added selection of character encoding on the file. (_STRF_ENCODE)
;/                   Added f_closedir().
;/                   Added forced full FAT scan for f_getfree(). (_FS_NOFSINFO)
;/                   Added forced mount feature with changes of f_mount().
;/                   Improved behavior of volume auto detection.
;/                   Improved write throughput of f_puts() and f_printf().
;/                   Changed argument of f_chdrive(), f_mkfs(), disk_read() and disk_write().
;/                   Fixed f_write() can be truncated when the file size is close to 4GB.
;/                   Fixed f_open(), f_mkdir() and f_setlabel() can return incorrect error code.
;/---------------------------------------------------------------------------*/
;
;#include "ff.h"			/* Declarations of FatFs API */
;#include "diskio.h"		/* Declarations of disk I/O functions */
;#include "option/unicode.c"
;#include "../ff.h"
;
;#if _USE_LFN != 0
;
;#if   _CODE_PAGE == 932
;#include "cc932.c"
;#elif _CODE_PAGE == 936
;#include "cc936.c"
;#elif _CODE_PAGE == 949
;#include "cc949.c"
;#elif _CODE_PAGE == 950
;#include "cc950.c"
;#else
;#include "ccsbcs.c"
;#endif
;
;#endif
;
;
;/*--------------------------------------------------------------------------
;
;   Module Private Definitions
;
;---------------------------------------------------------------------------*/
;
;#if _FATFS != 80960	/* Revision ID */
;#error Wrong include file (ff.h).
;#endif
;
;
;/* Definitions on sector size */
;#if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
;#error Wrong sector size.
;#endif
;#if _MAX_SS != 512
;#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
;#else
;#define	SS(fs)	512U			/* Fixed sector size */
;#endif
;
;
;/* Reentrancy related */
;#if _FS_REENTRANT
;#if _USE_LFN == 1
;#error Static LFN work area cannot be used at thread-safe configuration.
;#endif
;#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
;#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
;#else
;#define	ENTER_FF(fs)
;#define LEAVE_FF(fs, res)	return res
;#endif
;
;#define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
;
;
;/* File access control feature */
;#if _FS_LOCK
;#if _FS_READONLY
;#error _FS_LOCK must be 0 at read-only cfg.
;#endif
;typedef struct {
;	FATFS *fs;				/* Object ID 1, volume (NULL:blank entry) */
;	DWORD clu;				/* Object ID 2, directory */
;	WORD idx;				/* Object ID 3, directory index */
;	WORD ctr;				/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
;} FILESEM;
;#endif
;
;
;
;/* DBCS code ranges and SBCS extend character conversion table */
;
;#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
;#define _DF1S	0x81	/* DBC 1st byte range 1 start */
;#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
;#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
;#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
;#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
;#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
;#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
;#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
;
;#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
;#define _DF1S	0x81
;#define _DF1E	0xFE
;#define _DS1S	0x40
;#define _DS1E	0x7E
;#define _DS2S	0x80
;#define _DS2E	0xFE
;
;#elif _CODE_PAGE == 949	/* Korean */
;#define _DF1S	0x81
;#define _DF1E	0xFE
;#define _DS1S	0x41
;#define _DS1E	0x5A
;#define _DS2S	0x61
;#define _DS2E	0x7A
;#define _DS3S	0x81
;#define _DS3E	0xFE
;
;#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
;#define _DF1S	0x81
;#define _DF1E	0xFE
;#define _DS1S	0x40
;#define _DS1E	0x7E
;#define _DS2S	0xA1
;#define _DS2E	0xFE
;
;#elif _CODE_PAGE == 437	/* U.S. (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99 ...
;				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 720	/* Arabic (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 737	/* Greek (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94 ...
;				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 775	/* Baltic (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99 ...
;				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99 ...
;				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99 ...
;				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95 ...
;				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0 ...
;				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0 ...
;
;#elif _CODE_PAGE == 857	/* Turkish (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99 ...
;				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99 ...
;				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 866	/* Russian (OEM) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0 ...
;
;#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1253 /* Greek (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0 ...
;
;#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
;#define _DF1S	0
;#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94 ...
;				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0 ...
;				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0 ...
;
;#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
;#if _USE_LFN
;#error Cannot use LFN feature without valid code page.
;#endif
;#define _DF1S	0
;
;#else
;#error Unknown code page
;
;#endif
;
;
;/* Character code support macros */
;#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
;#define IsLower(c)	(((c)>='a')&&((c)<='z'))
;#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
;
;#if _DF1S		/* Code page is DBCS */
;
;#ifdef _DF2S	/* Two 1st byte areas */
;#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
;#else			/* One 1st byte area */
;#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
;#endif
;
;#ifdef _DS3S	/* Three 2nd byte areas */
;#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)( ...
;#else			/* Two 2nd byte areas */
;#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
;#endif
;
;#else			/* Code page is SBCS */
;
;#define IsDBCS1(c)	0
;#define IsDBCS2(c)	0
;
;#endif /* _DF1S */
;
;
;/* Name status flags */
;#define NS			11		/* Index of name status byte in fn[] */
;#define NS_LOSS		0x01	/* Out of 8.3 format */
;#define NS_LFN		0x02	/* Force to create LFN entry */
;#define NS_LAST		0x04	/* Last segment */
;#define NS_BODY		0x08	/* Lower case flag (body) */
;#define NS_EXT		0x10	/* Lower case flag (ext) */
;#define NS_DOT		0x20	/* Dot entry */
;
;
;/* FAT sub-type boundaries */
;#define MIN_FAT16	4086U	/* Minimum number of clusters for FAT16 */
;#define	MIN_FAT32	65526U	/* Minimum number of clusters for FAT32 */
;
;
;/* FatFs refers the members in the FAT structures as byte array instead of
;/ structure member because the structure is not binary compatible between
;/ different platforms */
;
;#define BS_jmpBoot			0	/* Jump instruction (3) */
;#define BS_OEMName			3	/* OEM name (8) */
;#define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
;#define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
;#define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
;#define BPB_NumFATs			16	/* Number of FAT copies (1) */
;#define BPB_RootEntCnt		17	/* Number of root directory entries for FAT12/16 (2) */
;#define BPB_TotSec16		19	/* Volume size [sector] (2) */
;#define BPB_Media			21	/* Media descriptor (1) */
;#define BPB_FATSz16			22	/* FAT size [sector] (2) */
;#define BPB_SecPerTrk		24	/* Track size [sector] (2) */
;#define BPB_NumHeads		26	/* Number of heads (2) */
;#define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
;#define BPB_TotSec32		32	/* Volume size [sector] (4) */
;#define BS_DrvNum			36	/* Physical drive number (2) */
;#define BS_BootSig			38	/* Extended boot signature (1) */
;#define BS_VolID			39	/* Volume serial number (4) */
;#define BS_VolLab			43	/* Volume label (8) */
;#define BS_FilSysType		54	/* File system type (1) */
;#define BPB_FATSz32			36	/* FAT size [sector] (4) */
;#define BPB_ExtFlags		40	/* Extended flags (2) */
;#define BPB_FSVer			42	/* File system version (2) */
;#define BPB_RootClus		44	/* Root directory first cluster (4) */
;#define BPB_FSInfo			48	/* Offset of FSINFO sector (2) */
;#define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
;#define BS_DrvNum32			64	/* Physical drive number (2) */
;#define BS_BootSig32		66	/* Extended boot signature (1) */
;#define BS_VolID32			67	/* Volume serial number (4) */
;#define BS_VolLab32			71	/* Volume label (8) */
;#define BS_FilSysType32		82	/* File system type (1) */
;#define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
;#define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
;#define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
;#define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
;#define MBR_Table			446	/* MBR: Partition table offset (2) */
;#define	SZ_PTE				16	/* MBR: Size of a partition table entry */
;#define BS_55AA				510	/* Boot sector signature (2) */
;
;#define	DIR_Name			0	/* Short file name (11) */
;#define	DIR_Attr			11	/* Attribute (1) */
;#define	DIR_NTres			12	/* NT flag (1) */
;#define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
;#define	DIR_CrtTime			14	/* Created time (2) */
;#define	DIR_CrtDate			16	/* Created date (2) */
;#define DIR_LstAccDate		18	/* Last accessed date (2) */
;#define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
;#define	DIR_WrtTime			22	/* Modified time (2) */
;#define	DIR_WrtDate			24	/* Modified date (2) */
;#define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
;#define	DIR_FileSize		28	/* File size (4) */
;#define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
;#define	LDIR_Attr			11	/* LFN attribute (1) */
;#define	LDIR_Type			12	/* LFN type (1) */
;#define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
;#define	LDIR_FstClusLO		26	/* Filled by zero (0) */
;#define	SZ_DIR				32		/* Size of a directory entry */
;#define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
;#define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
;#define	NDDE				0x05	/* Replacement of the character collides with DDE */
;
;
;/*------------------------------------------------------------*/
;/* Module private work area                                   */
;/*------------------------------------------------------------*/
;/* Note that uninitialized variables with static duration are
;/  zeroed/nulled at start-up. If not, the compiler or start-up
;/  routine is out of ANSI-C standard.
;*/
;
;#if _VOLUMES
;static
;FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
;#else
;#error Number of volumes must not be 0.
;#endif
;
;static
;WORD Fsid;				/* File system mount ID */
;
;#if _FS_RPATH && _VOLUMES >= 2
;static
;BYTE CurrVol;			/* Current drive */
;#endif
;
;#if _FS_LOCK
;static
;FILESEM	Files[_FS_LOCK];	/* Open object lock semaphores */
;#endif
;
;#if _USE_LFN == 0			/* No LFN feature */
;#define	DEF_NAMEBUF			BYTE sfn[12]
;#define INIT_BUF(dobj)		(dobj).fn = sfn
;#define	FREE_BUF()
;
;#elif _USE_LFN == 1			/* LFN feature with static working buffer */
;static
;WCHAR LfnBuf[_MAX_LFN+1];
;#define	DEF_NAMEBUF			BYTE sfn[12]
;#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
;#define	FREE_BUF()
;
;#elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
;#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
;#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
;#define	FREE_BUF()
;
;#elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
;#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
;#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
;							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
;							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
;#define	FREE_BUF()			ff_memfree(lfn)
;
;#else
;#error Wrong LFN configuration.
;#endif
;
;
;#ifdef _EXCVT
;static
;const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended characters */
;#endif
;
;
;
;
;
;
;/*--------------------------------------------------------------------------
;
;   Module Private Functions
;
;---------------------------------------------------------------------------*/
;
;
;/*-----------------------------------------------------------------------*/
;/* String functions                                                      */
;/*-----------------------------------------------------------------------*/
;
;/* Copy memory to memory */
;static
;void mem_cpy (void* dst, const void* src, UINT cnt) {
;PCODE: $00000C38 VOL: 0
;PCODE: $00000C39 VOL: 0
;	BYTE *d = (BYTE*)dst;
;	const BYTE *s = (const BYTE*)src;
;
;#if _WORD_ACCESS == 1
;	while (cnt >= sizeof (int)) {
;		*(int*)d = *(int*)s;
;		d += sizeof (int); s += sizeof (int);
;		cnt -= sizeof (int);
;	}
;#endif
;	while (cnt--)
;PCODE: $00000C3A VOL: 0
;PCODE: $00000C3B VOL: 0
;	*dst -> Y+8
;	*src -> Y+6
;	cnt -> Y+4
;	*d -> R16,R17
;	*s -> R18,R19
;PCODE: $00000C3C VOL: 0
;PCODE: $00000C3D VOL: 0
;PCODE: $00000C3E VOL: 0
;PCODE: $00000C3F VOL: 0
;PCODE: $00000C40 VOL: 0
;PCODE: $00000C41 VOL: 0
;PCODE: $00000C42 VOL: 0
;PCODE: $00000C43 VOL: 0
;PCODE: $00000C44 VOL: 0
;PCODE: $00000C45 VOL: 0
;		*d++ = *s++;
;PCODE: $00000C46 VOL: 0
;PCODE: $00000C47 VOL: 0
;PCODE: $00000C48 VOL: 0
;PCODE: $00000C49 VOL: 0
;PCODE: $00000C4A VOL: 0
;PCODE: $00000C4B VOL: 0
;PCODE: $00000C4C VOL: 0
;PCODE: $00000C4D VOL: 0
;PCODE: $00000C4E VOL: 0
;PCODE: $00000C4F VOL: 0
;PCODE: $00000C50 VOL: 0
;PCODE: $00000C51 VOL: 0
;PCODE: $00000C52 VOL: 0
;PCODE: $00000C53 VOL: 0
;PCODE: $00000C54 VOL: 0
;
;/* Fill memory */
;static
;void mem_set (void* dst, int val, UINT cnt) {
;PCODE: $00000C55 VOL: 0
;PCODE: $00000C56 VOL: 0
;	BYTE *d = (BYTE*)dst;
;
;	while (cnt--)
;PCODE: $00000C57 VOL: 0
;PCODE: $00000C58 VOL: 0
;PCODE: $00000C59 VOL: 0
;	*dst -> Y+6
;	val -> Y+4
;	cnt -> Y+2
;	*d -> R16,R17
;PCODE: $00000C5A VOL: 0
;PCODE: $00000C5B VOL: 0
;PCODE: $00000C5C VOL: 0
;PCODE: $00000C5D VOL: 0
;PCODE: $00000C5E VOL: 0
;PCODE: $00000C5F VOL: 0
;PCODE: $00000C60 VOL: 0
;PCODE: $00000C61 VOL: 0
;		*d++ = (BYTE)val;
;PCODE: $00000C62 VOL: 0
;PCODE: $00000C63 VOL: 0
;PCODE: $00000C64 VOL: 0
;PCODE: $00000C65 VOL: 0
;PCODE: $00000C66 VOL: 0
;PCODE: $00000C67 VOL: 0
;PCODE: $00000C68 VOL: 0
;PCODE: $00000C69 VOL: 0
;PCODE: $00000C6A VOL: 0
;PCODE: $00000C6B VOL: 0
;PCODE: $00000C6C VOL: 0
;PCODE: $00000C6D VOL: 0
;PCODE: $00000C6E VOL: 0
;PCODE: $00000C6F VOL: 0
;PCODE: $00000C70 VOL: 0
;
;/* Compare memory to memory */
;static
;int mem_cmp (const void* dst, const void* src, UINT cnt) {
;PCODE: $00000C71 VOL: 0
;PCODE: $00000C72 VOL: 0
;	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
;	int r = 0;
;
;	while (cnt-- && (r = *d++ - *s++) == 0) ;
;PCODE: $00000C73 VOL: 0
;PCODE: $00000C74 VOL: 0
;	*dst -> Y+10
;	*src -> Y+8
;	cnt -> Y+6
;	*d -> R16,R17
;	*s -> R18,R19
;	r -> R20,R21
;PCODE: $00000C75 VOL: 0
;PCODE: $00000C76 VOL: 0
;PCODE: $00000C77 VOL: 0
;PCODE: $00000C78 VOL: 0
;PCODE: $00000C79 VOL: 0
;PCODE: $00000C7A VOL: 0
;PCODE: $00000C7B VOL: 0
;PCODE: $00000C7C VOL: 0
;PCODE: $00000C7D VOL: 0
;PCODE: $00000C7E VOL: 0
;PCODE: $00000C7F VOL: 0
;PCODE: $00000C80 VOL: 0
;PCODE: $00000C81 VOL: 0
;PCODE: $00000C82 VOL: 0
;PCODE: $00000C83 VOL: 0
;PCODE: $00000C84 VOL: 0
;PCODE: $00000C85 VOL: 0
;PCODE: $00000C86 VOL: 0
;PCODE: $00000C87 VOL: 0
;PCODE: $00000C88 VOL: 0
;PCODE: $00000C89 VOL: 0
;PCODE: $00000C8A VOL: 0
;PCODE: $00000C8B VOL: 0
;PCODE: $00000C8C VOL: 0
;PCODE: $00000C8D VOL: 0
;PCODE: $00000C8E VOL: 0
;PCODE: $00000C8F VOL: 0
;PCODE: $00000C90 VOL: 0
;PCODE: $00000C91 VOL: 0
;PCODE: $00000C92 VOL: 0
;PCODE: $00000C93 VOL: 0
;PCODE: $00000C94 VOL: 0
;PCODE: $00000C95 VOL: 0
;	return r;
;PCODE: $00000C96 VOL: 0
;PCODE: $00000C97 VOL: 0
;PCODE: $00000C98 VOL: 0
;PCODE: $00000C99 VOL: 0
;}
;PCODE: $00000C9A VOL: 0
;
;/* Check if chr is contained in the string */
;static
;int chk_chr (const char* str, int chr) {
;PCODE: $00000C9B VOL: 0
;PCODE: $00000C9C VOL: 0
;	while (*str && *str != chr) str++;
;PCODE: $00000C9D VOL: 0
;	*str -> Y+2
;	chr -> Y+0
;PCODE: $00000C9E VOL: 0
;PCODE: $00000C9F VOL: 0
;PCODE: $00000CA0 VOL: 0
;PCODE: $00000CA1 VOL: 0
;PCODE: $00000CA2 VOL: 0
;PCODE: $00000CA3 VOL: 0
;PCODE: $00000CA4 VOL: 0
;PCODE: $00000CA5 VOL: 0
;PCODE: $00000CA6 VOL: 0
;PCODE: $00000CA7 VOL: 0
;PCODE: $00000CA8 VOL: 0
;PCODE: $00000CA9 VOL: 0
;PCODE: $00000CAA VOL: 0
;PCODE: $00000CAB VOL: 0
;PCODE: $00000CAC VOL: 0
;PCODE: $00000CAD VOL: 0
;PCODE: $00000CAE VOL: 0
;PCODE: $00000CAF VOL: 0
;PCODE: $00000CB0 VOL: 0
;PCODE: $00000CB1 VOL: 0
;PCODE: $00000CB2 VOL: 0
;PCODE: $00000CB3 VOL: 0
;PCODE: $00000CB4 VOL: 0
;PCODE: $00000CB5 VOL: 0
;PCODE: $00000CB6 VOL: 0
;}
;PCODE: $00000CB7 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Request/Release grant to access the volume                            */
;/*-----------------------------------------------------------------------*/
;#if _FS_REENTRANT
;static
;int lock_fs (
;	FATFS* fs		/* File system object */
;)
;{
;	return ff_req_grant(fs->sobj);
;}
;
;
;static
;void unlock_fs (
;	FATFS* fs,		/* File system object */
;	FRESULT res		/* Result code to be returned */
;)
;{
;	if (fs &&
;		res != FR_NOT_ENABLED &&
;		res != FR_INVALID_DRIVE &&
;		res != FR_INVALID_OBJECT &&
;		res != FR_TIMEOUT) {
;		ff_rel_grant(fs->sobj);
;	}
;}
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* File lock control functions                                           */
;/*-----------------------------------------------------------------------*/
;#if _FS_LOCK
;
;static
;FRESULT chk_lock (	/* Check if the file can be accessed */
;	DIR* dp,		/* Directory object pointing the file to be checked */
;	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;)
;{
;	UINT i, be;
;
;	/* Search file semaphore table */
;	for (i = be = 0; i < _FS_LOCK; i++) {
;		if (Files[i].fs) {	/* Existing entry */
;			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
;				Files[i].clu == dp->sclust &&
;				Files[i].idx == dp->index) break;
;		} else {			/* Blank entry */
;			be = 1;
;		}
;	}
;	if (i == _FS_LOCK)	/* The object is not opened */
;		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
;
;	/* The object has been opened. Reject any open against writing file and all write mode open */
;	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
;}
;
;
;static
;int enq_lock (void)	/* Check if an entry is available for a new object */
;{
;	UINT i;
;
;	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
;	return (i == _FS_LOCK) ? 0 : 1;
;}
;
;
;static
;UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
;	DIR* dp,	/* Directory object pointing the file to register or increment */
;	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;)
;{
;	UINT i;
;
;
;	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
;		if (Files[i].fs == dp->fs &&
;			Files[i].clu == dp->sclust &&
;			Files[i].idx == dp->index) break;
;	}
;
;	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
;		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
;		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
;		Files[i].fs = dp->fs;
;		Files[i].clu = dp->sclust;
;		Files[i].idx = dp->index;
;		Files[i].ctr = 0;
;	}
;
;	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
;
;	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;
;	return i + 1;
;}
;
;
;static
;FRESULT dec_lock (	/* Decrement object open counter */
;	UINT i			/* Semaphore index (1..) */
;)
;{
;	WORD n;
;	FRESULT res;
;
;
;	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
;		n = Files[i].ctr;
;		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
;		if (n) n--;					/* Decrement read mode open count */
;		Files[i].ctr = n;
;		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
;		res = FR_OK;
;	} else {
;		res = FR_INT_ERR;			/* Invalid index nunber */
;	}
;	return res;
;}
;
;
;static
;void clear_lock (	/* Clear lock entries of the volume */
;	FATFS *fs
;)
;{
;	UINT i;
;
;	for (i = 0; i < _FS_LOCK; i++) {
;		if (Files[i].fs == fs) Files[i].fs = 0;
;	}
;}
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Move/Flush disk access window in the file system object               */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;static
;FRESULT sync_window (
;	FATFS* fs		/* File system object */
;)
;{
;PCODE: $00000CB8 VOL: 0
;PCODE: $00000CB9 VOL: 0
;	DWORD wsect;
;	UINT nf;
;
;
;	if (fs->wflag) {	/* Write back the sector if it is dirty */
;PCODE: $00000CBA VOL: 0
;PCODE: $00000CBB VOL: 0
;PCODE: $00000CBC VOL: 0
;PCODE: $00000CBD VOL: 0
;	*fs -> Y+6
;	wsect -> Y+2
;	nf -> R16,R17
;PCODE: $00000CBE VOL: 0
;PCODE: $00000CBF VOL: 0
;PCODE: $00000CC0 VOL: 0
;PCODE: $00000CC1 VOL: 0
;		wsect = fs->winsect;	/* Current sector number */
;PCODE: $00000CC2 VOL: 0
;PCODE: $00000CC3 VOL: 0
;PCODE: $00000CC4 VOL: 0
;PCODE: $00000CC5 VOL: 0
;		if (disk_write(fs->drv, fs->win, wsect, 1))
;PCODE: $00000CC6 VOL: 0
;PCODE: $00000CC7 VOL: 0
;PCODE: $00000CC8 VOL: 0
;PCODE: $00000CC9 VOL: 0
;PCODE: $00000CCA VOL: 0
;PCODE: $00000CCB VOL: 0
;PCODE: $00000CCC VOL: 0
;PCODE: $00000CCD VOL: 0
;PCODE: $00000CCE VOL: 0
;PCODE: $00000CCF VOL: 0
;PCODE: $00000CD0 VOL: 0
;PCODE: $00000CD1 VOL: 0
;PCODE: $00000CD2 VOL: 0
;			return FR_DISK_ERR;
;PCODE: $00000CD3 VOL: 0
;PCODE: $00000CD4 VOL: 0
;PCODE: $00000CD5 VOL: 0
;PCODE: $00000CD6 VOL: 0
;PCODE: $00000CD7 VOL: 0
;PCODE: $00000CD8 VOL: 0
;PCODE: $00000CD9 VOL: 0
;		fs->wflag = 0;
;PCODE: $00000CDA VOL: 0
;PCODE: $00000CDB VOL: 0
;PCODE: $00000CDC VOL: 0
;PCODE: $00000CDD VOL: 0
;PCODE: $00000CDE VOL: 0
;		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
;PCODE: $00000CDF VOL: 0
;PCODE: $00000CE0 VOL: 0
;PCODE: $00000CE1 VOL: 0
;PCODE: $00000CE2 VOL: 0
;PCODE: $00000CE3 VOL: 0
;PCODE: $00000CE4 VOL: 0
;PCODE: $00000CE5 VOL: 0
;PCODE: $00000CE6 VOL: 0
;PCODE: $00000CE7 VOL: 0
;PCODE: $00000CE8 VOL: 0
;PCODE: $00000CE9 VOL: 0
;PCODE: $00000CEA VOL: 0
;PCODE: $00000CEB VOL: 0
;			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
;PCODE: $00000CEC VOL: 0
;PCODE: $00000CED VOL: 0
;PCODE: $00000CEE VOL: 0
;PCODE: $00000CEF VOL: 0
;PCODE: $00000CF0 VOL: 0
;PCODE: $00000CF1 VOL: 0
;PCODE: $00000CF2 VOL: 0
;PCODE: $00000CF3 VOL: 0
;PCODE: $00000CF4 VOL: 0
;PCODE: $00000CF5 VOL: 0
;PCODE: $00000CF6 VOL: 0
;				wsect += fs->fsize;
;PCODE: $00000CF7 VOL: 0
;PCODE: $00000CF8 VOL: 0
;PCODE: $00000CF9 VOL: 0
;PCODE: $00000CFA VOL: 0
;PCODE: $00000CFB VOL: 0
;PCODE: $00000CFC VOL: 0
;				disk_write(fs->drv, fs->win, wsect, 1);
;PCODE: $00000CFD VOL: 0
;PCODE: $00000CFE VOL: 0
;PCODE: $00000CFF VOL: 0
;PCODE: $00000D00 VOL: 0
;PCODE: $00000D01 VOL: 0
;PCODE: $00000D02 VOL: 0
;PCODE: $00000D03 VOL: 0
;PCODE: $00000D04 VOL: 0
;PCODE: $00000D05 VOL: 0
;PCODE: $00000D06 VOL: 0
;PCODE: $00000D07 VOL: 0
;			}
;PCODE: $00000D08 VOL: 0
;PCODE: $00000D09 VOL: 0
;PCODE: $00000D0A VOL: 0
;PCODE: $00000D0B VOL: 0
;PCODE: $00000D0C VOL: 0
;		}
;	}
;PCODE: $00000D0D VOL: 0
;	return FR_OK;
;PCODE: $00000D0E VOL: 0
;PCODE: $00000D0F VOL: 0
;PCODE: $00000D10 VOL: 0
;PCODE: $00000D11 VOL: 0
;PCODE: $00000D12 VOL: 0
;PCODE: $00000D13 VOL: 0
;PCODE: $00000D14 VOL: 0
;PCODE: $00000D15 VOL: 0
;}
;PCODE: $00000D16 VOL: 0
;#endif
;
;
;static
;FRESULT move_window (
;	FATFS* fs,		/* File system object */
;	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;)
;{
;PCODE: $00000D17 VOL: 0
;PCODE: $00000D18 VOL: 0
;	if (sector != fs->winsect)
;PCODE: $00000D19 VOL: 0
;	*fs -> Y+4
;	sector -> Y+0
;PCODE: $00000D1A VOL: 0
;PCODE: $00000D1B VOL: 0
;PCODE: $00000D1C VOL: 0
;PCODE: $00000D1D VOL: 0
;PCODE: $00000D1E VOL: 0
;PCODE: $00000D1F VOL: 0
;    {	/* Changed current window */
;#if !_FS_READONLY
;		if (sync_window(fs) != FR_OK)
;PCODE: $00000D20 VOL: 0
;PCODE: $00000D21 VOL: 0
;PCODE: $00000D22 VOL: 0
;PCODE: $00000D23 VOL: 0
;			return FR_DISK_ERR;
;PCODE: $00000D24 VOL: 0
;PCODE: $00000D25 VOL: 0
;PCODE: $00000D26 VOL: 0
;#endif
;		if (disk_read(fs->drv, fs->win, sector, 1))
;PCODE: $00000D27 VOL: 0
;PCODE: $00000D28 VOL: 0
;PCODE: $00000D29 VOL: 0
;PCODE: $00000D2A VOL: 0
;PCODE: $00000D2B VOL: 0
;PCODE: $00000D2C VOL: 0
;PCODE: $00000D2D VOL: 0
;PCODE: $00000D2E VOL: 0
;PCODE: $00000D2F VOL: 0
;PCODE: $00000D30 VOL: 0
;PCODE: $00000D31 VOL: 0
;PCODE: $00000D32 VOL: 0
;PCODE: $00000D33 VOL: 0
;PCODE: $00000D34 VOL: 0
;        {
;            // PORTD.0 = 1;
;			return FR_DISK_ERR;
;PCODE: $00000D35 VOL: 0
;PCODE: $00000D36 VOL: 0
;PCODE: $00000D37 VOL: 0
;        }
;		fs->winsect = sector;
;PCODE: $00000D38 VOL: 0
;PCODE: $00000D39 VOL: 0
;PCODE: $00000D3A VOL: 0
;PCODE: $00000D3B VOL: 0
;	}
;
;	return FR_OK;
;PCODE: $00000D3C VOL: 0
;PCODE: $00000D3D VOL: 0
;PCODE: $00000D3E VOL: 0
;PCODE: $00000D3F VOL: 0
;}
;PCODE: $00000D40 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Synchronize file system and strage device                             */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;static
;FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
;	FATFS* fs		/* File system object */
;)
;{
;PCODE: $00000D41 VOL: 0
;PCODE: $00000D42 VOL: 0
;	FRESULT res;
;
;
;	res = sync_window(fs);
;PCODE: $00000D43 VOL: 0
;PCODE: $00000D44 VOL: 0
;	*fs -> Y+1
;	res -> R17
;PCODE: $00000D45 VOL: 0
;PCODE: $00000D46 VOL: 0
;PCODE: $00000D47 VOL: 0
;	if (res == FR_OK) {
;PCODE: $00000D48 VOL: 0
;PCODE: $00000D49 VOL: 0
;		/* Update FSINFO sector if needed */
;		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
;PCODE: $00000D4A VOL: 0
;PCODE: $00000D4B VOL: 0
;PCODE: $00000D4C VOL: 0
;PCODE: $00000D4D VOL: 0
;PCODE: $00000D4E VOL: 0
;PCODE: $00000D4F VOL: 0
;PCODE: $00000D50 VOL: 0
;PCODE: $00000D51 VOL: 0
;PCODE: $00000D52 VOL: 0
;PCODE: $00000D53 VOL: 0
;PCODE: $00000D54 VOL: 0
;PCODE: $00000D55 VOL: 0
;			/* Create FSINFO structure */
;			mem_set(fs->win, 0, SS(fs));
;PCODE: $00000D56 VOL: 0
;PCODE: $00000D57 VOL: 0
;PCODE: $00000D58 VOL: 0
;PCODE: $00000D59 VOL: 0
;PCODE: $00000D5A VOL: 0
;PCODE: $00000D5B VOL: 0
;PCODE: $00000D5C VOL: 0
;			ST_WORD(fs->win+BS_55AA, 0xAA55);
;PCODE: $00000D5D VOL: 0
;PCODE: $00000D5E VOL: 0
;PCODE: $00000D5F VOL: 0
;PCODE: $00000D60 VOL: 0
;PCODE: $00000D61 VOL: 0
;PCODE: $00000D62 VOL: 0
;PCODE: $00000D63 VOL: 0
;PCODE: $00000D64 VOL: 0
;PCODE: $00000D65 VOL: 0
;PCODE: $00000D66 VOL: 0
;			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
;PCODE: $00000D67 VOL: 0
;PCODE: $00000D68 VOL: 0
;PCODE: $00000D69 VOL: 0
;PCODE: $00000D6A VOL: 0
;PCODE: $00000D6B VOL: 0
;PCODE: $00000D6C VOL: 0
;PCODE: $00000D6D VOL: 0
;PCODE: $00000D6E VOL: 0
;PCODE: $00000D6F VOL: 0
;PCODE: $00000D70 VOL: 0
;PCODE: $00000D71 VOL: 0
;PCODE: $00000D72 VOL: 0
;PCODE: $00000D73 VOL: 0
;PCODE: $00000D74 VOL: 0
;PCODE: $00000D75 VOL: 0
;PCODE: $00000D76 VOL: 0
;			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
;PCODE: $00000D77 VOL: 0
;PCODE: $00000D78 VOL: 0
;PCODE: $00000D79 VOL: 0
;PCODE: $00000D7A VOL: 0
;PCODE: $00000D7B VOL: 0
;PCODE: $00000D7C VOL: 0
;PCODE: $00000D7D VOL: 0
;PCODE: $00000D7E VOL: 0
;PCODE: $00000D7F VOL: 0
;PCODE: $00000D80 VOL: 0
;PCODE: $00000D81 VOL: 0
;PCODE: $00000D82 VOL: 0
;PCODE: $00000D83 VOL: 0
;PCODE: $00000D84 VOL: 0
;PCODE: $00000D85 VOL: 0
;PCODE: $00000D86 VOL: 0
;PCODE: $00000D87 VOL: 0
;PCODE: $00000D88 VOL: 0
;PCODE: $00000D89 VOL: 0
;PCODE: $00000D8A VOL: 0
;			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
;PCODE: $00000D8B VOL: 0
;PCODE: $00000D8C VOL: 0
;PCODE: $00000D8D VOL: 0
;PCODE: $00000D8E VOL: 0
;PCODE: $00000D8F VOL: 0
;PCODE: $00000D90 VOL: 0
;PCODE: $00000D91 VOL: 0
;PCODE: $00000D92 VOL: 0
;PCODE: $00000D93 VOL: 0
;PCODE: $00000D94 VOL: 0
;PCODE: $00000D95 VOL: 0
;PCODE: $00000D96 VOL: 0
;PCODE: $00000D97 VOL: 0
;PCODE: $00000D98 VOL: 0
;PCODE: $00000D99 VOL: 0
;PCODE: $00000D9A VOL: 0
;PCODE: $00000D9B VOL: 0
;PCODE: $00000D9C VOL: 0
;PCODE: $00000D9D VOL: 0
;PCODE: $00000D9E VOL: 0
;PCODE: $00000D9F VOL: 0
;PCODE: $00000DA0 VOL: 0
;PCODE: $00000DA1 VOL: 0
;PCODE: $00000DA2 VOL: 0
;PCODE: $00000DA3 VOL: 0
;PCODE: $00000DA4 VOL: 0
;PCODE: $00000DA5 VOL: 0
;PCODE: $00000DA6 VOL: 0
;PCODE: $00000DA7 VOL: 0
;PCODE: $00000DA8 VOL: 0
;PCODE: $00000DA9 VOL: 0
;PCODE: $00000DAA VOL: 0
;PCODE: $00000DAB VOL: 0
;PCODE: $00000DAC VOL: 0
;PCODE: $00000DAD VOL: 0
;PCODE: $00000DAE VOL: 0
;PCODE: $00000DAF VOL: 0
;			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
;PCODE: $00000DB0 VOL: 0
;PCODE: $00000DB1 VOL: 0
;PCODE: $00000DB2 VOL: 0
;PCODE: $00000DB3 VOL: 0
;PCODE: $00000DB4 VOL: 0
;PCODE: $00000DB5 VOL: 0
;PCODE: $00000DB6 VOL: 0
;PCODE: $00000DB7 VOL: 0
;PCODE: $00000DB8 VOL: 0
;PCODE: $00000DB9 VOL: 0
;PCODE: $00000DBA VOL: 0
;PCODE: $00000DBB VOL: 0
;PCODE: $00000DBC VOL: 0
;PCODE: $00000DBD VOL: 0
;PCODE: $00000DBE VOL: 0
;PCODE: $00000DBF VOL: 0
;PCODE: $00000DC0 VOL: 0
;PCODE: $00000DC1 VOL: 0
;PCODE: $00000DC2 VOL: 0
;PCODE: $00000DC3 VOL: 0
;PCODE: $00000DC4 VOL: 0
;PCODE: $00000DC5 VOL: 0
;PCODE: $00000DC6 VOL: 0
;PCODE: $00000DC7 VOL: 0
;PCODE: $00000DC8 VOL: 0
;PCODE: $00000DC9 VOL: 0
;PCODE: $00000DCA VOL: 0
;PCODE: $00000DCB VOL: 0
;PCODE: $00000DCC VOL: 0
;PCODE: $00000DCD VOL: 0
;PCODE: $00000DCE VOL: 0
;PCODE: $00000DCF VOL: 0
;PCODE: $00000DD0 VOL: 0
;PCODE: $00000DD1 VOL: 0
;PCODE: $00000DD2 VOL: 0
;PCODE: $00000DD3 VOL: 0
;PCODE: $00000DD4 VOL: 0
;			/* Write it into the FSINFO sector */
;			fs->winsect = fs->volbase + 1;
;PCODE: $00000DD5 VOL: 0
;PCODE: $00000DD6 VOL: 0
;PCODE: $00000DD7 VOL: 0
;PCODE: $00000DD8 VOL: 0
;PCODE: $00000DD9 VOL: 0
;PCODE: $00000DDA VOL: 0
;			disk_write(fs->drv, fs->win, fs->winsect, 1);
;PCODE: $00000DDB VOL: 0
;PCODE: $00000DDC VOL: 0
;PCODE: $00000DDD VOL: 0
;PCODE: $00000DDE VOL: 0
;PCODE: $00000DDF VOL: 0
;PCODE: $00000DE0 VOL: 0
;PCODE: $00000DE1 VOL: 0
;PCODE: $00000DE2 VOL: 0
;PCODE: $00000DE3 VOL: 0
;PCODE: $00000DE4 VOL: 0
;PCODE: $00000DE5 VOL: 0
;PCODE: $00000DE6 VOL: 0
;			fs->fsi_flag = 0;
;PCODE: $00000DE7 VOL: 0
;PCODE: $00000DE8 VOL: 0
;PCODE: $00000DE9 VOL: 0
;PCODE: $00000DEA VOL: 0
;		}
;		/* Make sure that no pending write process in the physical drive */
;		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
;PCODE: $00000DEB VOL: 0
;PCODE: $00000DEC VOL: 0
;PCODE: $00000DED VOL: 0
;PCODE: $00000DEE VOL: 0
;PCODE: $00000DEF VOL: 0
;PCODE: $00000DF0 VOL: 0
;PCODE: $00000DF1 VOL: 0
;PCODE: $00000DF2 VOL: 0
;PCODE: $00000DF3 VOL: 0
;PCODE: $00000DF4 VOL: 0
;PCODE: $00000DF5 VOL: 0
;			res = FR_DISK_ERR;
;PCODE: $00000DF6 VOL: 0
;PCODE: $00000DF7 VOL: 0
;	}
;PCODE: $00000DF8 VOL: 0
;
;	return res;
;PCODE: $00000DF9 VOL: 0
;PCODE: $00000DFA VOL: 0
;PCODE: $00000DFB VOL: 0
;PCODE: $00000DFC VOL: 0
;PCODE: $00000DFD VOL: 0
;PCODE: $00000DFE VOL: 0
;}
;PCODE: $00000DFF VOL: 0
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get sector# from cluster#                                             */
;/*-----------------------------------------------------------------------*/
;
;
;DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
;	FATFS* fs,		/* File system object */
;	DWORD clst		/* Cluster# to be converted */
;)
;{
;PCODE: $00000E00 VOL: 0
;PCODE: $00000E01 VOL: 0
;	clst -= 2;
;PCODE: $00000E02 VOL: 0
;	*fs -> Y+4
;	clst -> Y+0
;PCODE: $00000E03 VOL: 0
;PCODE: $00000E04 VOL: 0
;PCODE: $00000E05 VOL: 0
;	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
;PCODE: $00000E06 VOL: 0
;PCODE: $00000E07 VOL: 0
;PCODE: $00000E08 VOL: 0
;PCODE: $00000E09 VOL: 0
;PCODE: $00000E0A VOL: 0
;PCODE: $00000E0B VOL: 0
;PCODE: $00000E0C VOL: 0
;PCODE: $00000E0D VOL: 0
;PCODE: $00000E0E VOL: 0
;PCODE: $00000E0F VOL: 0
;PCODE: $00000E10 VOL: 0
;	return clst * fs->csize + fs->database;
;PCODE: $00000E11 VOL: 0
;PCODE: $00000E12 VOL: 0
;PCODE: $00000E13 VOL: 0
;PCODE: $00000E14 VOL: 0
;PCODE: $00000E15 VOL: 0
;PCODE: $00000E16 VOL: 0
;PCODE: $00000E17 VOL: 0
;PCODE: $00000E18 VOL: 0
;PCODE: $00000E19 VOL: 0
;PCODE: $00000E1A VOL: 0
;PCODE: $00000E1B VOL: 0
;PCODE: $00000E1C VOL: 0
;PCODE: $00000E1D VOL: 0
;PCODE: $00000E1E VOL: 0
;PCODE: $00000E1F VOL: 0
;}
;PCODE: $00000E20 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT access - Read value of a FAT entry                                */
;/*-----------------------------------------------------------------------*/
;
;DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
;	FATFS* fs,	/* File system object */
;	DWORD clst	/* Cluster# to get the link information */
;)
;{
;PCODE: $00000E21 VOL: 0
;PCODE: $00000E22 VOL: 0
;	UINT wc, bc;
;	BYTE *p;
;
;
;	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
;PCODE: $00000E23 VOL: 0
;PCODE: $00000E24 VOL: 0
;	*fs -> Y+10
;	clst -> Y+6
;	wc -> R16,R17
;	bc -> R18,R19
;	*p -> R20,R21
;PCODE: $00000E25 VOL: 0
;PCODE: $00000E26 VOL: 0
;PCODE: $00000E27 VOL: 0
;PCODE: $00000E28 VOL: 0
;PCODE: $00000E29 VOL: 0
;PCODE: $00000E2A VOL: 0
;PCODE: $00000E2B VOL: 0
;PCODE: $00000E2C VOL: 0
;PCODE: $00000E2D VOL: 0
;PCODE: $00000E2E VOL: 0
;PCODE: $00000E2F VOL: 0
;		return 1;
;PCODE: $00000E30 VOL: 0
;PCODE: $00000E31 VOL: 0
;PCODE: $00000E32 VOL: 0
;PCODE: $00000E33 VOL: 0
;
;	switch (fs->fs_type) {
;PCODE: $00000E34 VOL: 0
;PCODE: $00000E35 VOL: 0
;PCODE: $00000E36 VOL: 0
;PCODE: $00000E37 VOL: 0
;	case FS_FAT12 :
;PCODE: $00000E38 VOL: 0
;PCODE: $00000E39 VOL: 0
;		bc = (UINT)clst; bc += bc / 2;
;PCODE: $00000E3A VOL: 0
;PCODE: $00000E3B VOL: 0
;PCODE: $00000E3C VOL: 0
;PCODE: $00000E3D VOL: 0
;PCODE: $00000E3E VOL: 0
;PCODE: $00000E3F VOL: 0
;		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;PCODE: $00000E40 VOL: 0
;PCODE: $00000E41 VOL: 0
;PCODE: $00000E42 VOL: 0
;PCODE: $00000E43 VOL: 0
;PCODE: $00000E44 VOL: 0
;PCODE: $00000E45 VOL: 0
;PCODE: $00000E46 VOL: 0
;PCODE: $00000E47 VOL: 0
;PCODE: $00000E48 VOL: 0
;PCODE: $00000E49 VOL: 0
;PCODE: $00000E4A VOL: 0
;PCODE: $00000E4B VOL: 0
;PCODE: $00000E4C VOL: 0
;PCODE: $00000E4D VOL: 0
;PCODE: $00000E4E VOL: 0
;		wc = fs->win[bc % SS(fs)]; bc++;
;PCODE: $00000E4F VOL: 0
;PCODE: $00000E50 VOL: 0
;PCODE: $00000E51 VOL: 0
;PCODE: $00000E52 VOL: 0
;PCODE: $00000E53 VOL: 0
;PCODE: $00000E54 VOL: 0
;PCODE: $00000E55 VOL: 0
;PCODE: $00000E56 VOL: 0
;PCODE: $00000E57 VOL: 0
;PCODE: $00000E58 VOL: 0
;		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;PCODE: $00000E59 VOL: 0
;PCODE: $00000E5A VOL: 0
;PCODE: $00000E5B VOL: 0
;PCODE: $00000E5C VOL: 0
;PCODE: $00000E5D VOL: 0
;PCODE: $00000E5E VOL: 0
;PCODE: $00000E5F VOL: 0
;PCODE: $00000E60 VOL: 0
;PCODE: $00000E61 VOL: 0
;PCODE: $00000E62 VOL: 0
;PCODE: $00000E63 VOL: 0
;PCODE: $00000E64 VOL: 0
;PCODE: $00000E65 VOL: 0
;PCODE: $00000E66 VOL: 0
;PCODE: $00000E67 VOL: 0
;		wc |= fs->win[bc % SS(fs)] << 8;
;PCODE: $00000E68 VOL: 0
;PCODE: $00000E69 VOL: 0
;PCODE: $00000E6A VOL: 0
;PCODE: $00000E6B VOL: 0
;PCODE: $00000E6C VOL: 0
;PCODE: $00000E6D VOL: 0
;PCODE: $00000E6E VOL: 0
;PCODE: $00000E6F VOL: 0
;PCODE: $00000E70 VOL: 0
;PCODE: $00000E71 VOL: 0
;		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
;PCODE: $00000E72 VOL: 0
;PCODE: $00000E73 VOL: 0
;PCODE: $00000E74 VOL: 0
;PCODE: $00000E75 VOL: 0
;PCODE: $00000E76 VOL: 0
;PCODE: $00000E77 VOL: 0
;PCODE: $00000E78 VOL: 0
;PCODE: $00000E79 VOL: 0
;PCODE: $00000E7A VOL: 0
;PCODE: $00000E7B VOL: 0
;PCODE: $00000E7C VOL: 0
;PCODE: $00000E7D VOL: 0
;PCODE: $00000E7E VOL: 0
;PCODE: $00000E7F VOL: 0
;PCODE: $00000E80 VOL: 0
;PCODE: $00000E81 VOL: 0
;
;	case FS_FAT16 :
;PCODE: $00000E82 VOL: 0
;PCODE: $00000E83 VOL: 0
;PCODE: $00000E84 VOL: 0
;		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
;PCODE: $00000E85 VOL: 0
;PCODE: $00000E86 VOL: 0
;PCODE: $00000E87 VOL: 0
;PCODE: $00000E88 VOL: 0
;PCODE: $00000E89 VOL: 0
;PCODE: $00000E8A VOL: 0
;PCODE: $00000E8B VOL: 0
;PCODE: $00000E8C VOL: 0
;PCODE: $00000E8D VOL: 0
;PCODE: $00000E8E VOL: 0
;PCODE: $00000E8F VOL: 0
;PCODE: $00000E90 VOL: 0
;PCODE: $00000E91 VOL: 0
;PCODE: $00000E92 VOL: 0
;		p = &fs->win[clst * 2 % SS(fs)];
;PCODE: $00000E93 VOL: 0
;PCODE: $00000E94 VOL: 0
;PCODE: $00000E95 VOL: 0
;PCODE: $00000E96 VOL: 0
;PCODE: $00000E97 VOL: 0
;PCODE: $00000E98 VOL: 0
;PCODE: $00000E99 VOL: 0
;PCODE: $00000E9A VOL: 0
;PCODE: $00000E9B VOL: 0
;		return LD_WORD(p);
;PCODE: $00000E9C VOL: 0
;PCODE: $00000E9D VOL: 0
;PCODE: $00000E9E VOL: 0
;PCODE: $00000E9F VOL: 0
;PCODE: $00000EA0 VOL: 0
;PCODE: $00000EA1 VOL: 0
;PCODE: $00000EA2 VOL: 0
;PCODE: $00000EA3 VOL: 0
;PCODE: $00000EA4 VOL: 0
;PCODE: $00000EA5 VOL: 0
;PCODE: $00000EA6 VOL: 0
;PCODE: $00000EA7 VOL: 0
;PCODE: $00000EA8 VOL: 0
;
;	case FS_FAT32 :
;PCODE: $00000EA9 VOL: 0
;PCODE: $00000EAA VOL: 0
;PCODE: $00000EAB VOL: 0
;		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
;PCODE: $00000EAC VOL: 0
;PCODE: $00000EAD VOL: 0
;PCODE: $00000EAE VOL: 0
;PCODE: $00000EAF VOL: 0
;PCODE: $00000EB0 VOL: 0
;PCODE: $00000EB1 VOL: 0
;PCODE: $00000EB2 VOL: 0
;PCODE: $00000EB3 VOL: 0
;PCODE: $00000EB4 VOL: 0
;PCODE: $00000EB5 VOL: 0
;PCODE: $00000EB6 VOL: 0
;PCODE: $00000EB7 VOL: 0
;PCODE: $00000EB8 VOL: 0
;         {
;         break;
;PCODE: $00000EB9 VOL: 0
;         }
;		p = &fs->win[clst * 4 % SS(fs)];
;PCODE: $00000EBA VOL: 0
;PCODE: $00000EBB VOL: 0
;PCODE: $00000EBC VOL: 0
;PCODE: $00000EBD VOL: 0
;PCODE: $00000EBE VOL: 0
;PCODE: $00000EBF VOL: 0
;PCODE: $00000EC0 VOL: 0
;PCODE: $00000EC1 VOL: 0
;PCODE: $00000EC2 VOL: 0
;		return LD_DWORD(p) & 0x0FFFFFFF;
;PCODE: $00000EC3 VOL: 0
;PCODE: $00000EC4 VOL: 0
;PCODE: $00000EC5 VOL: 0
;PCODE: $00000EC6 VOL: 0
;PCODE: $00000EC7 VOL: 0
;PCODE: $00000EC8 VOL: 0
;PCODE: $00000EC9 VOL: 0
;PCODE: $00000ECA VOL: 0
;PCODE: $00000ECB VOL: 0
;PCODE: $00000ECC VOL: 0
;PCODE: $00000ECD VOL: 0
;PCODE: $00000ECE VOL: 0
;PCODE: $00000ECF VOL: 0
;PCODE: $00000ED0 VOL: 0
;PCODE: $00000ED1 VOL: 0
;PCODE: $00000ED2 VOL: 0
;PCODE: $00000ED3 VOL: 0
;PCODE: $00000ED4 VOL: 0
;PCODE: $00000ED5 VOL: 0
;PCODE: $00000ED6 VOL: 0
;PCODE: $00000ED7 VOL: 0
;PCODE: $00000ED8 VOL: 0
;PCODE: $00000ED9 VOL: 0
;PCODE: $00000EDA VOL: 0
;PCODE: $00000EDB VOL: 0
;PCODE: $00000EDC VOL: 0
;PCODE: $00000EDD VOL: 0
;PCODE: $00000EDE VOL: 0
;PCODE: $00000EDF VOL: 0
;PCODE: $00000EE0 VOL: 0
;PCODE: $00000EE1 VOL: 0
;	}
;PCODE: $00000EE2 VOL: 0
;	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
;PCODE: $00000EE3 VOL: 0
;PCODE: $00000EE4 VOL: 0
;PCODE: $00000EE5 VOL: 0
;PCODE: $00000EE6 VOL: 0
;}
;PCODE: $00000EE7 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT access - Change value of a FAT entry                              */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;
;FRESULT put_fat (
;	FATFS* fs,	/* File system object */
;	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
;	DWORD val	/* New value to mark the cluster */
;)
;{
;PCODE: $00000EE8 VOL: 0
;PCODE: $00000EE9 VOL: 0
;	UINT bc;
;	BYTE *p;
;	FRESULT res;
;
;
;	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
;PCODE: $00000EEA VOL: 0
;PCODE: $00000EEB VOL: 0
;	*fs -> Y+14
;	clst -> Y+10
;	val -> Y+6
;	bc -> R16,R17
;	*p -> R18,R19
;	res -> R21
;PCODE: $00000EEC VOL: 0
;PCODE: $00000EED VOL: 0
;PCODE: $00000EEE VOL: 0
;PCODE: $00000EEF VOL: 0
;PCODE: $00000EF0 VOL: 0
;PCODE: $00000EF1 VOL: 0
;PCODE: $00000EF2 VOL: 0
;PCODE: $00000EF3 VOL: 0
;PCODE: $00000EF4 VOL: 0
;PCODE: $00000EF5 VOL: 0
;PCODE: $00000EF6 VOL: 0
;		res = FR_INT_ERR;
;PCODE: $00000EF7 VOL: 0
;PCODE: $00000EF8 VOL: 0
;
;	} else {
;PCODE: $00000EF9 VOL: 0
;PCODE: $00000EFA VOL: 0
;		switch (fs->fs_type) {
;PCODE: $00000EFB VOL: 0
;PCODE: $00000EFC VOL: 0
;PCODE: $00000EFD VOL: 0
;		case FS_FAT12 :
;PCODE: $00000EFE VOL: 0
;PCODE: $00000EFF VOL: 0
;			bc = (UINT)clst; bc += bc / 2;
;PCODE: $00000F00 VOL: 0
;PCODE: $00000F01 VOL: 0
;PCODE: $00000F02 VOL: 0
;PCODE: $00000F03 VOL: 0
;PCODE: $00000F04 VOL: 0
;PCODE: $00000F05 VOL: 0
;			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;PCODE: $00000F06 VOL: 0
;PCODE: $00000F07 VOL: 0
;PCODE: $00000F08 VOL: 0
;PCODE: $00000F09 VOL: 0
;PCODE: $00000F0A VOL: 0
;PCODE: $00000F0B VOL: 0
;PCODE: $00000F0C VOL: 0
;PCODE: $00000F0D VOL: 0
;PCODE: $00000F0E VOL: 0
;PCODE: $00000F0F VOL: 0
;PCODE: $00000F10 VOL: 0
;PCODE: $00000F11 VOL: 0
;PCODE: $00000F12 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $00000F13 VOL: 0
;PCODE: $00000F14 VOL: 0
;PCODE: $00000F15 VOL: 0
;			p = &fs->win[bc % SS(fs)];
;PCODE: $00000F16 VOL: 0
;PCODE: $00000F17 VOL: 0
;PCODE: $00000F18 VOL: 0
;PCODE: $00000F19 VOL: 0
;PCODE: $00000F1A VOL: 0
;PCODE: $00000F1B VOL: 0
;PCODE: $00000F1C VOL: 0
;			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;PCODE: $00000F1D VOL: 0
;PCODE: $00000F1E VOL: 0
;PCODE: $00000F1F VOL: 0
;PCODE: $00000F20 VOL: 0
;PCODE: $00000F21 VOL: 0
;PCODE: $00000F22 VOL: 0
;PCODE: $00000F23 VOL: 0
;PCODE: $00000F24 VOL: 0
;PCODE: $00000F25 VOL: 0
;PCODE: $00000F26 VOL: 0
;PCODE: $00000F27 VOL: 0
;PCODE: $00000F28 VOL: 0
;PCODE: $00000F29 VOL: 0
;PCODE: $00000F2A VOL: 0
;PCODE: $00000F2B VOL: 0
;PCODE: $00000F2C VOL: 0
;PCODE: $00000F2D VOL: 0
;PCODE: $00000F2E VOL: 0
;			bc++;
;PCODE: $00000F2F VOL: 0
;PCODE: $00000F30 VOL: 0
;			fs->wflag = 1;
;PCODE: $00000F31 VOL: 0
;PCODE: $00000F32 VOL: 0
;PCODE: $00000F33 VOL: 0
;PCODE: $00000F34 VOL: 0
;			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;PCODE: $00000F35 VOL: 0
;PCODE: $00000F36 VOL: 0
;PCODE: $00000F37 VOL: 0
;PCODE: $00000F38 VOL: 0
;PCODE: $00000F39 VOL: 0
;PCODE: $00000F3A VOL: 0
;PCODE: $00000F3B VOL: 0
;PCODE: $00000F3C VOL: 0
;PCODE: $00000F3D VOL: 0
;PCODE: $00000F3E VOL: 0
;PCODE: $00000F3F VOL: 0
;PCODE: $00000F40 VOL: 0
;PCODE: $00000F41 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $00000F42 VOL: 0
;PCODE: $00000F43 VOL: 0
;PCODE: $00000F44 VOL: 0
;			p = &fs->win[bc % SS(fs)];
;PCODE: $00000F45 VOL: 0
;PCODE: $00000F46 VOL: 0
;PCODE: $00000F47 VOL: 0
;PCODE: $00000F48 VOL: 0
;PCODE: $00000F49 VOL: 0
;PCODE: $00000F4A VOL: 0
;PCODE: $00000F4B VOL: 0
;			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;PCODE: $00000F4C VOL: 0
;PCODE: $00000F4D VOL: 0
;PCODE: $00000F4E VOL: 0
;PCODE: $00000F4F VOL: 0
;PCODE: $00000F50 VOL: 0
;PCODE: $00000F51 VOL: 0
;PCODE: $00000F52 VOL: 0
;PCODE: $00000F53 VOL: 0
;PCODE: $00000F54 VOL: 0
;PCODE: $00000F55 VOL: 0
;PCODE: $00000F56 VOL: 0
;PCODE: $00000F57 VOL: 0
;PCODE: $00000F58 VOL: 0
;PCODE: $00000F59 VOL: 0
;PCODE: $00000F5A VOL: 0
;PCODE: $00000F5B VOL: 0
;PCODE: $00000F5C VOL: 0
;PCODE: $00000F5D VOL: 0
;PCODE: $00000F5E VOL: 0
;PCODE: $00000F5F VOL: 0
;PCODE: $00000F60 VOL: 0
;PCODE: $00000F61 VOL: 0
;PCODE: $00000F62 VOL: 0
;			break;
;PCODE: $00000F63 VOL: 0
;
;		case FS_FAT16 :
;PCODE: $00000F64 VOL: 0
;PCODE: $00000F65 VOL: 0
;PCODE: $00000F66 VOL: 0
;			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;PCODE: $00000F67 VOL: 0
;PCODE: $00000F68 VOL: 0
;PCODE: $00000F69 VOL: 0
;PCODE: $00000F6A VOL: 0
;PCODE: $00000F6B VOL: 0
;PCODE: $00000F6C VOL: 0
;PCODE: $00000F6D VOL: 0
;PCODE: $00000F6E VOL: 0
;PCODE: $00000F6F VOL: 0
;PCODE: $00000F70 VOL: 0
;PCODE: $00000F71 VOL: 0
;PCODE: $00000F72 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $00000F73 VOL: 0
;PCODE: $00000F74 VOL: 0
;PCODE: $00000F75 VOL: 0
;			p = &fs->win[clst * 2 % SS(fs)];
;PCODE: $00000F76 VOL: 0
;PCODE: $00000F77 VOL: 0
;PCODE: $00000F78 VOL: 0
;PCODE: $00000F79 VOL: 0
;PCODE: $00000F7A VOL: 0
;PCODE: $00000F7B VOL: 0
;PCODE: $00000F7C VOL: 0
;PCODE: $00000F7D VOL: 0
;PCODE: $00000F7E VOL: 0
;			ST_WORD(p, (WORD)val);
;PCODE: $00000F7F VOL: 0
;PCODE: $00000F80 VOL: 0
;PCODE: $00000F81 VOL: 0
;PCODE: $00000F82 VOL: 0
;PCODE: $00000F83 VOL: 0
;PCODE: $00000F84 VOL: 0
;			break;
;PCODE: $00000F85 VOL: 0
;
;		case FS_FAT32 :
;PCODE: $00000F86 VOL: 0
;PCODE: $00000F87 VOL: 0
;PCODE: $00000F88 VOL: 0
;			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;PCODE: $00000F89 VOL: 0
;PCODE: $00000F8A VOL: 0
;PCODE: $00000F8B VOL: 0
;PCODE: $00000F8C VOL: 0
;PCODE: $00000F8D VOL: 0
;PCODE: $00000F8E VOL: 0
;PCODE: $00000F8F VOL: 0
;PCODE: $00000F90 VOL: 0
;PCODE: $00000F91 VOL: 0
;PCODE: $00000F92 VOL: 0
;PCODE: $00000F93 VOL: 0
;PCODE: $00000F94 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $00000F95 VOL: 0
;PCODE: $00000F96 VOL: 0
;PCODE: $00000F97 VOL: 0
;			p = &fs->win[clst * 4 % SS(fs)];
;PCODE: $00000F98 VOL: 0
;PCODE: $00000F99 VOL: 0
;PCODE: $00000F9A VOL: 0
;PCODE: $00000F9B VOL: 0
;PCODE: $00000F9C VOL: 0
;PCODE: $00000F9D VOL: 0
;PCODE: $00000F9E VOL: 0
;PCODE: $00000F9F VOL: 0
;PCODE: $00000FA0 VOL: 0
;			val |= LD_DWORD(p) & 0xF0000000;
;PCODE: $00000FA1 VOL: 0
;PCODE: $00000FA2 VOL: 0
;PCODE: $00000FA3 VOL: 0
;PCODE: $00000FA4 VOL: 0
;PCODE: $00000FA5 VOL: 0
;PCODE: $00000FA6 VOL: 0
;PCODE: $00000FA7 VOL: 0
;PCODE: $00000FA8 VOL: 0
;PCODE: $00000FA9 VOL: 0
;PCODE: $00000FAA VOL: 0
;PCODE: $00000FAB VOL: 0
;PCODE: $00000FAC VOL: 0
;PCODE: $00000FAD VOL: 0
;PCODE: $00000FAE VOL: 0
;PCODE: $00000FAF VOL: 0
;PCODE: $00000FB0 VOL: 0
;PCODE: $00000FB1 VOL: 0
;PCODE: $00000FB2 VOL: 0
;PCODE: $00000FB3 VOL: 0
;PCODE: $00000FB4 VOL: 0
;PCODE: $00000FB5 VOL: 0
;PCODE: $00000FB6 VOL: 0
;PCODE: $00000FB7 VOL: 0
;PCODE: $00000FB8 VOL: 0
;PCODE: $00000FB9 VOL: 0
;PCODE: $00000FBA VOL: 0
;PCODE: $00000FBB VOL: 0
;PCODE: $00000FBC VOL: 0
;PCODE: $00000FBD VOL: 0
;PCODE: $00000FBE VOL: 0
;PCODE: $00000FBF VOL: 0
;			ST_DWORD(p, val);
;PCODE: $00000FC0 VOL: 0
;PCODE: $00000FC1 VOL: 0
;PCODE: $00000FC2 VOL: 0
;PCODE: $00000FC3 VOL: 0
;PCODE: $00000FC4 VOL: 0
;PCODE: $00000FC5 VOL: 0
;PCODE: $00000FC6 VOL: 0
;PCODE: $00000FC7 VOL: 0
;PCODE: $00000FC8 VOL: 0
;PCODE: $00000FC9 VOL: 0
;PCODE: $00000FCA VOL: 0
;PCODE: $00000FCB VOL: 0
;PCODE: $00000FCC VOL: 0
;PCODE: $00000FCD VOL: 0
;PCODE: $00000FCE VOL: 0
;			break;
;PCODE: $00000FCF VOL: 0
;
;		default :
;PCODE: $00000FD0 VOL: 0
;			res = FR_INT_ERR;
;PCODE: $00000FD1 VOL: 0
;PCODE: $00000FD2 VOL: 0
;		}
;PCODE: $00000FD3 VOL: 0
;		fs->wflag = 1;
;PCODE: $00000FD4 VOL: 0
;PCODE: $00000FD5 VOL: 0
;PCODE: $00000FD6 VOL: 0
;PCODE: $00000FD7 VOL: 0
;	}
;PCODE: $00000FD8 VOL: 0
;
;	return res;
;PCODE: $00000FD9 VOL: 0
;PCODE: $00000FDA VOL: 0
;PCODE: $00000FDB VOL: 0
;PCODE: $00000FDC VOL: 0
;}
;PCODE: $00000FDD VOL: 0
;#endif /* !_FS_READONLY */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT handling - Remove a cluster chain                                 */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;static
;FRESULT remove_chain (
;	FATFS* fs,			/* File system object */
;	DWORD clst			/* Cluster# to remove a chain from */
;)
;{
;PCODE: $00000FDE VOL: 0
;PCODE: $00000FDF VOL: 0
;	FRESULT res;
;	DWORD nxt;
;#if _USE_ERASE
;	DWORD scl = clst, ecl = clst, rt[2];
;#endif
;
;	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
;PCODE: $00000FE0 VOL: 0
;PCODE: $00000FE1 VOL: 0
;PCODE: $00000FE2 VOL: 0
;	*fs -> Y+9
;	clst -> Y+5
;	res -> R17
;	nxt -> Y+1
;PCODE: $00000FE3 VOL: 0
;PCODE: $00000FE4 VOL: 0
;PCODE: $00000FE5 VOL: 0
;PCODE: $00000FE6 VOL: 0
;PCODE: $00000FE7 VOL: 0
;PCODE: $00000FE8 VOL: 0
;PCODE: $00000FE9 VOL: 0
;PCODE: $00000FEA VOL: 0
;PCODE: $00000FEB VOL: 0
;PCODE: $00000FEC VOL: 0
;PCODE: $00000FED VOL: 0
;		res = FR_INT_ERR;
;PCODE: $00000FEE VOL: 0
;PCODE: $00000FEF VOL: 0
;
;	} else {
;PCODE: $00000FF0 VOL: 0
;PCODE: $00000FF1 VOL: 0
;		res = FR_OK;
;PCODE: $00000FF2 VOL: 0
;PCODE: $00000FF3 VOL: 0
;		while (clst < fs->n_fatent) {			/* Not a last link? */
;PCODE: $00000FF4 VOL: 0
;PCODE: $00000FF5 VOL: 0
;PCODE: $00000FF6 VOL: 0
;PCODE: $00000FF7 VOL: 0
;PCODE: $00000FF8 VOL: 0
;PCODE: $00000FF9 VOL: 0
;PCODE: $00000FFA VOL: 0
;			nxt = get_fat(fs, clst);			/* Get cluster status */
;PCODE: $00000FFB VOL: 0
;PCODE: $00000FFC VOL: 0
;PCODE: $00000FFD VOL: 0
;PCODE: $00000FFE VOL: 0
;PCODE: $00000FFF VOL: 0
;			if (nxt == 0) break;				/* Empty cluster? */
;PCODE: $00001000 VOL: 0
;PCODE: $00001001 VOL: 0
;PCODE: $00001002 VOL: 0
;PCODE: $00001003 VOL: 0
;			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
;PCODE: $00001004 VOL: 0
;PCODE: $00001005 VOL: 0
;PCODE: $00001006 VOL: 0
;PCODE: $00001007 VOL: 0
;PCODE: $00001008 VOL: 0
;PCODE: $00001009 VOL: 0
;PCODE: $0000100A VOL: 0
;			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
;PCODE: $0000100B VOL: 0
;PCODE: $0000100C VOL: 0
;PCODE: $0000100D VOL: 0
;PCODE: $0000100E VOL: 0
;PCODE: $0000100F VOL: 0
;PCODE: $00001010 VOL: 0
;PCODE: $00001011 VOL: 0
;			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
;PCODE: $00001012 VOL: 0
;PCODE: $00001013 VOL: 0
;PCODE: $00001014 VOL: 0
;PCODE: $00001015 VOL: 0
;PCODE: $00001016 VOL: 0
;PCODE: $00001017 VOL: 0
;PCODE: $00001018 VOL: 0
;PCODE: $00001019 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $0000101A VOL: 0
;PCODE: $0000101B VOL: 0
;PCODE: $0000101C VOL: 0
;			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
;PCODE: $0000101D VOL: 0
;PCODE: $0000101E VOL: 0
;PCODE: $0000101F VOL: 0
;PCODE: $00001020 VOL: 0
;PCODE: $00001021 VOL: 0
;				fs->free_clust++;
;PCODE: $00001022 VOL: 0
;PCODE: $00001023 VOL: 0
;PCODE: $00001024 VOL: 0
;PCODE: $00001025 VOL: 0
;PCODE: $00001026 VOL: 0
;				fs->fsi_flag |= 1;
;PCODE: $00001027 VOL: 0
;PCODE: $00001028 VOL: 0
;PCODE: $00001029 VOL: 0
;PCODE: $0000102A VOL: 0
;PCODE: $0000102B VOL: 0
;			}
;#if _USE_ERASE
;			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;				ecl = nxt;
;			} else {				/* End of contiguous clusters */
;				rt[0] = clust2sect(fs, scl);					/* Start sector */
;				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
;				scl = ecl = nxt;
;			}
;#endif
;			clst = nxt;	/* Next cluster */
;PCODE: $0000102C VOL: 0
;PCODE: $0000102D VOL: 0
;PCODE: $0000102E VOL: 0
;		}
;PCODE: $0000102F VOL: 0
;PCODE: $00001030 VOL: 0
;	}
;PCODE: $00001031 VOL: 0
;
;	return res;
;PCODE: $00001032 VOL: 0
;PCODE: $00001033 VOL: 0
;PCODE: $00001034 VOL: 0
;PCODE: $00001035 VOL: 0
;PCODE: $00001036 VOL: 0
;}
;PCODE: $00001037 VOL: 0
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT handling - Stretch or Create a cluster chain                      */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;static
;DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
;	FATFS* fs,			/* File system object */
;	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;)
;{
;PCODE: $00001038 VOL: 0
;PCODE: $00001039 VOL: 0
;	DWORD cs, ncl, scl;
;	FRESULT res;
;
;
;	if (clst == 0) {		/* Create a new chain */
;PCODE: $0000103A VOL: 0
;PCODE: $0000103B VOL: 0
;PCODE: $0000103C VOL: 0
;	*fs -> Y+17
;	clst -> Y+13
;	cs -> Y+9
;	ncl -> Y+5
;	scl -> Y+1
;	res -> R17
;PCODE: $0000103D VOL: 0
;PCODE: $0000103E VOL: 0
;PCODE: $0000103F VOL: 0
;		scl = fs->last_clust;			/* Get suggested start point */
;PCODE: $00001040 VOL: 0
;PCODE: $00001041 VOL: 0
;PCODE: $00001042 VOL: 0
;PCODE: $00001043 VOL: 0
;		if (!scl || scl >= fs->n_fatent) scl = 1;
;PCODE: $00001044 VOL: 0
;PCODE: $00001045 VOL: 0
;PCODE: $00001046 VOL: 0
;PCODE: $00001047 VOL: 0
;PCODE: $00001048 VOL: 0
;PCODE: $00001049 VOL: 0
;PCODE: $0000104A VOL: 0
;PCODE: $0000104B VOL: 0
;PCODE: $0000104C VOL: 0
;PCODE: $0000104D VOL: 0
;PCODE: $0000104E VOL: 0
;PCODE: $0000104F VOL: 0
;PCODE: $00001050 VOL: 0
;	}
;PCODE: $00001051 VOL: 0
;	else {					/* Stretch the current chain */
;PCODE: $00001052 VOL: 0
;PCODE: $00001053 VOL: 0
;		cs = get_fat(fs, clst);			/* Check the cluster status */
;PCODE: $00001054 VOL: 0
;PCODE: $00001055 VOL: 0
;PCODE: $00001056 VOL: 0
;PCODE: $00001057 VOL: 0
;PCODE: $00001058 VOL: 0
;		if (cs < 2) return 1;			/* It is an invalid cluster */
;PCODE: $00001059 VOL: 0
;PCODE: $0000105A VOL: 0
;PCODE: $0000105B VOL: 0
;PCODE: $0000105C VOL: 0
;PCODE: $0000105D VOL: 0
;PCODE: $0000105E VOL: 0
;PCODE: $0000105F VOL: 0
;PCODE: $00001060 VOL: 0
;		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;PCODE: $00001061 VOL: 0
;PCODE: $00001062 VOL: 0
;PCODE: $00001063 VOL: 0
;PCODE: $00001064 VOL: 0
;PCODE: $00001065 VOL: 0
;PCODE: $00001066 VOL: 0
;PCODE: $00001067 VOL: 0
;PCODE: $00001068 VOL: 0
;PCODE: $00001069 VOL: 0
;PCODE: $0000106A VOL: 0
;PCODE: $0000106B VOL: 0
;PCODE: $0000106C VOL: 0
;		scl = clst;
;PCODE: $0000106D VOL: 0
;PCODE: $0000106E VOL: 0
;PCODE: $0000106F VOL: 0
;	}
;PCODE: $00001070 VOL: 0
;
;	ncl = scl;				/* Start cluster */
;PCODE: $00001071 VOL: 0
;PCODE: $00001072 VOL: 0
;	for (;;) {
;PCODE: $00001073 VOL: 0
;PCODE: $00001074 VOL: 0
;		ncl++;							/* Next cluster */
;PCODE: $00001075 VOL: 0
;PCODE: $00001076 VOL: 0
;PCODE: $00001077 VOL: 0
;		if (ncl >= fs->n_fatent) {		/* Wrap around */
;PCODE: $00001078 VOL: 0
;PCODE: $00001079 VOL: 0
;PCODE: $0000107A VOL: 0
;PCODE: $0000107B VOL: 0
;PCODE: $0000107C VOL: 0
;PCODE: $0000107D VOL: 0
;			ncl = 2;
;PCODE: $0000107E VOL: 0
;PCODE: $0000107F VOL: 0
;			if (ncl > scl) return 0;	/* No free cluster */
;PCODE: $00001080 VOL: 0
;PCODE: $00001081 VOL: 0
;PCODE: $00001082 VOL: 0
;PCODE: $00001083 VOL: 0
;PCODE: $00001084 VOL: 0
;PCODE: $00001085 VOL: 0
;PCODE: $00001086 VOL: 0
;PCODE: $00001087 VOL: 0
;PCODE: $00001088 VOL: 0
;		}
;PCODE: $00001089 VOL: 0
;		cs = get_fat(fs, ncl);			/* Get the cluster status */
;PCODE: $0000108A VOL: 0
;PCODE: $0000108B VOL: 0
;PCODE: $0000108C VOL: 0
;PCODE: $0000108D VOL: 0
;PCODE: $0000108E VOL: 0
;PCODE: $0000108F VOL: 0
;		if (cs == 0) break;				/* Found a free cluster */
;PCODE: $00001090 VOL: 0
;PCODE: $00001091 VOL: 0
;PCODE: $00001092 VOL: 0
;PCODE: $00001093 VOL: 0
;		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;PCODE: $00001094 VOL: 0
;PCODE: $00001095 VOL: 0
;PCODE: $00001096 VOL: 0
;PCODE: $00001097 VOL: 0
;PCODE: $00001098 VOL: 0
;PCODE: $00001099 VOL: 0
;PCODE: $0000109A VOL: 0
;PCODE: $0000109B VOL: 0
;PCODE: $0000109C VOL: 0
;			return cs;
;PCODE: $0000109D VOL: 0
;PCODE: $0000109E VOL: 0
;PCODE: $0000109F VOL: 0
;PCODE: $000010A0 VOL: 0
;PCODE: $000010A1 VOL: 0
;		if (ncl == scl) return 0;		/* No free cluster */
;PCODE: $000010A2 VOL: 0
;PCODE: $000010A3 VOL: 0
;PCODE: $000010A4 VOL: 0
;PCODE: $000010A5 VOL: 0
;PCODE: $000010A6 VOL: 0
;PCODE: $000010A7 VOL: 0
;PCODE: $000010A8 VOL: 0
;PCODE: $000010A9 VOL: 0
;PCODE: $000010AA VOL: 0
;PCODE: $000010AB VOL: 0
;	}
;PCODE: $000010AC VOL: 0
;PCODE: $000010AD VOL: 0
;PCODE: $000010AE VOL: 0
;PCODE: $000010AF VOL: 0
;
;	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;PCODE: $000010B0 VOL: 0
;PCODE: $000010B1 VOL: 0
;PCODE: $000010B2 VOL: 0
;PCODE: $000010B3 VOL: 0
;PCODE: $000010B4 VOL: 0
;PCODE: $000010B5 VOL: 0
;PCODE: $000010B6 VOL: 0
;	if (res == FR_OK && clst != 0) {
;PCODE: $000010B7 VOL: 0
;PCODE: $000010B8 VOL: 0
;PCODE: $000010B9 VOL: 0
;PCODE: $000010BA VOL: 0
;PCODE: $000010BB VOL: 0
;PCODE: $000010BC VOL: 0
;PCODE: $000010BD VOL: 0
;PCODE: $000010BE VOL: 0
;PCODE: $000010BF VOL: 0
;		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;PCODE: $000010C0 VOL: 0
;PCODE: $000010C1 VOL: 0
;PCODE: $000010C2 VOL: 0
;PCODE: $000010C3 VOL: 0
;PCODE: $000010C4 VOL: 0
;PCODE: $000010C5 VOL: 0
;PCODE: $000010C6 VOL: 0
;	}
;	if (res == FR_OK) {
;PCODE: $000010C7 VOL: 0
;PCODE: $000010C8 VOL: 0
;PCODE: $000010C9 VOL: 0
;		fs->last_clust = ncl;			/* Update FSINFO */
;PCODE: $000010CA VOL: 0
;PCODE: $000010CB VOL: 0
;PCODE: $000010CC VOL: 0
;		if (fs->free_clust != 0xFFFFFFFF) {
;PCODE: $000010CD VOL: 0
;PCODE: $000010CE VOL: 0
;PCODE: $000010CF VOL: 0
;PCODE: $000010D0 VOL: 0
;			fs->free_clust--;
;PCODE: $000010D1 VOL: 0
;PCODE: $000010D2 VOL: 0
;PCODE: $000010D3 VOL: 0
;PCODE: $000010D4 VOL: 0
;PCODE: $000010D5 VOL: 0
;			fs->fsi_flag |= 1;
;PCODE: $000010D6 VOL: 0
;PCODE: $000010D7 VOL: 0
;PCODE: $000010D8 VOL: 0
;PCODE: $000010D9 VOL: 0
;PCODE: $000010DA VOL: 0
;		}
;	} else {
;PCODE: $000010DB VOL: 0
;PCODE: $000010DC VOL: 0
;PCODE: $000010DD VOL: 0
;		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;PCODE: $000010DE VOL: 0
;PCODE: $000010DF VOL: 0
;PCODE: $000010E0 VOL: 0
;PCODE: $000010E1 VOL: 0
;PCODE: $000010E2 VOL: 0
;PCODE: $000010E3 VOL: 0
;PCODE: $000010E4 VOL: 0
;PCODE: $000010E5 VOL: 0
;PCODE: $000010E6 VOL: 0
;PCODE: $000010E7 VOL: 0
;PCODE: $000010E8 VOL: 0
;	}
;PCODE: $000010E9 VOL: 0
;
;	return ncl;		/* Return new cluster number or error code */
;PCODE: $000010EA VOL: 0
;PCODE: $000010EB VOL: 0
;PCODE: $000010EC VOL: 0
;PCODE: $000010ED VOL: 0
;PCODE: $000010EE VOL: 0
;}
;PCODE: $000010EF VOL: 0
;#endif /* !_FS_READONLY */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* FAT handling - Convert offset into cluster with link map table        */
;/*-----------------------------------------------------------------------*/
;
;#if _USE_FASTSEEK
;static
;DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
;	FIL* fp,		/* Pointer to the file object */
;	DWORD ofs		/* File offset to be converted to cluster# */
;)
;{
;	DWORD cl, ncl, *tbl;
;
;
;	tbl = fp->cltbl + 1;	/* Top of CLMT */
;	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
;	for (;;) {
;		ncl = *tbl++;			/* Number of cluters in the fragment */
;		if (!ncl) return 0;		/* End of table? (error) */
;		if (cl < ncl) break;	/* In this fragment? */
;		cl -= ncl; tbl++;		/* Next fragment */
;	}
;	return cl + *tbl;	/* Return the cluster number */
;}
;#endif	/* _USE_FASTSEEK */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Set directory index                              */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_sdi (
;	DIR* dp,		/* Pointer to directory object */
;	WORD idx		/* Index of directory table */
;)
;{
;PCODE: $000010F0 VOL: 0
;PCODE: $000010F1 VOL: 0
;	DWORD clst;
;	WORD ic;
;
;
;	dp->index = idx;
;PCODE: $000010F2 VOL: 0
;PCODE: $000010F3 VOL: 0
;PCODE: $000010F4 VOL: 0
;PCODE: $000010F5 VOL: 0
;	*dp -> Y+8
;	idx -> Y+6
;	clst -> Y+2
;	ic -> R16,R17
;PCODE: $000010F6 VOL: 0
;PCODE: $000010F7 VOL: 0
;PCODE: $000010F8 VOL: 0
;	clst = dp->sclust;
;PCODE: $000010F9 VOL: 0
;PCODE: $000010FA VOL: 0
;PCODE: $000010FB VOL: 0
;PCODE: $000010FC VOL: 0
;	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
;PCODE: $000010FD VOL: 0
;PCODE: $000010FE VOL: 0
;PCODE: $000010FF VOL: 0
;PCODE: $00001100 VOL: 0
;PCODE: $00001101 VOL: 0
;PCODE: $00001102 VOL: 0
;PCODE: $00001103 VOL: 0
;PCODE: $00001104 VOL: 0
;PCODE: $00001105 VOL: 0
;PCODE: $00001106 VOL: 0
;PCODE: $00001107 VOL: 0
;PCODE: $00001108 VOL: 0
;PCODE: $00001109 VOL: 0
;		return FR_INT_ERR;
;PCODE: $0000110A VOL: 0
;PCODE: $0000110B VOL: 0
;PCODE: $0000110C VOL: 0
;PCODE: $0000110D VOL: 0
;PCODE: $0000110E VOL: 0
;PCODE: $0000110F VOL: 0
;PCODE: $00001110 VOL: 0
;	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
;PCODE: $00001111 VOL: 0
;PCODE: $00001112 VOL: 0
;PCODE: $00001113 VOL: 0
;PCODE: $00001114 VOL: 0
;PCODE: $00001115 VOL: 0
;PCODE: $00001116 VOL: 0
;PCODE: $00001117 VOL: 0
;PCODE: $00001118 VOL: 0
;PCODE: $00001119 VOL: 0
;PCODE: $0000111A VOL: 0
;PCODE: $0000111B VOL: 0
;PCODE: $0000111C VOL: 0
;PCODE: $0000111D VOL: 0
;		clst = dp->fs->dirbase;
;PCODE: $0000111E VOL: 0
;PCODE: $0000111F VOL: 0
;PCODE: $00001120 VOL: 0
;PCODE: $00001121 VOL: 0
;PCODE: $00001122 VOL: 0
;PCODE: $00001123 VOL: 0
;
;	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;PCODE: $00001124 VOL: 0
;PCODE: $00001125 VOL: 0
;PCODE: $00001126 VOL: 0
;PCODE: $00001127 VOL: 0
;		dp->clust = clst;
;PCODE: $00001128 VOL: 0
;PCODE: $00001129 VOL: 0
;PCODE: $0000112A VOL: 0
;		if (idx >= dp->fs->n_rootdir)		/* Index is out of range */
;PCODE: $0000112B VOL: 0
;PCODE: $0000112C VOL: 0
;PCODE: $0000112D VOL: 0
;PCODE: $0000112E VOL: 0
;PCODE: $0000112F VOL: 0
;PCODE: $00001130 VOL: 0
;PCODE: $00001131 VOL: 0
;PCODE: $00001132 VOL: 0
;			return FR_INT_ERR;
;PCODE: $00001133 VOL: 0
;PCODE: $00001134 VOL: 0
;PCODE: $00001135 VOL: 0
;PCODE: $00001136 VOL: 0
;PCODE: $00001137 VOL: 0
;PCODE: $00001138 VOL: 0
;PCODE: $00001139 VOL: 0
;		dp->sect = dp->fs->dirbase + idx / (SS(dp->fs) / SZ_DIR);	/* Sector# */
;PCODE: $0000113A VOL: 0
;PCODE: $0000113B VOL: 0
;PCODE: $0000113C VOL: 0
;PCODE: $0000113D VOL: 0
;PCODE: $0000113E VOL: 0
;PCODE: $0000113F VOL: 0
;PCODE: $00001140 VOL: 0
;PCODE: $00001141 VOL: 0
;PCODE: $00001142 VOL: 0
;PCODE: $00001143 VOL: 0
;PCODE: $00001144 VOL: 0
;PCODE: $00001145 VOL: 0
;PCODE: $00001146 VOL: 0
;	}
;	else {				/* Dynamic table (sub-dirs or root-directory in FAT32) */
;PCODE: $00001147 VOL: 0
;PCODE: $00001148 VOL: 0
;		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
;PCODE: $00001149 VOL: 0
;PCODE: $0000114A VOL: 0
;PCODE: $0000114B VOL: 0
;PCODE: $0000114C VOL: 0
;PCODE: $0000114D VOL: 0
;PCODE: $0000114E VOL: 0
;		while (idx >= ic) {	/* Follow cluster chain */
;PCODE: $0000114F VOL: 0
;PCODE: $00001150 VOL: 0
;PCODE: $00001151 VOL: 0
;PCODE: $00001152 VOL: 0
;			clst = get_fat(dp->fs, clst);				/* Get next cluster */
;PCODE: $00001153 VOL: 0
;PCODE: $00001154 VOL: 0
;PCODE: $00001155 VOL: 0
;PCODE: $00001156 VOL: 0
;PCODE: $00001157 VOL: 0
;PCODE: $00001158 VOL: 0
;			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;PCODE: $00001159 VOL: 0
;PCODE: $0000115A VOL: 0
;PCODE: $0000115B VOL: 0
;PCODE: $0000115C VOL: 0
;PCODE: $0000115D VOL: 0
;PCODE: $0000115E VOL: 0
;PCODE: $0000115F VOL: 0
;PCODE: $00001160 VOL: 0
;PCODE: $00001161 VOL: 0
;PCODE: $00001162 VOL: 0
;			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or int error */
;PCODE: $00001163 VOL: 0
;PCODE: $00001164 VOL: 0
;PCODE: $00001165 VOL: 0
;PCODE: $00001166 VOL: 0
;PCODE: $00001167 VOL: 0
;PCODE: $00001168 VOL: 0
;PCODE: $00001169 VOL: 0
;PCODE: $0000116A VOL: 0
;PCODE: $0000116B VOL: 0
;PCODE: $0000116C VOL: 0
;PCODE: $0000116D VOL: 0
;PCODE: $0000116E VOL: 0
;PCODE: $0000116F VOL: 0
;PCODE: $00001170 VOL: 0
;				return FR_INT_ERR;
;PCODE: $00001171 VOL: 0
;PCODE: $00001172 VOL: 0
;PCODE: $00001173 VOL: 0
;PCODE: $00001174 VOL: 0
;PCODE: $00001175 VOL: 0
;PCODE: $00001176 VOL: 0
;PCODE: $00001177 VOL: 0
;			idx -= ic;
;PCODE: $00001178 VOL: 0
;PCODE: $00001179 VOL: 0
;PCODE: $0000117A VOL: 0
;PCODE: $0000117B VOL: 0
;		}
;PCODE: $0000117C VOL: 0
;PCODE: $0000117D VOL: 0
;		dp->clust = clst;
;PCODE: $0000117E VOL: 0
;PCODE: $0000117F VOL: 0
;PCODE: $00001180 VOL: 0
;		dp->sect = clust2sect(dp->fs, clst) + idx / (SS(dp->fs) / SZ_DIR);	/* Sector# */
;PCODE: $00001181 VOL: 0
;PCODE: $00001182 VOL: 0
;PCODE: $00001183 VOL: 0
;PCODE: $00001184 VOL: 0
;PCODE: $00001185 VOL: 0
;PCODE: $00001186 VOL: 0
;PCODE: $00001187 VOL: 0
;PCODE: $00001188 VOL: 0
;PCODE: $00001189 VOL: 0
;PCODE: $0000118A VOL: 0
;PCODE: $0000118B VOL: 0
;PCODE: $0000118C VOL: 0
;	}
;PCODE: $0000118D VOL: 0
;
;	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
;PCODE: $0000118E VOL: 0
;PCODE: $0000118F VOL: 0
;PCODE: $00001190 VOL: 0
;PCODE: $00001191 VOL: 0
;PCODE: $00001192 VOL: 0
;PCODE: $00001193 VOL: 0
;PCODE: $00001194 VOL: 0
;PCODE: $00001195 VOL: 0
;PCODE: $00001196 VOL: 0
;PCODE: $00001197 VOL: 0
;PCODE: $00001198 VOL: 0
;
;	return FR_OK;	/* Seek succeeded */
;PCODE: $00001199 VOL: 0
;PCODE: $0000119A VOL: 0
;PCODE: $0000119B VOL: 0
;PCODE: $0000119C VOL: 0
;PCODE: $0000119D VOL: 0
;PCODE: $0000119E VOL: 0
;PCODE: $0000119F VOL: 0
;}
;PCODE: $000011A0 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Move directory table index next                  */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
;	DIR* dp,		/* Pointer to the directory object */
;	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;)
;{
;PCODE: $000011A1 VOL: 0
;PCODE: $000011A2 VOL: 0
;	DWORD clst;
;	WORD i;
;
;
;	i = dp->index + 1;
;PCODE: $000011A3 VOL: 0
;PCODE: $000011A4 VOL: 0
;PCODE: $000011A5 VOL: 0
;PCODE: $000011A6 VOL: 0
;	*dp -> Y+8
;	stretch -> Y+6
;	clst -> Y+2
;	i -> R16,R17
;PCODE: $000011A7 VOL: 0
;PCODE: $000011A8 VOL: 0
;PCODE: $000011A9 VOL: 0
;PCODE: $000011AA VOL: 0
;PCODE: $000011AB VOL: 0
;	if (!i || !dp->sect)	/* Report EOT when index has reached 65535 */
;PCODE: $000011AC VOL: 0
;PCODE: $000011AD VOL: 0
;PCODE: $000011AE VOL: 0
;PCODE: $000011AF VOL: 0
;PCODE: $000011B0 VOL: 0
;PCODE: $000011B1 VOL: 0
;PCODE: $000011B2 VOL: 0
;PCODE: $000011B3 VOL: 0
;PCODE: $000011B4 VOL: 0
;		return FR_NO_FILE;
;PCODE: $000011B5 VOL: 0
;PCODE: $000011B6 VOL: 0
;PCODE: $000011B7 VOL: 0
;PCODE: $000011B8 VOL: 0
;PCODE: $000011B9 VOL: 0
;PCODE: $000011BA VOL: 0
;PCODE: $000011BB VOL: 0
;
;	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
;PCODE: $000011BC VOL: 0
;PCODE: $000011BD VOL: 0
;PCODE: $000011BE VOL: 0
;PCODE: $000011BF VOL: 0
;		dp->sect++;					/* Next sector */
;PCODE: $000011C0 VOL: 0
;PCODE: $000011C1 VOL: 0
;PCODE: $000011C2 VOL: 0
;PCODE: $000011C3 VOL: 0
;PCODE: $000011C4 VOL: 0
;
;		if (!dp->clust) {		/* Static table */
;PCODE: $000011C5 VOL: 0
;PCODE: $000011C6 VOL: 0
;PCODE: $000011C7 VOL: 0
;PCODE: $000011C8 VOL: 0
;PCODE: $000011C9 VOL: 0
;			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;PCODE: $000011CA VOL: 0
;PCODE: $000011CB VOL: 0
;PCODE: $000011CC VOL: 0
;PCODE: $000011CD VOL: 0
;PCODE: $000011CE VOL: 0
;PCODE: $000011CF VOL: 0
;PCODE: $000011D0 VOL: 0
;				return FR_NO_FILE;
;PCODE: $000011D1 VOL: 0
;PCODE: $000011D2 VOL: 0
;PCODE: $000011D3 VOL: 0
;PCODE: $000011D4 VOL: 0
;PCODE: $000011D5 VOL: 0
;PCODE: $000011D6 VOL: 0
;PCODE: $000011D7 VOL: 0
;		}
;PCODE: $000011D8 VOL: 0
;		else {					/* Dynamic table */
;PCODE: $000011D9 VOL: 0
;PCODE: $000011DA VOL: 0
;			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
;PCODE: $000011DB VOL: 0
;PCODE: $000011DC VOL: 0
;PCODE: $000011DD VOL: 0
;PCODE: $000011DE VOL: 0
;PCODE: $000011DF VOL: 0
;PCODE: $000011E0 VOL: 0
;PCODE: $000011E1 VOL: 0
;PCODE: $000011E2 VOL: 0
;PCODE: $000011E3 VOL: 0
;PCODE: $000011E4 VOL: 0
;PCODE: $000011E5 VOL: 0
;				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
;PCODE: $000011E6 VOL: 0
;PCODE: $000011E7 VOL: 0
;PCODE: $000011E8 VOL: 0
;PCODE: $000011E9 VOL: 0
;PCODE: $000011EA VOL: 0
;PCODE: $000011EB VOL: 0
;PCODE: $000011EC VOL: 0
;				if (clst <= 1) return FR_INT_ERR;
;PCODE: $000011ED VOL: 0
;PCODE: $000011EE VOL: 0
;PCODE: $000011EF VOL: 0
;PCODE: $000011F0 VOL: 0
;PCODE: $000011F1 VOL: 0
;PCODE: $000011F2 VOL: 0
;PCODE: $000011F3 VOL: 0
;PCODE: $000011F4 VOL: 0
;PCODE: $000011F5 VOL: 0
;PCODE: $000011F6 VOL: 0
;				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;PCODE: $000011F7 VOL: 0
;PCODE: $000011F8 VOL: 0
;PCODE: $000011F9 VOL: 0
;PCODE: $000011FA VOL: 0
;PCODE: $000011FB VOL: 0
;PCODE: $000011FC VOL: 0
;PCODE: $000011FD VOL: 0
;PCODE: $000011FE VOL: 0
;PCODE: $000011FF VOL: 0
;PCODE: $00001200 VOL: 0
;PCODE: $00001201 VOL: 0
;				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
;PCODE: $00001202 VOL: 0
;PCODE: $00001203 VOL: 0
;PCODE: $00001204 VOL: 0
;PCODE: $00001205 VOL: 0
;PCODE: $00001206 VOL: 0
;PCODE: $00001207 VOL: 0
;PCODE: $00001208 VOL: 0
;PCODE: $00001209 VOL: 0
;PCODE: $0000120A VOL: 0
;#if !_FS_READONLY
;					BYTE c;
;					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
;PCODE: $0000120B VOL: 0
;	*dp -> Y+9
;	stretch -> Y+7
;	clst -> Y+3
;	c -> Y+0
;PCODE: $0000120C VOL: 0
;PCODE: $0000120D VOL: 0
;PCODE: $0000120E VOL: 0
;PCODE: $0000120F VOL: 0
;PCODE: $00001210 VOL: 0
;PCODE: $00001211 VOL: 0
;PCODE: $00001212 VOL: 0
;PCODE: $00001213 VOL: 0
;PCODE: $00001214 VOL: 0
;PCODE: $00001215 VOL: 0
;PCODE: $00001216 VOL: 0
;					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
;PCODE: $00001217 VOL: 0
;PCODE: $00001218 VOL: 0
;PCODE: $00001219 VOL: 0
;PCODE: $0000121A VOL: 0
;PCODE: $0000121B VOL: 0
;PCODE: $0000121C VOL: 0
;PCODE: $0000121D VOL: 0
;PCODE: $0000121E VOL: 0
;					if (clst == 0) return FR_DENIED;			/* No free cluster */
;PCODE: $0000121F VOL: 0
;PCODE: $00001220 VOL: 0
;PCODE: $00001221 VOL: 0
;PCODE: $00001222 VOL: 0
;PCODE: $00001223 VOL: 0
;PCODE: $00001224 VOL: 0
;PCODE: $00001225 VOL: 0
;PCODE: $00001226 VOL: 0
;PCODE: $00001227 VOL: 0
;PCODE: $00001228 VOL: 0
;PCODE: $00001229 VOL: 0
;					if (clst == 1) return FR_INT_ERR;
;PCODE: $0000122A VOL: 0
;PCODE: $0000122B VOL: 0
;PCODE: $0000122C VOL: 0
;PCODE: $0000122D VOL: 0
;PCODE: $0000122E VOL: 0
;PCODE: $0000122F VOL: 0
;PCODE: $00001230 VOL: 0
;PCODE: $00001231 VOL: 0
;PCODE: $00001232 VOL: 0
;PCODE: $00001233 VOL: 0
;PCODE: $00001234 VOL: 0
;PCODE: $00001235 VOL: 0
;					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;PCODE: $00001236 VOL: 0
;PCODE: $00001237 VOL: 0
;PCODE: $00001238 VOL: 0
;PCODE: $00001239 VOL: 0
;PCODE: $0000123A VOL: 0
;PCODE: $0000123B VOL: 0
;PCODE: $0000123C VOL: 0
;PCODE: $0000123D VOL: 0
;PCODE: $0000123E VOL: 0
;PCODE: $0000123F VOL: 0
;PCODE: $00001240 VOL: 0
;PCODE: $00001241 VOL: 0
;					/* Clean-up stretched table */
;					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
;PCODE: $00001242 VOL: 0
;PCODE: $00001243 VOL: 0
;PCODE: $00001244 VOL: 0
;PCODE: $00001245 VOL: 0
;PCODE: $00001246 VOL: 0
;PCODE: $00001247 VOL: 0
;PCODE: $00001248 VOL: 0
;PCODE: $00001249 VOL: 0
;PCODE: $0000124A VOL: 0
;PCODE: $0000124B VOL: 0
;PCODE: $0000124C VOL: 0
;PCODE: $0000124D VOL: 0
;PCODE: $0000124E VOL: 0
;PCODE: $0000124F VOL: 0
;PCODE: $00001250 VOL: 0
;					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
;PCODE: $00001251 VOL: 0
;PCODE: $00001252 VOL: 0
;PCODE: $00001253 VOL: 0
;PCODE: $00001254 VOL: 0
;PCODE: $00001255 VOL: 0
;PCODE: $00001256 VOL: 0
;PCODE: $00001257 VOL: 0
;PCODE: $00001258 VOL: 0
;PCODE: $00001259 VOL: 0
;					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;PCODE: $0000125A VOL: 0
;PCODE: $0000125B VOL: 0
;PCODE: $0000125C VOL: 0
;PCODE: $0000125D VOL: 0
;PCODE: $0000125E VOL: 0
;PCODE: $0000125F VOL: 0
;PCODE: $00001260 VOL: 0
;PCODE: $00001261 VOL: 0
;PCODE: $00001262 VOL: 0
;PCODE: $00001263 VOL: 0
;PCODE: $00001264 VOL: 0
;					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;PCODE: $00001265 VOL: 0
;PCODE: $00001266 VOL: 0
;PCODE: $00001267 VOL: 0
;PCODE: $00001268 VOL: 0
;PCODE: $00001269 VOL: 0
;PCODE: $0000126A VOL: 0
;PCODE: $0000126B VOL: 0
;PCODE: $0000126C VOL: 0
;PCODE: $0000126D VOL: 0
;PCODE: $0000126E VOL: 0
;PCODE: $0000126F VOL: 0
;PCODE: $00001270 VOL: 0
;PCODE: $00001271 VOL: 0
;						dp->fs->wflag = 1;
;PCODE: $00001272 VOL: 0
;PCODE: $00001273 VOL: 0
;PCODE: $00001274 VOL: 0
;PCODE: $00001275 VOL: 0
;PCODE: $00001276 VOL: 0
;						if (sync_window(dp->fs)) return FR_DISK_ERR;
;PCODE: $00001277 VOL: 0
;PCODE: $00001278 VOL: 0
;PCODE: $00001279 VOL: 0
;PCODE: $0000127A VOL: 0
;PCODE: $0000127B VOL: 0
;PCODE: $0000127C VOL: 0
;PCODE: $0000127D VOL: 0
;PCODE: $0000127E VOL: 0
;PCODE: $0000127F VOL: 0
;PCODE: $00001280 VOL: 0
;PCODE: $00001281 VOL: 0
;PCODE: $00001282 VOL: 0
;PCODE: $00001283 VOL: 0
;PCODE: $00001284 VOL: 0
;						dp->fs->winsect++;
;PCODE: $00001285 VOL: 0
;PCODE: $00001286 VOL: 0
;PCODE: $00001287 VOL: 0
;PCODE: $00001288 VOL: 0
;PCODE: $00001289 VOL: 0
;PCODE: $0000128A VOL: 0
;PCODE: $0000128B VOL: 0
;PCODE: $0000128C VOL: 0
;					}
;PCODE: $0000128D VOL: 0
;PCODE: $0000128E VOL: 0
;PCODE: $0000128F VOL: 0
;PCODE: $00001290 VOL: 0
;PCODE: $00001291 VOL: 0
;PCODE: $00001292 VOL: 0
;					dp->fs->winsect -= c;						/* Rewind window offset */
;PCODE: $00001293 VOL: 0
;PCODE: $00001294 VOL: 0
;PCODE: $00001295 VOL: 0
;PCODE: $00001296 VOL: 0
;PCODE: $00001297 VOL: 0
;PCODE: $00001298 VOL: 0
;PCODE: $00001299 VOL: 0
;PCODE: $0000129A VOL: 0
;PCODE: $0000129B VOL: 0
;PCODE: $0000129C VOL: 0
;PCODE: $0000129D VOL: 0
;PCODE: $0000129E VOL: 0
;PCODE: $0000129F VOL: 0
;PCODE: $000012A0 VOL: 0
;#else
;					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
;					return FR_NO_FILE;							/* Report EOT */
;#endif
;				}
;PCODE: $000012A1 VOL: 0
;				dp->clust = clst;				/* Initialize data for new cluster */
;PCODE: $000012A2 VOL: 0
;PCODE: $000012A3 VOL: 0
;PCODE: $000012A4 VOL: 0
;PCODE: $000012A5 VOL: 0
;				dp->sect = clust2sect(dp->fs, clst);
;PCODE: $000012A6 VOL: 0
;PCODE: $000012A7 VOL: 0
;PCODE: $000012A8 VOL: 0
;PCODE: $000012A9 VOL: 0
;PCODE: $000012AA VOL: 0
;PCODE: $000012AB VOL: 0
;PCODE: $000012AC VOL: 0
;			}
;		}
;PCODE: $000012AD VOL: 0
;PCODE: $000012AE VOL: 0
;	}
;
;	dp->index = i;	/* Current index */
;PCODE: $000012AF VOL: 0
;PCODE: $000012B0 VOL: 0
;PCODE: $000012B1 VOL: 0
;PCODE: $000012B2 VOL: 0
;	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
;PCODE: $000012B3 VOL: 0
;PCODE: $000012B4 VOL: 0
;PCODE: $000012B5 VOL: 0
;PCODE: $000012B6 VOL: 0
;PCODE: $000012B7 VOL: 0
;PCODE: $000012B8 VOL: 0
;PCODE: $000012B9 VOL: 0
;PCODE: $000012BA VOL: 0
;PCODE: $000012BB VOL: 0
;PCODE: $000012BC VOL: 0
;PCODE: $000012BD VOL: 0
;
;	return FR_OK;
;PCODE: $000012BE VOL: 0
;PCODE: $000012BF VOL: 0
;PCODE: $000012C0 VOL: 0
;PCODE: $000012C1 VOL: 0
;PCODE: $000012C2 VOL: 0
;PCODE: $000012C3 VOL: 0
;PCODE: $000012C4 VOL: 0
;}
;PCODE: $000012C5 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Reserve directory entry                          */
;/*-----------------------------------------------------------------------*/
;
;#if !_FS_READONLY
;static
;FRESULT dir_alloc (
;	DIR* dp,	/* Pointer to the directory object */
;	UINT nent	/* Number of contiguous entries to allocate (1-21) */
;)
;{
;PCODE: $000012C6 VOL: 0
;PCODE: $000012C7 VOL: 0
;	FRESULT res;
;	UINT n;
;
;
;	res = dir_sdi(dp, 0);
;PCODE: $000012C8 VOL: 0
;PCODE: $000012C9 VOL: 0
;	*dp -> Y+6
;	nent -> Y+4
;	res -> R17
;	n -> R18,R19
;PCODE: $000012CA VOL: 0
;PCODE: $000012CB VOL: 0
;PCODE: $000012CC VOL: 0
;PCODE: $000012CD VOL: 0
;PCODE: $000012CE VOL: 0
;PCODE: $000012CF VOL: 0
;	if (res == FR_OK) {
;PCODE: $000012D0 VOL: 0
;PCODE: $000012D1 VOL: 0
;		n = 0;
;PCODE: $000012D2 VOL: 0
;PCODE: $000012D3 VOL: 0
;		do {
;PCODE: $000012D4 VOL: 0
;			res = move_window(dp->fs, dp->sect);
;PCODE: $000012D5 VOL: 0
;PCODE: $000012D6 VOL: 0
;PCODE: $000012D7 VOL: 0
;PCODE: $000012D8 VOL: 0
;PCODE: $000012D9 VOL: 0
;PCODE: $000012DA VOL: 0
;PCODE: $000012DB VOL: 0
;			if (res != FR_OK) break;
;PCODE: $000012DC VOL: 0
;PCODE: $000012DD VOL: 0
;PCODE: $000012DE VOL: 0
;			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
;PCODE: $000012DF VOL: 0
;PCODE: $000012E0 VOL: 0
;PCODE: $000012E1 VOL: 0
;PCODE: $000012E2 VOL: 0
;PCODE: $000012E3 VOL: 0
;PCODE: $000012E4 VOL: 0
;PCODE: $000012E5 VOL: 0
;PCODE: $000012E6 VOL: 0
;PCODE: $000012E7 VOL: 0
;PCODE: $000012E8 VOL: 0
;PCODE: $000012E9 VOL: 0
;PCODE: $000012EA VOL: 0
;PCODE: $000012EB VOL: 0
;				if (++n == nent) break;	/* A block of contiguous entries is found */
;PCODE: $000012EC VOL: 0
;PCODE: $000012ED VOL: 0
;PCODE: $000012EE VOL: 0
;PCODE: $000012EF VOL: 0
;PCODE: $000012F0 VOL: 0
;PCODE: $000012F1 VOL: 0
;PCODE: $000012F2 VOL: 0
;PCODE: $000012F3 VOL: 0
;			} else {
;PCODE: $000012F4 VOL: 0
;PCODE: $000012F5 VOL: 0
;PCODE: $000012F6 VOL: 0
;				n = 0;					/* Not a blank entry. Restart to search */
;PCODE: $000012F7 VOL: 0
;PCODE: $000012F8 VOL: 0
;			}
;PCODE: $000012F9 VOL: 0
;			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
;PCODE: $000012FA VOL: 0
;PCODE: $000012FB VOL: 0
;PCODE: $000012FC VOL: 0
;PCODE: $000012FD VOL: 0
;PCODE: $000012FE VOL: 0
;PCODE: $000012FF VOL: 0
;		} while (res == FR_OK);
;PCODE: $00001300 VOL: 0
;PCODE: $00001301 VOL: 0
;PCODE: $00001302 VOL: 0
;PCODE: $00001303 VOL: 0
;PCODE: $00001304 VOL: 0
;	}
;	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
;PCODE: $00001305 VOL: 0
;PCODE: $00001306 VOL: 0
;PCODE: $00001307 VOL: 0
;PCODE: $00001308 VOL: 0
;PCODE: $00001309 VOL: 0
;PCODE: $0000130A VOL: 0
;	return res;
;PCODE: $0000130B VOL: 0
;PCODE: $0000130C VOL: 0
;PCODE: $0000130D VOL: 0
;PCODE: $0000130E VOL: 0
;PCODE: $0000130F VOL: 0
;}
;PCODE: $00001310 VOL: 0
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Load/Store start cluster number                  */
;/*-----------------------------------------------------------------------*/
;
;static
;DWORD ld_clust (
;	FATFS* fs,	/* Pointer to the fs object */
;	BYTE* dir	/* Pointer to the directory entry */
;)
;{
;PCODE: $00001311 VOL: 0
;PCODE: $00001312 VOL: 0
;	DWORD cl;
;
;	cl = LD_WORD(dir+DIR_FstClusLO);
;PCODE: $00001313 VOL: 0
;PCODE: $00001314 VOL: 0
;	*fs -> Y+6
;	*dir -> Y+4
;	cl -> Y+0
;PCODE: $00001315 VOL: 0
;PCODE: $00001316 VOL: 0
;PCODE: $00001317 VOL: 0
;PCODE: $00001318 VOL: 0
;PCODE: $00001319 VOL: 0
;PCODE: $0000131A VOL: 0
;PCODE: $0000131B VOL: 0
;PCODE: $0000131C VOL: 0
;PCODE: $0000131D VOL: 0
;PCODE: $0000131E VOL: 0
;	if (fs->fs_type == FS_FAT32)
;PCODE: $0000131F VOL: 0
;PCODE: $00001320 VOL: 0
;PCODE: $00001321 VOL: 0
;PCODE: $00001322 VOL: 0
;		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
;PCODE: $00001323 VOL: 0
;PCODE: $00001324 VOL: 0
;PCODE: $00001325 VOL: 0
;PCODE: $00001326 VOL: 0
;PCODE: $00001327 VOL: 0
;PCODE: $00001328 VOL: 0
;PCODE: $00001329 VOL: 0
;PCODE: $0000132A VOL: 0
;PCODE: $0000132B VOL: 0
;PCODE: $0000132C VOL: 0
;PCODE: $0000132D VOL: 0
;PCODE: $0000132E VOL: 0
;PCODE: $0000132F VOL: 0
;
;	return cl;
;PCODE: $00001330 VOL: 0
;PCODE: $00001331 VOL: 0
;PCODE: $00001332 VOL: 0
;PCODE: $00001333 VOL: 0
;}
;PCODE: $00001334 VOL: 0
;
;
;#if !_FS_READONLY
;static
;void st_clust (
;	BYTE* dir,	/* Pointer to the directory entry */
;	DWORD cl	/* Value to be set */
;)
;{
;PCODE: $00001335 VOL: 0
;PCODE: $00001336 VOL: 0
;	ST_WORD(dir+DIR_FstClusLO, cl);
;PCODE: $00001337 VOL: 0
;	*dir -> Y+4
;	cl -> Y+0
;PCODE: $00001338 VOL: 0
;PCODE: $00001339 VOL: 0
;PCODE: $0000133A VOL: 0
;PCODE: $0000133B VOL: 0
;PCODE: $0000133C VOL: 0
;PCODE: $0000133D VOL: 0
;	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
;PCODE: $0000133E VOL: 0
;PCODE: $0000133F VOL: 0
;PCODE: $00001340 VOL: 0
;PCODE: $00001341 VOL: 0
;PCODE: $00001342 VOL: 0
;PCODE: $00001343 VOL: 0
;PCODE: $00001344 VOL: 0
;PCODE: $00001345 VOL: 0
;PCODE: $00001346 VOL: 0
;PCODE: $00001347 VOL: 0
;}
;PCODE: $00001348 VOL: 0
;PCODE: $00001349 VOL: 0
;PCODE: $0000134A VOL: 0
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
;/*-----------------------------------------------------------------------*/
;#if _USE_LFN
;static
;const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
;
;
;static
;int cmp_lfn (			/* 1:Matched, 0:Not matched */
;	WCHAR* lfnbuf,		/* Pointer to the LFN to be compared */
;	BYTE* dir			/* Pointer to the directory entry containing a part of LFN */
;)
;{
;	UINT i, s;
;	WCHAR wc, uc;
;
;
;	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
;	s = 0; wc = 1;
;	do {
;		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
;		if (wc) {	/* Last character has not been processed */
;			wc = ff_wtoupper(uc);		/* Convert it to upper case */
;			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
;				return 0;				/* Not matched */
;		} else {
;			if (uc != 0xFFFF) return 0;	/* Check filler */
;		}
;	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
;
;	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
;		return 0;
;
;	return 1;						/* The part of LFN matched */
;}
;
;
;
;static
;int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
;	WCHAR* lfnbuf,		/* Pointer to the Unicode-LFN buffer */
;	BYTE* dir			/* Pointer to the directory entry */
;)
;{
;	UINT i, s;
;	WCHAR wc, uc;
;
;
;	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
;
;	s = 0; wc = 1;
;	do {
;		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
;		if (wc) {	/* Last character has not been processed */
;			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
;			lfnbuf[i++] = wc = uc;			/* Store it */
;		} else {
;			if (uc != 0xFFFF) return 0;		/* Check filler */
;		}
;	} while (++s < 13);						/* Read all character in the entry */
;
;	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
;		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
;		lfnbuf[i] = 0;
;	}
;
;	return 1;
;}
;
;
;#if !_FS_READONLY
;static
;void fit_lfn (
;	const WCHAR* lfnbuf,	/* Pointer to the LFN buffer */
;	BYTE* dir,				/* Pointer to the directory entry */
;	BYTE ord,				/* LFN order (1-20) */
;	BYTE sum				/* SFN sum */
;)
;{
;	UINT i, s;
;	WCHAR wc;
;
;
;	dir[LDIR_Chksum] = sum;			/* Set check sum */
;	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
;	dir[LDIR_Type] = 0;
;	ST_WORD(dir+LDIR_FstClusLO, 0);
;
;	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
;	s = wc = 0;
;	do {
;		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
;		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
;		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
;	} while (++s < 13);
;	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
;	dir[LDIR_Ord] = ord;			/* Set the LFN order */
;}
;
;#endif
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Create numbered name                                                  */
;/*-----------------------------------------------------------------------*/
;#if _USE_LFN
;void gen_numname (
;	BYTE* dst,			/* Pointer to generated SFN */
;	const BYTE* src,	/* Pointer to source SFN to be modified */
;	const WCHAR* lfn,	/* Pointer to LFN */
;	WORD seq			/* Sequence number */
;)
;{
;	BYTE ns[8], c;
;	UINT i, j;
;
;
;	mem_cpy(dst, src, 11);
;
;	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
;		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
;	}
;
;	/* itoa (hexdecimal) */
;	i = 7;
;	do {
;		c = (seq % 16) + '0';
;		if (c > '9') c += 7;
;		ns[i--] = c;
;		seq /= 16;
;	} while (seq);
;	ns[i] = '~';
;
;	/* Append the number */
;	for (j = 0; j < i && dst[j] != ' '; j++) {
;		if (IsDBCS1(dst[j])) {
;			if (j == i - 1) break;
;			j++;
;		}
;	}
;	do {
;		dst[j++] = (i < 8) ? ns[i++] : ' ';
;	} while (j < 8);
;}
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Calculate sum of an SFN                                               */
;/*-----------------------------------------------------------------------*/
;#if _USE_LFN
;static
;BYTE sum_sfn (
;	const BYTE* dir		/* Pointer to the SFN entry */
;)
;{
;	BYTE sum = 0;
;	UINT n = 11;
;
;	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
;	return sum;
;}
;#endif
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Directory handling - Find an object in the directory                  */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT dir_find (
;	DIR* dp			/* Pointer to the directory object linked to the file name */
;)
;{
;PCODE: $0000134B VOL: 0
;PCODE: $0000134C VOL: 0
;	FRESULT res;
;	BYTE c, *dir;
;#if _USE_LFN
;	BYTE a, ord, sum;
;#endif
;
;	res = dir_sdi(dp, 0);			/* Rewind directory object */
;PCODE: $0000134D VOL: 0
;PCODE: $0000134E VOL: 0
;	*dp -> Y+4
;	res -> R17
;	c -> R16
;	*dir -> R18,R19
;PCODE: $0000134F VOL: 0
;PCODE: $00001350 VOL: 0
;PCODE: $00001351 VOL: 0
;PCODE: $00001352 VOL: 0
;PCODE: $00001353 VOL: 0
;PCODE: $00001354 VOL: 0
;	if (res != FR_OK) return res;
;PCODE: $00001355 VOL: 0
;PCODE: $00001356 VOL: 0
;PCODE: $00001357 VOL: 0
;PCODE: $00001358 VOL: 0
;PCODE: $00001359 VOL: 0
;PCODE: $0000135A VOL: 0
;
;#if _USE_LFN
;	ord = sum = 0xFF;
;#endif
;	do {
;PCODE: $0000135B VOL: 0
;PCODE: $0000135C VOL: 0
;		res = move_window(dp->fs, dp->sect);
;PCODE: $0000135D VOL: 0
;PCODE: $0000135E VOL: 0
;PCODE: $0000135F VOL: 0
;PCODE: $00001360 VOL: 0
;PCODE: $00001361 VOL: 0
;PCODE: $00001362 VOL: 0
;PCODE: $00001363 VOL: 0
;		if (res != FR_OK) break;
;PCODE: $00001364 VOL: 0
;PCODE: $00001365 VOL: 0
;PCODE: $00001366 VOL: 0
;		dir = dp->dir;					/* Ptr to the directory entry of current index */
;PCODE: $00001367 VOL: 0
;PCODE: $00001368 VOL: 0
;PCODE: $00001369 VOL: 0
;PCODE: $0000136A VOL: 0
;		c = dir[DIR_Name];
;PCODE: $0000136B VOL: 0
;PCODE: $0000136C VOL: 0
;		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;PCODE: $0000136D VOL: 0
;PCODE: $0000136E VOL: 0
;PCODE: $0000136F VOL: 0
;PCODE: $00001370 VOL: 0
;PCODE: $00001371 VOL: 0
;#if _USE_LFN	/* LFN configuration */
;		a = dir[DIR_Attr] & AM_MASK;
;		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;			ord = 0xFF;
;		} else {
;			if (a == AM_LFN) {			/* An LFN entry is found */
;				if (dp->lfn) {
;					if (c & LLE) {		/* Is it start of LFN sequence? */
;						sum = dir[LDIR_Chksum];
;						c &= ~LLE; ord = c;	/* LFN start order */
;						dp->lfn_idx = dp->index;
;					}
;					/* Check validity of the LFN entry and compare it with given name */
;					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;				}
;			} else {					/* An SFN entry is found */
;				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
;				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
;			}
;		}
;#else		/* Non LFN configuration */
;		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
;PCODE: $00001372 VOL: 0
;PCODE: $00001373 VOL: 0
;PCODE: $00001374 VOL: 0
;PCODE: $00001375 VOL: 0
;PCODE: $00001376 VOL: 0
;PCODE: $00001377 VOL: 0
;PCODE: $00001378 VOL: 0
;PCODE: $00001379 VOL: 0
;PCODE: $0000137A VOL: 0
;PCODE: $0000137B VOL: 0
;PCODE: $0000137C VOL: 0
;PCODE: $0000137D VOL: 0
;PCODE: $0000137E VOL: 0
;PCODE: $0000137F VOL: 0
;PCODE: $00001380 VOL: 0
;PCODE: $00001381 VOL: 0
;PCODE: $00001382 VOL: 0
;PCODE: $00001383 VOL: 0
;			break;
;PCODE: $00001384 VOL: 0
;#endif
;		res = dir_next(dp, 0);		/* Next entry */
;PCODE: $00001385 VOL: 0
;PCODE: $00001386 VOL: 0
;PCODE: $00001387 VOL: 0
;PCODE: $00001388 VOL: 0
;PCODE: $00001389 VOL: 0
;PCODE: $0000138A VOL: 0
;PCODE: $0000138B VOL: 0
;	} while (res == FR_OK);
;PCODE: $0000138C VOL: 0
;PCODE: $0000138D VOL: 0
;PCODE: $0000138E VOL: 0
;PCODE: $0000138F VOL: 0
;PCODE: $00001390 VOL: 0
;
;	return res;
;PCODE: $00001391 VOL: 0
;PCODE: $00001392 VOL: 0
;PCODE: $00001393 VOL: 0
;PCODE: $00001394 VOL: 0
;}
;PCODE: $00001395 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read an object from the directory                                     */
;/*-----------------------------------------------------------------------*/
;#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
;static
;FRESULT dir_read (
;	DIR* dp,		/* Pointer to the directory object */
;	int vol			/* Filtered by 0:file/directory or 1:volume label */
;)
;{
;PCODE: $00001396 VOL: 0
;PCODE: $00001397 VOL: 0
;	FRESULT res;
;	BYTE a, c, *dir;
;#if _USE_LFN
;	BYTE ord = 0xFF, sum = 0xFF;
;#endif
;
;	res = FR_NO_FILE;
;PCODE: $00001398 VOL: 0
;PCODE: $00001399 VOL: 0
;	*dp -> Y+8
;	vol -> Y+6
;	res -> R17
;	a -> R16
;	c -> R19
;	*dir -> R20,R21
;PCODE: $0000139A VOL: 0
;PCODE: $0000139B VOL: 0
;	while (dp->sect) {
;PCODE: $0000139C VOL: 0
;PCODE: $0000139D VOL: 0
;PCODE: $0000139E VOL: 0
;PCODE: $0000139F VOL: 0
;PCODE: $000013A0 VOL: 0
;PCODE: $000013A1 VOL: 0
;		res = move_window(dp->fs, dp->sect);
;PCODE: $000013A2 VOL: 0
;PCODE: $000013A3 VOL: 0
;PCODE: $000013A4 VOL: 0
;PCODE: $000013A5 VOL: 0
;PCODE: $000013A6 VOL: 0
;PCODE: $000013A7 VOL: 0
;PCODE: $000013A8 VOL: 0
;		if (res != FR_OK) break;
;PCODE: $000013A9 VOL: 0
;PCODE: $000013AA VOL: 0
;PCODE: $000013AB VOL: 0
;		dir = dp->dir;					/* Ptr to the directory entry of current index */
;PCODE: $000013AC VOL: 0
;PCODE: $000013AD VOL: 0
;PCODE: $000013AE VOL: 0
;PCODE: $000013AF VOL: 0
;		c = dir[DIR_Name];
;PCODE: $000013B0 VOL: 0
;PCODE: $000013B1 VOL: 0
;		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;PCODE: $000013B2 VOL: 0
;PCODE: $000013B3 VOL: 0
;PCODE: $000013B4 VOL: 0
;PCODE: $000013B5 VOL: 0
;PCODE: $000013B6 VOL: 0
;		a = dir[DIR_Attr] & AM_MASK;
;PCODE: $000013B7 VOL: 0
;PCODE: $000013B8 VOL: 0
;PCODE: $000013B9 VOL: 0
;PCODE: $000013BA VOL: 0
;PCODE: $000013BB VOL: 0
;#if _USE_LFN	/* LFN configuration */
;		if (c == DDE || (!_FS_RPATH && c == '.') || (int)(a == AM_VOL) != vol) {	/* An entry without valid data */
;			ord = 0xFF;
;		} else {
;			if (a == AM_LFN) {			/* An LFN entry is found */
;				if (c & LLE) {			/* Is it start of LFN sequence? */
;					sum = dir[LDIR_Chksum];
;					c &= ~LLE; ord = c;
;					dp->lfn_idx = dp->index;
;				}
;				/* Check LFN validity and capture it */
;				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;			} else {					/* An SFN entry is found */
;				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;				break;
;			}
;		}
;#else		/* Non LFN configuration */
;		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)(a == AM_VOL) == vol)	/* Is it a valid entry? */
;PCODE: $000013BC VOL: 0
;PCODE: $000013BD VOL: 0
;PCODE: $000013BE VOL: 0
;PCODE: $000013BF VOL: 0
;PCODE: $000013C0 VOL: 0
;PCODE: $000013C1 VOL: 0
;PCODE: $000013C2 VOL: 0
;PCODE: $000013C3 VOL: 0
;PCODE: $000013C4 VOL: 0
;PCODE: $000013C5 VOL: 0
;PCODE: $000013C6 VOL: 0
;PCODE: $000013C7 VOL: 0
;PCODE: $000013C8 VOL: 0
;PCODE: $000013C9 VOL: 0
;PCODE: $000013CA VOL: 0
;PCODE: $000013CB VOL: 0
;PCODE: $000013CC VOL: 0
;PCODE: $000013CD VOL: 0
;PCODE: $000013CE VOL: 0
;PCODE: $000013CF VOL: 0
;PCODE: $000013D0 VOL: 0
;PCODE: $000013D1 VOL: 0
;PCODE: $000013D2 VOL: 0
;PCODE: $000013D3 VOL: 0
;PCODE: $000013D4 VOL: 0
;PCODE: $000013D5 VOL: 0
;			break;
;PCODE: $000013D6 VOL: 0
;#endif
;		res = dir_next(dp, 0);				/* Next entry */
;PCODE: $000013D7 VOL: 0
;PCODE: $000013D8 VOL: 0
;PCODE: $000013D9 VOL: 0
;PCODE: $000013DA VOL: 0
;PCODE: $000013DB VOL: 0
;PCODE: $000013DC VOL: 0
;PCODE: $000013DD VOL: 0
;		if (res != FR_OK) break;
;PCODE: $000013DE VOL: 0
;PCODE: $000013DF VOL: 0
;PCODE: $000013E0 VOL: 0
;	}
;PCODE: $000013E1 VOL: 0
;PCODE: $000013E2 VOL: 0
;PCODE: $000013E3 VOL: 0
;
;	if (res != FR_OK) dp->sect = 0;
;PCODE: $000013E4 VOL: 0
;PCODE: $000013E5 VOL: 0
;PCODE: $000013E6 VOL: 0
;PCODE: $000013E7 VOL: 0
;PCODE: $000013E8 VOL: 0
;PCODE: $000013E9 VOL: 0
;
;	return res;
;PCODE: $000013EA VOL: 0
;PCODE: $000013EB VOL: 0
;PCODE: $000013EC VOL: 0
;PCODE: $000013ED VOL: 0
;PCODE: $000013EE VOL: 0
;}
;PCODE: $000013EF VOL: 0
;#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Register an object to the directory                                   */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY
;static
;FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
;	DIR* dp				/* Target directory with object name to be created */
;)
;{
;PCODE: $000013F0 VOL: 0
;PCODE: $000013F1 VOL: 0
;	FRESULT res;
;#if _USE_LFN	/* LFN configuration */
;	WORD n, ne;
;	BYTE sn[12], *fn, sum;
;	WCHAR *lfn;
;
;
;	fn = dp->fn; lfn = dp->lfn;
;	mem_cpy(sn, fn, 12);
;
;	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
;		return FR_INVALID_NAME;
;
;	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
;		for (n = 1; n < 100; n++) {
;			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;			if (res != FR_OK) break;
;		}
;		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;		fn[NS] = sn[NS]; dp->lfn = lfn;
;	}
;
;	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
;		for (n = 0; lfn[n]; n++) ;
;		ne = (n + 25) / 13;
;	} else {						/* Otherwise allocate an entry for an SFN  */
;		ne = 1;
;	}
;	res = dir_alloc(dp, ne);		/* Allocate entries */
;
;	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
;		res = dir_sdi(dp, (WORD)(dp->index - ne));
;		if (res == FR_OK) {
;			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
;			do {					/* Store LFN entries in bottom first */
;				res = move_window(dp->fs, dp->sect);
;				if (res != FR_OK) break;
;				fit_lfn(dp->lfn, dp->dir, (BYTE)ne, sum);
;				dp->fs->wflag = 1;
;				res = dir_next(dp, 0);	/* Next entry */
;			} while (res == FR_OK && --ne);
;		}
;	}
;#else	/* Non LFN configuration */
;	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
;PCODE: $000013F2 VOL: 0
;PCODE: $000013F3 VOL: 0
;	*dp -> Y+1
;	res -> R17
;PCODE: $000013F4 VOL: 0
;PCODE: $000013F5 VOL: 0
;PCODE: $000013F6 VOL: 0
;PCODE: $000013F7 VOL: 0
;PCODE: $000013F8 VOL: 0
;PCODE: $000013F9 VOL: 0
;#endif
;
;	if (res == FR_OK) {				/* Set SFN entry */
;PCODE: $000013FA VOL: 0
;PCODE: $000013FB VOL: 0
;		res = move_window(dp->fs, dp->sect);
;PCODE: $000013FC VOL: 0
;PCODE: $000013FD VOL: 0
;PCODE: $000013FE VOL: 0
;PCODE: $000013FF VOL: 0
;PCODE: $00001400 VOL: 0
;PCODE: $00001401 VOL: 0
;PCODE: $00001402 VOL: 0
;		if (res == FR_OK) {
;PCODE: $00001403 VOL: 0
;PCODE: $00001404 VOL: 0
;			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
;PCODE: $00001405 VOL: 0
;PCODE: $00001406 VOL: 0
;PCODE: $00001407 VOL: 0
;PCODE: $00001408 VOL: 0
;PCODE: $00001409 VOL: 0
;PCODE: $0000140A VOL: 0
;PCODE: $0000140B VOL: 0
;PCODE: $0000140C VOL: 0
;			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
;PCODE: $0000140D VOL: 0
;PCODE: $0000140E VOL: 0
;PCODE: $0000140F VOL: 0
;PCODE: $00001410 VOL: 0
;PCODE: $00001411 VOL: 0
;PCODE: $00001412 VOL: 0
;PCODE: $00001413 VOL: 0
;PCODE: $00001414 VOL: 0
;PCODE: $00001415 VOL: 0
;#if _USE_LFN
;			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
;#endif
;			dp->fs->wflag = 1;
;PCODE: $00001416 VOL: 0
;PCODE: $00001417 VOL: 0
;PCODE: $00001418 VOL: 0
;PCODE: $00001419 VOL: 0
;PCODE: $0000141A VOL: 0
;		}
;	}
;PCODE: $0000141B VOL: 0
;
;	return res;
;PCODE: $0000141C VOL: 0
;PCODE: $0000141D VOL: 0
;PCODE: $0000141E VOL: 0
;PCODE: $0000141F VOL: 0
;PCODE: $00001420 VOL: 0
;PCODE: $00001421 VOL: 0
;}
;PCODE: $00001422 VOL: 0
;#endif /* !_FS_READONLY */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Remove an object from the directory                                   */
;/*-----------------------------------------------------------------------*/
;#if !_FS_READONLY && !_FS_MINIMIZE
;static
;FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
;	DIR* dp				/* Directory object pointing the entry to be removed */
;)
;{
;PCODE: $00001423 VOL: 0
;PCODE: $00001424 VOL: 0
;	FRESULT res;
;#if _USE_LFN	/* LFN configuration */
;	WORD i;
;
;	i = dp->index;	/* SFN index */
;	res = dir_sdi(dp, (WORD)((dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx));	/* Goto the SFN or top of the LFN entries */
;	if (res == FR_OK) {
;		do {
;			res = move_window(dp->fs, dp->sect);
;			if (res != FR_OK) break;
;			*dp->dir = DDE;			/* Mark the entry "deleted" */
;			dp->fs->wflag = 1;
;			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;			res = dir_next(dp, 0);		/* Next entry */
;		} while (res == FR_OK);
;		if (res == FR_NO_FILE) res = FR_INT_ERR;
;	}
;
;#else			/* Non LFN configuration */
;	res = dir_sdi(dp, dp->index);
;PCODE: $00001425 VOL: 0
;PCODE: $00001426 VOL: 0
;	*dp -> Y+1
;	res -> R17
;PCODE: $00001427 VOL: 0
;PCODE: $00001428 VOL: 0
;PCODE: $00001429 VOL: 0
;PCODE: $0000142A VOL: 0
;PCODE: $0000142B VOL: 0
;PCODE: $0000142C VOL: 0
;	if (res == FR_OK) {
;PCODE: $0000142D VOL: 0
;PCODE: $0000142E VOL: 0
;		res = move_window(dp->fs, dp->sect);
;PCODE: $0000142F VOL: 0
;PCODE: $00001430 VOL: 0
;PCODE: $00001431 VOL: 0
;PCODE: $00001432 VOL: 0
;PCODE: $00001433 VOL: 0
;PCODE: $00001434 VOL: 0
;PCODE: $00001435 VOL: 0
;		if (res == FR_OK) {
;PCODE: $00001436 VOL: 0
;PCODE: $00001437 VOL: 0
;			*dp->dir = DDE;			/* Mark the entry "deleted" */
;PCODE: $00001438 VOL: 0
;PCODE: $00001439 VOL: 0
;PCODE: $0000143A VOL: 0
;PCODE: $0000143B VOL: 0
;			dp->fs->wflag = 1;
;PCODE: $0000143C VOL: 0
;PCODE: $0000143D VOL: 0
;PCODE: $0000143E VOL: 0
;PCODE: $0000143F VOL: 0
;PCODE: $00001440 VOL: 0
;		}
;	}
;PCODE: $00001441 VOL: 0
;#endif
;
;	return res;
;PCODE: $00001442 VOL: 0
;PCODE: $00001443 VOL: 0
;PCODE: $00001444 VOL: 0
;PCODE: $00001445 VOL: 0
;PCODE: $00001446 VOL: 0
;PCODE: $00001447 VOL: 0
;}
;PCODE: $00001448 VOL: 0
;#endif /* !_FS_READONLY */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Pick a segment and create the object name in directory form           */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT create_name (
;	DIR* dp,			/* Pointer to the directory object */
;	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;)
;{
;PCODE: $00001449 VOL: 0
;PCODE: $0000144A VOL: 0
;#if _USE_LFN	/* LFN configuration */
;	BYTE b, cf;
;	WCHAR w, *lfn;
;	UINT i, ni, si, di;
;	const TCHAR *p;
;
;	/* Create LFN in Unicode */
;	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;	lfn = dp->lfn;
;	si = di = 0;
;	for (;;) {
;		w = p[si++];					/* Get a character */
;		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;		if (di >= _MAX_LFN)				/* Reject too long name */
;			return FR_INVALID_NAME;
;#if !_LFN_UNICODE
;		w &= 0xFF;
;		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;			b = (BYTE)p[si++];			/* Get 2nd byte */
;			if (!IsDBCS2(b))
;				return FR_INVALID_NAME;	/* Reject invalid sequence */
;			w = (w << 8) + b;			/* Create a DBC */
;		}
;		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;#endif
;		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
;			return FR_INVALID_NAME;
;		lfn[di++] = w;					/* Store the Unicode character */
;	}
;	*path = &p[si];						/* Return pointer to the next segment */
;	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;#if _FS_RPATH
;	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
;		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
;		lfn[di] = 0;
;		for (i = 0; i < 11; i++)
;			dp->fn[i] = (i < di) ? '.' : ' ';
;		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;		return FR_OK;
;	}
;#endif
;	while (di) {						/* Strip trailing spaces and dots */
;		w = lfn[di-1];
;		if (w != ' ' && w != '.') break;
;		di--;
;	}
;	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;
;	lfn[di] = 0;						/* LFN is created */
;
;	/* Create SFN in directory form */
;	mem_set(dp->fn, ' ', 11);
;	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;	if (si) cf |= NS_LOSS | NS_LFN;
;	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;
;	b = i = 0; ni = 8;
;	for (;;) {
;		w = lfn[si++];					/* Get an LFN character */
;		if (!w) break;					/* Break on end of the LFN */
;		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;			cf |= NS_LOSS | NS_LFN; continue;
;		}
;
;		if (i >= ni || si == di) {		/* Extension or end of SFN */
;			if (ni == 11) {				/* Long extension */
;				cf |= NS_LOSS | NS_LFN; break;
;			}
;			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;			if (si > di) break;			/* No extension */
;			si = di; i = 8; ni = 11;	/* Enter extension section */
;			b <<= 2; continue;
;		}
;
;		if (w >= 0x80) {				/* Non ASCII character */
;#ifdef _EXCVT
;			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;#else
;			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;#endif
;			cf |= NS_LFN;				/* Force create LFN entry */
;		}
;
;		if (_DF1S && w >= 0x100) {		/* Double byte character (always false on SBCS cfg) */
;			if (i >= ni - 1) {
;				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;			}
;			dp->fn[i++] = (BYTE)(w >> 8);
;		} else {						/* Single byte character */
;			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;			} else {
;				if (IsUpper(w)) {		/* ASCII large capital */
;					b |= 2;
;				} else {
;					if (IsLower(w)) {	/* ASCII small capital */
;						b |= 1; w -= 0x20;
;					}
;				}
;			}
;		}
;		dp->fn[i++] = (BYTE)w;
;	}
;
;	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
;
;	if (ni == 8) b <<= 2;
;	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;		cf |= NS_LFN;
;	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;	}
;
;	dp->fn[NS] = cf;	/* SFN is created */
;
;	return FR_OK;
;
;
;#else	/* Non-LFN configuration */
;	BYTE b, c, d, *sfn;
;	UINT ni, si, i;
;	const char *p;
;
;	/* Create file name in directory form */
;	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;PCODE: $0000144B VOL: 0
;PCODE: $0000144C VOL: 0
;PCODE: $0000144D VOL: 0
;	*dp -> Y+16
;	*path -> Y+14
;	b -> R17
;	c -> R16
;	d -> R19
;	*sfn -> R20,R21
;	ni -> Y+12
;	si -> Y+10
;	i -> Y+8
;	*p -> Y+6
;PCODE: $0000144E VOL: 0
;PCODE: $0000144F VOL: 0
;PCODE: $00001450 VOL: 0
;PCODE: $00001451 VOL: 0
;PCODE: $00001452 VOL: 0
;PCODE: $00001453 VOL: 0
;PCODE: $00001454 VOL: 0
;PCODE: $00001455 VOL: 0
;PCODE: $00001456 VOL: 0
;PCODE: $00001457 VOL: 0
;PCODE: $00001458 VOL: 0
;PCODE: $00001459 VOL: 0
;PCODE: $0000145A VOL: 0
;PCODE: $0000145B VOL: 0
;PCODE: $0000145C VOL: 0
;PCODE: $0000145D VOL: 0
;PCODE: $0000145E VOL: 0
;PCODE: $0000145F VOL: 0
;PCODE: $00001460 VOL: 0
;PCODE: $00001461 VOL: 0
;PCODE: $00001462 VOL: 0
;PCODE: $00001463 VOL: 0
;PCODE: $00001464 VOL: 0
;PCODE: $00001465 VOL: 0
;	sfn = dp->fn;
;PCODE: $00001466 VOL: 0
;PCODE: $00001467 VOL: 0
;PCODE: $00001468 VOL: 0
;	mem_set(sfn, ' ', 11);
;PCODE: $00001469 VOL: 0
;PCODE: $0000146A VOL: 0
;PCODE: $0000146B VOL: 0
;PCODE: $0000146C VOL: 0
;PCODE: $0000146D VOL: 0
;PCODE: $0000146E VOL: 0
;	si = i = b = 0; ni = 8;
;PCODE: $0000146F VOL: 0
;PCODE: $00001470 VOL: 0
;PCODE: $00001471 VOL: 0
;PCODE: $00001472 VOL: 0
;PCODE: $00001473 VOL: 0
;PCODE: $00001474 VOL: 0
;PCODE: $00001475 VOL: 0
;#if _FS_RPATH
;	if (p[si] == '.') { /* Is this a dot entry? */
;		for (;;) {
;			c = (BYTE)p[si++];
;			if (c != '.' || si >= 3) break;
;			sfn[i++] = c;
;		}
;		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;		*path = &p[si];									/* Return pointer to the next segment */
;		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;		return FR_OK;
;	}
;#endif
;	for (;;) {
;PCODE: $00001476 VOL: 0
;PCODE: $00001477 VOL: 0
;		c = (BYTE)p[si++];
;PCODE: $00001478 VOL: 0
;PCODE: $00001479 VOL: 0
;PCODE: $0000147A VOL: 0
;PCODE: $0000147B VOL: 0
;PCODE: $0000147C VOL: 0
;PCODE: $0000147D VOL: 0
;PCODE: $0000147E VOL: 0
;		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
;PCODE: $0000147F VOL: 0
;PCODE: $00001480 VOL: 0
;PCODE: $00001481 VOL: 0
;PCODE: $00001482 VOL: 0
;PCODE: $00001483 VOL: 0
;PCODE: $00001484 VOL: 0
;PCODE: $00001485 VOL: 0
;PCODE: $00001486 VOL: 0
;PCODE: $00001487 VOL: 0
;PCODE: $00001488 VOL: 0
;PCODE: $00001489 VOL: 0
;PCODE: $0000148A VOL: 0
;		if (c == '.' || i >= ni) {
;PCODE: $0000148B VOL: 0
;PCODE: $0000148C VOL: 0
;PCODE: $0000148D VOL: 0
;PCODE: $0000148E VOL: 0
;PCODE: $0000148F VOL: 0
;PCODE: $00001490 VOL: 0
;PCODE: $00001491 VOL: 0
;PCODE: $00001492 VOL: 0
;PCODE: $00001493 VOL: 0
;PCODE: $00001494 VOL: 0
;			if (ni != 8 || c != '.') return FR_INVALID_NAME;
;PCODE: $00001495 VOL: 0
;PCODE: $00001496 VOL: 0
;PCODE: $00001497 VOL: 0
;PCODE: $00001498 VOL: 0
;PCODE: $00001499 VOL: 0
;PCODE: $0000149A VOL: 0
;PCODE: $0000149B VOL: 0
;PCODE: $0000149C VOL: 0
;PCODE: $0000149D VOL: 0
;PCODE: $0000149E VOL: 0
;PCODE: $0000149F VOL: 0
;PCODE: $000014A0 VOL: 0
;			i = 8; ni = 11;
;PCODE: $000014A1 VOL: 0
;PCODE: $000014A2 VOL: 0
;PCODE: $000014A3 VOL: 0
;PCODE: $000014A4 VOL: 0
;PCODE: $000014A5 VOL: 0
;			b <<= 2; continue;
;PCODE: $000014A6 VOL: 0
;PCODE: $000014A7 VOL: 0
;		}
;		if (c >= 0x80) {				/* Extended character? */
;PCODE: $000014A8 VOL: 0
;PCODE: $000014A9 VOL: 0
;PCODE: $000014AA VOL: 0
;PCODE: $000014AB VOL: 0
;			b |= 3;						/* Eliminate NT flag */
;PCODE: $000014AC VOL: 0
;PCODE: $000014AD VOL: 0
;#ifdef _EXCVT
;			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;PCODE: $000014AE VOL: 0
;PCODE: $000014AF VOL: 0
;PCODE: $000014B0 VOL: 0
;PCODE: $000014B1 VOL: 0
;PCODE: $000014B2 VOL: 0
;#else
;#if !_DF1S
;			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;#endif
;#endif
;		}
;		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;PCODE: $000014B3 VOL: 0
;PCODE: $000014B4 VOL: 0
;			d = (BYTE)p[si++];			/* Get 2nd byte */
;PCODE: $000014B5 VOL: 0
;PCODE: $000014B6 VOL: 0
;PCODE: $000014B7 VOL: 0
;PCODE: $000014B8 VOL: 0
;PCODE: $000014B9 VOL: 0
;PCODE: $000014BA VOL: 0
;PCODE: $000014BB VOL: 0
;			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;PCODE: $000014BC VOL: 0
;PCODE: $000014BD VOL: 0
;PCODE: $000014BE VOL: 0
;PCODE: $000014BF VOL: 0
;PCODE: $000014C0 VOL: 0
;PCODE: $000014C1 VOL: 0
;PCODE: $000014C2 VOL: 0
;PCODE: $000014C3 VOL: 0
;PCODE: $000014C4 VOL: 0
;PCODE: $000014C5 VOL: 0
;				return FR_INVALID_NAME;
;PCODE: $000014C6 VOL: 0
;PCODE: $000014C7 VOL: 0
;PCODE: $000014C8 VOL: 0
;PCODE: $000014C9 VOL: 0
;			sfn[i++] = c;
;PCODE: $000014CA VOL: 0
;PCODE: $000014CB VOL: 0
;PCODE: $000014CC VOL: 0
;PCODE: $000014CD VOL: 0
;PCODE: $000014CE VOL: 0
;PCODE: $000014CF VOL: 0
;PCODE: $000014D0 VOL: 0
;			sfn[i++] = d;
;PCODE: $000014D1 VOL: 0
;PCODE: $000014D2 VOL: 0
;PCODE: $000014D3 VOL: 0
;PCODE: $000014D4 VOL: 0
;PCODE: $000014D5 VOL: 0
;PCODE: $000014D6 VOL: 0
;		} else {						/* Single byte code */
;PCODE: $000014D7 VOL: 0
;PCODE: $000014D8 VOL: 0
;			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;PCODE: $000014D9 VOL: 0
;PCODE: $000014DA VOL: 0
;PCODE: $000014DB VOL: 0
;PCODE: $000014DC VOL: 0
;PCODE: $000014DD VOL: 0
;PCODE: $000014DE VOL: 0
;PCODE: $000014DF VOL: 0
;PCODE: $000014E0 VOL: 0
;				return FR_INVALID_NAME;
;PCODE: $000014E1 VOL: 0
;PCODE: $000014E2 VOL: 0
;PCODE: $000014E3 VOL: 0
;PCODE: $000014E4 VOL: 0
;			if (IsUpper(c)) {			/* ASCII large capital? */
;PCODE: $000014E5 VOL: 0
;PCODE: $000014E6 VOL: 0
;PCODE: $000014E7 VOL: 0
;PCODE: $000014E8 VOL: 0
;PCODE: $000014E9 VOL: 0
;PCODE: $000014EA VOL: 0
;PCODE: $000014EB VOL: 0
;PCODE: $000014EC VOL: 0
;PCODE: $000014ED VOL: 0
;PCODE: $000014EE VOL: 0
;PCODE: $000014EF VOL: 0
;				b |= 2;
;PCODE: $000014F0 VOL: 0
;PCODE: $000014F1 VOL: 0
;			} else {
;PCODE: $000014F2 VOL: 0
;PCODE: $000014F3 VOL: 0
;				if (IsLower(c)) {		/* ASCII small capital? */
;PCODE: $000014F4 VOL: 0
;PCODE: $000014F5 VOL: 0
;PCODE: $000014F6 VOL: 0
;PCODE: $000014F7 VOL: 0
;PCODE: $000014F8 VOL: 0
;PCODE: $000014F9 VOL: 0
;PCODE: $000014FA VOL: 0
;PCODE: $000014FB VOL: 0
;PCODE: $000014FC VOL: 0
;PCODE: $000014FD VOL: 0
;					b |= 1; c -= 0x20;
;PCODE: $000014FE VOL: 0
;PCODE: $000014FF VOL: 0
;PCODE: $00001500 VOL: 0
;PCODE: $00001501 VOL: 0
;				}
;			}
;PCODE: $00001502 VOL: 0
;PCODE: $00001503 VOL: 0
;			sfn[i++] = c;
;PCODE: $00001504 VOL: 0
;PCODE: $00001505 VOL: 0
;PCODE: $00001506 VOL: 0
;PCODE: $00001507 VOL: 0
;PCODE: $00001508 VOL: 0
;PCODE: $00001509 VOL: 0
;		}
;PCODE: $0000150A VOL: 0
;	}
;PCODE: $0000150B VOL: 0
;PCODE: $0000150C VOL: 0
;PCODE: $0000150D VOL: 0
;	*path = &p[si];						/* Return pointer to the next segment */
;PCODE: $0000150E VOL: 0
;PCODE: $0000150F VOL: 0
;PCODE: $00001510 VOL: 0
;PCODE: $00001511 VOL: 0
;PCODE: $00001512 VOL: 0
;	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;PCODE: $00001513 VOL: 0
;PCODE: $00001514 VOL: 0
;PCODE: $00001515 VOL: 0
;PCODE: $00001516 VOL: 0
;PCODE: $00001517 VOL: 0
;PCODE: $00001518 VOL: 0
;PCODE: $00001519 VOL: 0
;PCODE: $0000151A VOL: 0
;PCODE: $0000151B VOL: 0
;PCODE: $0000151C VOL: 0
;
;	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;PCODE: $0000151D VOL: 0
;PCODE: $0000151E VOL: 0
;PCODE: $0000151F VOL: 0
;PCODE: $00001520 VOL: 0
;PCODE: $00001521 VOL: 0
;PCODE: $00001522 VOL: 0
;PCODE: $00001523 VOL: 0
;	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
;PCODE: $00001524 VOL: 0
;PCODE: $00001525 VOL: 0
;PCODE: $00001526 VOL: 0
;PCODE: $00001527 VOL: 0
;PCODE: $00001528 VOL: 0
;PCODE: $00001529 VOL: 0
;PCODE: $0000152A VOL: 0
;PCODE: $0000152B VOL: 0
;
;	if (ni == 8) b <<= 2;
;PCODE: $0000152C VOL: 0
;PCODE: $0000152D VOL: 0
;PCODE: $0000152E VOL: 0
;PCODE: $0000152F VOL: 0
;PCODE: $00001530 VOL: 0
;	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;PCODE: $00001531 VOL: 0
;PCODE: $00001532 VOL: 0
;PCODE: $00001533 VOL: 0
;PCODE: $00001534 VOL: 0
;PCODE: $00001535 VOL: 0
;PCODE: $00001536 VOL: 0
;PCODE: $00001537 VOL: 0
;	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;PCODE: $00001538 VOL: 0
;PCODE: $00001539 VOL: 0
;PCODE: $0000153A VOL: 0
;PCODE: $0000153B VOL: 0
;PCODE: $0000153C VOL: 0
;PCODE: $0000153D VOL: 0
;PCODE: $0000153E VOL: 0
;
;	sfn[NS] = c;		/* Store NT flag, File name is created */
;PCODE: $0000153F VOL: 0
;PCODE: $00001540 VOL: 0
;PCODE: $00001541 VOL: 0
;PCODE: $00001542 VOL: 0
;
;	return FR_OK;
;PCODE: $00001543 VOL: 0
;PCODE: $00001544 VOL: 0
;PCODE: $00001545 VOL: 0
;PCODE: $00001546 VOL: 0
;#endif
;}
;PCODE: $00001547 VOL: 0

	.DSEG
_0x267:
	.BYTE 0xF
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get file information from directory entry                             */
;/*-----------------------------------------------------------------------*/
;#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
;static
;void get_fileinfo (		/* No return code */
;	DIR* dp,			/* Pointer to the directory object */
;	FILINFO* fno	 	/* Pointer to the file information to be filled */
;)
;{

	.CSEG
;PCODE: $00001548 VOL: 0
;PCODE: $00001549 VOL: 0
;	UINT i;
;	TCHAR *p, c;
;
;
;	p = fno->fname;
;PCODE: $0000154A VOL: 0
;PCODE: $0000154B VOL: 0
;	*dp -> Y+8
;	*fno -> Y+6
;	i -> R16,R17
;	*p -> R18,R19
;	c -> R21
;PCODE: $0000154C VOL: 0
;PCODE: $0000154D VOL: 0
;PCODE: $0000154E VOL: 0
;	if (dp->sect) {		/* Get SFN */
;PCODE: $0000154F VOL: 0
;PCODE: $00001550 VOL: 0
;PCODE: $00001551 VOL: 0
;PCODE: $00001552 VOL: 0
;PCODE: $00001553 VOL: 0
;		BYTE *dir = dp->dir;
;
;		i = 0;
;PCODE: $00001554 VOL: 0
;	*dp -> Y+10
;	*fno -> Y+8
;	*dir -> Y+0
;PCODE: $00001555 VOL: 0
;PCODE: $00001556 VOL: 0
;PCODE: $00001557 VOL: 0
;PCODE: $00001558 VOL: 0
;PCODE: $00001559 VOL: 0
;PCODE: $0000155A VOL: 0
;		while (i < 11) {		/* Copy name body and extension */
;PCODE: $0000155B VOL: 0
;PCODE: $0000155C VOL: 0
;PCODE: $0000155D VOL: 0
;PCODE: $0000155E VOL: 0
;			c = (TCHAR)dir[i++];
;PCODE: $0000155F VOL: 0
;PCODE: $00001560 VOL: 0
;PCODE: $00001561 VOL: 0
;PCODE: $00001562 VOL: 0
;PCODE: $00001563 VOL: 0
;PCODE: $00001564 VOL: 0
;			if (c == ' ') continue;			/* Skip padding spaces */
;PCODE: $00001565 VOL: 0
;PCODE: $00001566 VOL: 0
;PCODE: $00001567 VOL: 0
;PCODE: $00001568 VOL: 0
;			if (c == NDDE) c = (TCHAR)DDE;	/* Restore replaced DDE character */
;PCODE: $00001569 VOL: 0
;PCODE: $0000156A VOL: 0
;PCODE: $0000156B VOL: 0
;PCODE: $0000156C VOL: 0
;PCODE: $0000156D VOL: 0
;PCODE: $0000156E VOL: 0
;			if (i == 9) *p++ = '.';			/* Insert a . if extension is exist */
;PCODE: $0000156F VOL: 0
;PCODE: $00001570 VOL: 0
;PCODE: $00001571 VOL: 0
;PCODE: $00001572 VOL: 0
;PCODE: $00001573 VOL: 0
;PCODE: $00001574 VOL: 0
;PCODE: $00001575 VOL: 0
;PCODE: $00001576 VOL: 0
;PCODE: $00001577 VOL: 0
;#if _USE_LFN
;			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
;				c += 0x20;			/* To lower */
;#if _LFN_UNICODE
;			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;				c = c << 8 | dir[i++];
;			c = ff_convert(c, 1);	/* OEM -> Unicode */
;			if (!c) c = '?';
;#endif
;#endif
;			*p++ = c;
;PCODE: $00001578 VOL: 0
;PCODE: $00001579 VOL: 0
;PCODE: $0000157A VOL: 0
;PCODE: $0000157B VOL: 0
;PCODE: $0000157C VOL: 0
;PCODE: $0000157D VOL: 0
;PCODE: $0000157E VOL: 0
;		}
;PCODE: $0000157F VOL: 0
;PCODE: $00001580 VOL: 0
;		fno->fattrib = dir[DIR_Attr];				/* Attribute */
;PCODE: $00001581 VOL: 0
;PCODE: $00001582 VOL: 0
;PCODE: $00001583 VOL: 0
;PCODE: $00001584 VOL: 0
;		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
;PCODE: $00001585 VOL: 0
;PCODE: $00001586 VOL: 0
;PCODE: $00001587 VOL: 0
;PCODE: $00001588 VOL: 0
;PCODE: $00001589 VOL: 0
;PCODE: $0000158A VOL: 0
;PCODE: $0000158B VOL: 0
;PCODE: $0000158C VOL: 0
;PCODE: $0000158D VOL: 0
;PCODE: $0000158E VOL: 0
;PCODE: $0000158F VOL: 0
;PCODE: $00001590 VOL: 0
;PCODE: $00001591 VOL: 0
;PCODE: $00001592 VOL: 0
;PCODE: $00001593 VOL: 0
;PCODE: $00001594 VOL: 0
;PCODE: $00001595 VOL: 0
;PCODE: $00001596 VOL: 0
;PCODE: $00001597 VOL: 0
;PCODE: $00001598 VOL: 0
;PCODE: $00001599 VOL: 0
;PCODE: $0000159A VOL: 0
;PCODE: $0000159B VOL: 0
;PCODE: $0000159C VOL: 0
;PCODE: $0000159D VOL: 0
;PCODE: $0000159E VOL: 0
;PCODE: $0000159F VOL: 0
;PCODE: $000015A0 VOL: 0
;		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
;PCODE: $000015A1 VOL: 0
;PCODE: $000015A2 VOL: 0
;PCODE: $000015A3 VOL: 0
;PCODE: $000015A4 VOL: 0
;PCODE: $000015A5 VOL: 0
;PCODE: $000015A6 VOL: 0
;PCODE: $000015A7 VOL: 0
;PCODE: $000015A8 VOL: 0
;PCODE: $000015A9 VOL: 0
;PCODE: $000015AA VOL: 0
;		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
;PCODE: $000015AB VOL: 0
;PCODE: $000015AC VOL: 0
;PCODE: $000015AD VOL: 0
;PCODE: $000015AE VOL: 0
;PCODE: $000015AF VOL: 0
;PCODE: $000015B0 VOL: 0
;PCODE: $000015B1 VOL: 0
;PCODE: $000015B2 VOL: 0
;PCODE: $000015B3 VOL: 0
;PCODE: $000015B4 VOL: 0
;	}
;PCODE: $000015B5 VOL: 0
;	*p = 0;		/* Terminate SFN string by a \0 */
;PCODE: $000015B6 VOL: 0
;PCODE: $000015B7 VOL: 0
;PCODE: $000015B8 VOL: 0
;PCODE: $000015B9 VOL: 0
;
;#if _USE_LFN
;	if (fno->lfname) {
;		WCHAR w, *lfn;
;
;		i = 0; p = fno->lfname;
;		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
;			lfn = dp->lfn;
;			while ((w = *lfn++) != 0) {		/* Get an LFN character */
;#if !_LFN_UNICODE
;				w = ff_convert(w, 0);		/* Unicode -> OEM */
;				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
;				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;					p[i++] = (TCHAR)(w >> 8);
;#endif
;				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
;				p[i++] = (TCHAR)w;
;			}
;		}
;		p[i] = 0;	/* Terminate LFN string by a \0 */
;	}
;#endif
;}
;PCODE: $000015BA VOL: 0
;PCODE: $000015BB VOL: 0
;PCODE: $000015BC VOL: 0
;PCODE: $000015BD VOL: 0
;#endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Get logical drive number from path name                               */
;/*-----------------------------------------------------------------------*/
;
;static
;int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
;	const TCHAR** path	/* Pointer to pointer to the path name */
;)
;{
;PCODE: $000015BE VOL: 0
;PCODE: $000015BF VOL: 0
;	int vol = -1;
;
;
;	if (*path) {
;PCODE: $000015C0 VOL: 0
;PCODE: $000015C1 VOL: 0
;PCODE: $000015C2 VOL: 0
;	*path -> Y+2
;	vol -> R16,R17
;PCODE: $000015C3 VOL: 0
;PCODE: $000015C4 VOL: 0
;PCODE: $000015C5 VOL: 0
;PCODE: $000015C6 VOL: 0
;PCODE: $000015C7 VOL: 0
;PCODE: $000015C8 VOL: 0
;		vol = (*path)[0] - '0';
;PCODE: $000015C9 VOL: 0
;PCODE: $000015CA VOL: 0
;PCODE: $000015CB VOL: 0
;PCODE: $000015CC VOL: 0
;PCODE: $000015CD VOL: 0
;PCODE: $000015CE VOL: 0
;		if ((UINT)vol < 9 && (*path)[1] == ':') {	/* There is a drive number */
;PCODE: $000015CF VOL: 0
;PCODE: $000015D0 VOL: 0
;PCODE: $000015D1 VOL: 0
;PCODE: $000015D2 VOL: 0
;PCODE: $000015D3 VOL: 0
;PCODE: $000015D4 VOL: 0
;PCODE: $000015D5 VOL: 0
;PCODE: $000015D6 VOL: 0
;PCODE: $000015D7 VOL: 0
;PCODE: $000015D8 VOL: 0
;PCODE: $000015D9 VOL: 0
;PCODE: $000015DA VOL: 0
;			*path += 2;		/* Get value and strip it */
;PCODE: $000015DB VOL: 0
;PCODE: $000015DC VOL: 0
;PCODE: $000015DD VOL: 0
;PCODE: $000015DE VOL: 0
;			if (vol >= _VOLUMES) vol = -1;	/* Check if the drive number is valid */
;PCODE: $000015DF VOL: 0
;PCODE: $000015E0 VOL: 0
;PCODE: $000015E1 VOL: 0
;PCODE: $000015E2 VOL: 0
;PCODE: $000015E3 VOL: 0
;		} else {			/* No drive number use default drive */
;PCODE: $000015E4 VOL: 0
;PCODE: $000015E5 VOL: 0
;PCODE: $000015E6 VOL: 0
;#if _FS_RPATH && _VOLUMES >= 2
;			vol = CurrVol;	/* Current drive */
;#else
;			vol = 0;		/* Drive 0 */
;PCODE: $000015E7 VOL: 0
;PCODE: $000015E8 VOL: 0
;#endif
;		}
;PCODE: $000015E9 VOL: 0
;	}
;
;	return vol;
;PCODE: $000015EA VOL: 0
;PCODE: $000015EB VOL: 0
;PCODE: $000015EC VOL: 0
;PCODE: $000015ED VOL: 0
;PCODE: $000015EE VOL: 0
;PCODE: $000015EF VOL: 0
;PCODE: $000015F0 VOL: 0
;PCODE: $000015F1 VOL: 0
;}
;PCODE: $000015F2 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Follow a file path                                                    */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
;	DIR* dp,			/* Directory object to return last directory and found object */
;	const TCHAR* path	/* Full-path string to find a file or directory */
;)
;{
;PCODE: $000015F3 VOL: 0
;PCODE: $000015F4 VOL: 0
;	FRESULT res;
;	BYTE *dir, ns;
;
;
;#if _FS_RPATH
;	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
;		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;	} else {								/* No heading separator */
;		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
;	}
;#else
;	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
;PCODE: $000015F5 VOL: 0
;PCODE: $000015F6 VOL: 0
;	*dp -> Y+6
;	*path -> Y+4
;	res -> R17
;	*dir -> R18,R19
;	ns -> R16
;PCODE: $000015F7 VOL: 0
;PCODE: $000015F8 VOL: 0
;PCODE: $000015F9 VOL: 0
;PCODE: $000015FA VOL: 0
;PCODE: $000015FB VOL: 0
;PCODE: $000015FC VOL: 0
;PCODE: $000015FD VOL: 0
;PCODE: $000015FE VOL: 0
;PCODE: $000015FF VOL: 0
;PCODE: $00001600 VOL: 0
;		path++;
;PCODE: $00001601 VOL: 0
;PCODE: $00001602 VOL: 0
;PCODE: $00001603 VOL: 0
;	dp->sclust = 0;							/* Always start from the root directory */
;PCODE: $00001604 VOL: 0
;PCODE: $00001605 VOL: 0
;PCODE: $00001606 VOL: 0
;PCODE: $00001607 VOL: 0
;PCODE: $00001608 VOL: 0
;#endif
;
;	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
;PCODE: $00001609 VOL: 0
;PCODE: $0000160A VOL: 0
;PCODE: $0000160B VOL: 0
;PCODE: $0000160C VOL: 0
;PCODE: $0000160D VOL: 0
;		res = dir_sdi(dp, 0);
;PCODE: $0000160E VOL: 0
;PCODE: $0000160F VOL: 0
;PCODE: $00001610 VOL: 0
;PCODE: $00001611 VOL: 0
;PCODE: $00001612 VOL: 0
;PCODE: $00001613 VOL: 0
;		dp->dir = 0;
;PCODE: $00001614 VOL: 0
;PCODE: $00001615 VOL: 0
;PCODE: $00001616 VOL: 0
;PCODE: $00001617 VOL: 0
;	} else {								/* Follow path */
;PCODE: $00001618 VOL: 0
;PCODE: $00001619 VOL: 0
;		for (;;) {
;PCODE: $0000161A VOL: 0
;PCODE: $0000161B VOL: 0
;			res = create_name(dp, &path);	/* Get a segment name of the path */
;PCODE: $0000161C VOL: 0
;PCODE: $0000161D VOL: 0
;PCODE: $0000161E VOL: 0
;PCODE: $0000161F VOL: 0
;PCODE: $00001620 VOL: 0
;			if (res != FR_OK) break;
;PCODE: $00001621 VOL: 0
;PCODE: $00001622 VOL: 0
;PCODE: $00001623 VOL: 0
;			res = dir_find(dp);				/* Find an object with the sagment name */
;PCODE: $00001624 VOL: 0
;PCODE: $00001625 VOL: 0
;PCODE: $00001626 VOL: 0
;PCODE: $00001627 VOL: 0
;			ns = dp->fn[NS];
;PCODE: $00001628 VOL: 0
;PCODE: $00001629 VOL: 0
;PCODE: $0000162A VOL: 0
;PCODE: $0000162B VOL: 0
;PCODE: $0000162C VOL: 0
;			if (res != FR_OK) {				/* Failed to find the object */
;PCODE: $0000162D VOL: 0
;PCODE: $0000162E VOL: 0
;				if (res == FR_NO_FILE) {	/* Object is not found */
;PCODE: $0000162F VOL: 0
;PCODE: $00001630 VOL: 0
;PCODE: $00001631 VOL: 0
;					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;PCODE: $00001632 VOL: 0
;PCODE: $00001633 VOL: 0
;PCODE: $00001634 VOL: 0
;PCODE: $00001635 VOL: 0
;PCODE: $00001636 VOL: 0
;PCODE: $00001637 VOL: 0
;PCODE: $00001638 VOL: 0
;PCODE: $00001639 VOL: 0
;PCODE: $0000163A VOL: 0
;PCODE: $0000163B VOL: 0
;						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;PCODE: $0000163C VOL: 0
;PCODE: $0000163D VOL: 0
;PCODE: $0000163E VOL: 0
;PCODE: $0000163F VOL: 0
;PCODE: $00001640 VOL: 0
;PCODE: $00001641 VOL: 0
;PCODE: $00001642 VOL: 0
;PCODE: $00001643 VOL: 0
;						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;PCODE: $00001644 VOL: 0
;PCODE: $00001645 VOL: 0
;PCODE: $00001646 VOL: 0
;PCODE: $00001647 VOL: 0
;						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;PCODE: $00001648 VOL: 0
;PCODE: $00001649 VOL: 0
;PCODE: $0000164A VOL: 0
;					} else {							/* Could not find the object */
;PCODE: $0000164B VOL: 0
;PCODE: $0000164C VOL: 0
;						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;PCODE: $0000164D VOL: 0
;PCODE: $0000164E VOL: 0
;PCODE: $0000164F VOL: 0
;PCODE: $00001650 VOL: 0
;PCODE: $00001651 VOL: 0
;					}
;PCODE: $00001652 VOL: 0
;PCODE: $00001653 VOL: 0
;				}
;				break;
;PCODE: $00001654 VOL: 0
;PCODE: $00001655 VOL: 0
;			}
;			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;PCODE: $00001656 VOL: 0
;PCODE: $00001657 VOL: 0
;PCODE: $00001658 VOL: 0
;PCODE: $00001659 VOL: 0
;PCODE: $0000165A VOL: 0
;			dir = dp->dir;						/* Follow the sub-directory */
;PCODE: $0000165B VOL: 0
;PCODE: $0000165C VOL: 0
;PCODE: $0000165D VOL: 0
;PCODE: $0000165E VOL: 0
;			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;PCODE: $0000165F VOL: 0
;PCODE: $00001660 VOL: 0
;PCODE: $00001661 VOL: 0
;PCODE: $00001662 VOL: 0
;				res = FR_NO_PATH; break;
;PCODE: $00001663 VOL: 0
;PCODE: $00001664 VOL: 0
;PCODE: $00001665 VOL: 0
;			}
;			dp->sclust = ld_clust(dp->fs, dir);
;PCODE: $00001666 VOL: 0
;PCODE: $00001667 VOL: 0
;PCODE: $00001668 VOL: 0
;PCODE: $00001669 VOL: 0
;PCODE: $0000166A VOL: 0
;PCODE: $0000166B VOL: 0
;PCODE: $0000166C VOL: 0
;PCODE: $0000166D VOL: 0
;		}
;PCODE: $0000166E VOL: 0
;PCODE: $0000166F VOL: 0
;PCODE: $00001670 VOL: 0
;	}
;PCODE: $00001671 VOL: 0
;
;	return res;
;PCODE: $00001672 VOL: 0
;PCODE: $00001673 VOL: 0
;PCODE: $00001674 VOL: 0
;PCODE: $00001675 VOL: 0
;}
;PCODE: $00001676 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Load a sector and check if it is an FAT boot sector                   */
;/*-----------------------------------------------------------------------*/
;
;static
;BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
;	FATFS* fs,	/* File system object */
;	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;)
;{
;PCODE: $00001677 VOL: 0
;PCODE: $00001678 VOL: 0
;	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
;PCODE: $00001679 VOL: 0
;	*fs -> Y+4
;	sect -> Y+0
;PCODE: $0000167A VOL: 0
;PCODE: $0000167B VOL: 0
;PCODE: $0000167C VOL: 0
;PCODE: $0000167D VOL: 0
;PCODE: $0000167E VOL: 0
;PCODE: $0000167F VOL: 0
;PCODE: $00001680 VOL: 0
;PCODE: $00001681 VOL: 0
;	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
;PCODE: $00001682 VOL: 0
;PCODE: $00001683 VOL: 0
;PCODE: $00001684 VOL: 0
;PCODE: $00001685 VOL: 0
;PCODE: $00001686 VOL: 0
;PCODE: $00001687 VOL: 0
;		return 3;
;PCODE: $00001688 VOL: 0
;PCODE: $00001689 VOL: 0
;PCODE: $0000168A VOL: 0
;
;	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the secto ...
;PCODE: $0000168B VOL: 0
;PCODE: $0000168C VOL: 0
;PCODE: $0000168D VOL: 0
;PCODE: $0000168E VOL: 0
;PCODE: $0000168F VOL: 0
;PCODE: $00001690 VOL: 0
;PCODE: $00001691 VOL: 0
;PCODE: $00001692 VOL: 0
;PCODE: $00001693 VOL: 0
;PCODE: $00001694 VOL: 0
;PCODE: $00001695 VOL: 0
;PCODE: $00001696 VOL: 0
;PCODE: $00001697 VOL: 0
;PCODE: $00001698 VOL: 0
;PCODE: $00001699 VOL: 0
;		return 2;
;PCODE: $0000169A VOL: 0
;PCODE: $0000169B VOL: 0
;PCODE: $0000169C VOL: 0
;
;	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;PCODE: $0000169D VOL: 0
;PCODE: $0000169E VOL: 0
;PCODE: $0000169F VOL: 0
;PCODE: $000016A0 VOL: 0
;PCODE: $000016A1 VOL: 0
;PCODE: $000016A2 VOL: 0
;PCODE: $000016A3 VOL: 0
;PCODE: $000016A4 VOL: 0
;PCODE: $000016A5 VOL: 0
;PCODE: $000016A6 VOL: 0
;PCODE: $000016A7 VOL: 0
;PCODE: $000016A8 VOL: 0
;PCODE: $000016A9 VOL: 0
;PCODE: $000016AA VOL: 0
;PCODE: $000016AB VOL: 0
;PCODE: $000016AC VOL: 0
;PCODE: $000016AD VOL: 0
;PCODE: $000016AE VOL: 0
;PCODE: $000016AF VOL: 0
;PCODE: $000016B0 VOL: 0
;PCODE: $000016B1 VOL: 0
;PCODE: $000016B2 VOL: 0
;PCODE: $000016B3 VOL: 0
;PCODE: $000016B4 VOL: 0
;PCODE: $000016B5 VOL: 0
;PCODE: $000016B6 VOL: 0
;PCODE: $000016B7 VOL: 0
;PCODE: $000016B8 VOL: 0
;PCODE: $000016B9 VOL: 0
;PCODE: $000016BA VOL: 0
;		return 0;
;PCODE: $000016BB VOL: 0
;PCODE: $000016BC VOL: 0
;PCODE: $000016BD VOL: 0
;	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;PCODE: $000016BE VOL: 0
;PCODE: $000016BF VOL: 0
;PCODE: $000016C0 VOL: 0
;PCODE: $000016C1 VOL: 0
;PCODE: $000016C2 VOL: 0
;PCODE: $000016C3 VOL: 0
;PCODE: $000016C4 VOL: 0
;PCODE: $000016C5 VOL: 0
;PCODE: $000016C6 VOL: 0
;PCODE: $000016C7 VOL: 0
;PCODE: $000016C8 VOL: 0
;PCODE: $000016C9 VOL: 0
;PCODE: $000016CA VOL: 0
;PCODE: $000016CB VOL: 0
;PCODE: $000016CC VOL: 0
;PCODE: $000016CD VOL: 0
;PCODE: $000016CE VOL: 0
;PCODE: $000016CF VOL: 0
;PCODE: $000016D0 VOL: 0
;PCODE: $000016D1 VOL: 0
;PCODE: $000016D2 VOL: 0
;PCODE: $000016D3 VOL: 0
;PCODE: $000016D4 VOL: 0
;PCODE: $000016D5 VOL: 0
;PCODE: $000016D6 VOL: 0
;PCODE: $000016D7 VOL: 0
;PCODE: $000016D8 VOL: 0
;PCODE: $000016D9 VOL: 0
;PCODE: $000016DA VOL: 0
;PCODE: $000016DB VOL: 0
;PCODE: $000016DC VOL: 0
;PCODE: $000016DD VOL: 0
;PCODE: $000016DE VOL: 0
;PCODE: $000016DF VOL: 0
;		return 0;
;PCODE: $000016E0 VOL: 0
;PCODE: $000016E1 VOL: 0
;PCODE: $000016E2 VOL: 0
;
;	return 1;
;PCODE: $000016E3 VOL: 0
;PCODE: $000016E4 VOL: 0
;PCODE: $000016E5 VOL: 0
;PCODE: $000016E6 VOL: 0
;}
;PCODE: $000016E7 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Find logical drive and check if the volume is mounted                 */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
;	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;	BYTE wmode			/* !=0: Check write protection for write access */
;)
;{
;PCODE: $000016E8 VOL: 0
;PCODE: $000016E9 VOL: 0
;	BYTE fmt;
;	int vol;
;	DSTATUS stat;
;	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;	WORD nrsv;
;	FATFS *fs;
;
;
;	/* Get logical drive number from the path name */
;	*rfs = 0;
;PCODE: $000016EA VOL: 0
;PCODE: $000016EB VOL: 0
;PCODE: $000016EC VOL: 0
;	*rfs -> Y+35
;	*path -> Y+33
;	wmode -> Y+32
;	fmt -> R17
;	vol -> R18,R19
;	stat -> R16
;	bsect -> Y+28
;	fasize -> Y+24
;	tsect -> Y+20
;	sysect -> Y+16
;	nclst -> Y+12
;	szbfat -> Y+8
;	nrsv -> R20,R21
;	*fs -> Y+6
;PCODE: $000016ED VOL: 0
;PCODE: $000016EE VOL: 0
;PCODE: $000016EF VOL: 0
;	vol = get_ldnumber(path);
;PCODE: $000016F0 VOL: 0
;PCODE: $000016F1 VOL: 0
;PCODE: $000016F2 VOL: 0
;	if (vol < 0) return FR_INVALID_DRIVE;
;PCODE: $000016F3 VOL: 0
;PCODE: $000016F4 VOL: 0
;PCODE: $000016F5 VOL: 0
;PCODE: $000016F6 VOL: 0
;PCODE: $000016F7 VOL: 0
;PCODE: $000016F8 VOL: 0
;
;	/* Check if the file system object is valid or not */
;	fs = FatFs[vol];					/* Get pointer to the file system object */
;PCODE: $000016F9 VOL: 0
;PCODE: $000016FA VOL: 0
;PCODE: $000016FB VOL: 0
;PCODE: $000016FC VOL: 0
;PCODE: $000016FD VOL: 0
;PCODE: $000016FE VOL: 0
;PCODE: $000016FF VOL: 0
;	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;PCODE: $00001700 VOL: 0
;PCODE: $00001701 VOL: 0
;PCODE: $00001702 VOL: 0
;PCODE: $00001703 VOL: 0
;PCODE: $00001704 VOL: 0
;PCODE: $00001705 VOL: 0
;PCODE: $00001706 VOL: 0
;
;	ENTER_FF(fs);						/* Lock the volume */
;	*rfs = fs;							/* Return pointer to the file system object */
;PCODE: $00001707 VOL: 0
;PCODE: $00001708 VOL: 0
;PCODE: $00001709 VOL: 0
;PCODE: $0000170A VOL: 0
;
;	if (fs->fs_type) {					/* If the volume has been mounted */
;PCODE: $0000170B VOL: 0
;PCODE: $0000170C VOL: 0
;PCODE: $0000170D VOL: 0
;PCODE: $0000170E VOL: 0
;		stat = disk_status(fs->drv);
;PCODE: $0000170F VOL: 0
;PCODE: $00001710 VOL: 0
;PCODE: $00001711 VOL: 0
;PCODE: $00001712 VOL: 0
;		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;PCODE: $00001713 VOL: 0
;PCODE: $00001714 VOL: 0
;PCODE: $00001715 VOL: 0
;			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;PCODE: $00001716 VOL: 0
;PCODE: $00001717 VOL: 0
;PCODE: $00001718 VOL: 0
;PCODE: $00001719 VOL: 0
;PCODE: $0000171A VOL: 0
;PCODE: $0000171B VOL: 0
;PCODE: $0000171C VOL: 0
;PCODE: $0000171D VOL: 0
;PCODE: $0000171E VOL: 0
;PCODE: $0000171F VOL: 0
;PCODE: $00001720 VOL: 0
;PCODE: $00001721 VOL: 0
;PCODE: $00001722 VOL: 0
;				return FR_WRITE_PROTECTED;
;PCODE: $00001723 VOL: 0
;PCODE: $00001724 VOL: 0
;PCODE: $00001725 VOL: 0
;PCODE: $00001726 VOL: 0
;			return FR_OK;				/* The file system object is valid */
;PCODE: $00001727 VOL: 0
;PCODE: $00001728 VOL: 0
;PCODE: $00001729 VOL: 0
;PCODE: $0000172A VOL: 0
;PCODE: $0000172B VOL: 0
;		}
;	}
;PCODE: $0000172C VOL: 0
;
;	/* The file system object is not valid. */
;	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;
;	fs->fs_type = 0;					/* Clear the file system object */
;PCODE: $0000172D VOL: 0
;PCODE: $0000172E VOL: 0
;PCODE: $0000172F VOL: 0
;PCODE: $00001730 VOL: 0
;	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;PCODE: $00001731 VOL: 0
;PCODE: $00001732 VOL: 0
;PCODE: $00001733 VOL: 0
;	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;PCODE: $00001734 VOL: 0
;PCODE: $00001735 VOL: 0
;PCODE: $00001736 VOL: 0
;PCODE: $00001737 VOL: 0
;	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;PCODE: $00001738 VOL: 0
;PCODE: $00001739 VOL: 0
;PCODE: $0000173A VOL: 0
;		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;PCODE: $0000173B VOL: 0
;PCODE: $0000173C VOL: 0
;PCODE: $0000173D VOL: 0
;PCODE: $0000173E VOL: 0
;	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;PCODE: $0000173F VOL: 0
;PCODE: $00001740 VOL: 0
;PCODE: $00001741 VOL: 0
;PCODE: $00001742 VOL: 0
;PCODE: $00001743 VOL: 0
;PCODE: $00001744 VOL: 0
;PCODE: $00001745 VOL: 0
;PCODE: $00001746 VOL: 0
;PCODE: $00001747 VOL: 0
;PCODE: $00001748 VOL: 0
;PCODE: $00001749 VOL: 0
;PCODE: $0000174A VOL: 0
;PCODE: $0000174B VOL: 0
;PCODE: $0000174C VOL: 0
;		return FR_WRITE_PROTECTED;
;PCODE: $0000174D VOL: 0
;PCODE: $0000174E VOL: 0
;PCODE: $0000174F VOL: 0
;PCODE: $00001750 VOL: 0
;#if _MAX_SS != 512						/* Get sector size (variable sector size cfg only) */
;	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
;		return FR_DISK_ERR;
;#endif
;	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;	bsect = 0;
;PCODE: $00001751 VOL: 0
;PCODE: $00001752 VOL: 0
;PCODE: $00001753 VOL: 0
;	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;PCODE: $00001754 VOL: 0
;PCODE: $00001755 VOL: 0
;PCODE: $00001756 VOL: 0
;PCODE: $00001757 VOL: 0
;PCODE: $00001758 VOL: 0
;	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;PCODE: $00001759 VOL: 0
;PCODE: $0000175A VOL: 0
;PCODE: $0000175B VOL: 0
;PCODE: $0000175C VOL: 0
;PCODE: $0000175D VOL: 0
;PCODE: $0000175E VOL: 0
;PCODE: $0000175F VOL: 0
;PCODE: $00001760 VOL: 0
;PCODE: $00001761 VOL: 0
;PCODE: $00001762 VOL: 0
;PCODE: $00001763 VOL: 0
;PCODE: $00001764 VOL: 0
;		UINT i;
;		DWORD br[4];
;
;		for (i = 0; i < 4; i++) {			/* Get partition offset */
;PCODE: $00001765 VOL: 0
;	*rfs -> Y+53
;	*path -> Y+51
;	wmode -> Y+50
;	bsect -> Y+46
;	fasize -> Y+42
;	tsect -> Y+38
;	sysect -> Y+34
;	nclst -> Y+30
;	szbfat -> Y+26
;	*fs -> Y+24
;	i -> Y+16
;	br -> Y+0
;PCODE: $00001766 VOL: 0
;PCODE: $00001767 VOL: 0
;PCODE: $00001768 VOL: 0
;PCODE: $00001769 VOL: 0
;PCODE: $0000176A VOL: 0
;PCODE: $0000176B VOL: 0
;PCODE: $0000176C VOL: 0
;PCODE: $0000176D VOL: 0
;PCODE: $0000176E VOL: 0
;PCODE: $0000176F VOL: 0
;			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
;			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;PCODE: $00001770 VOL: 0
;	*rfs -> Y+55
;	*path -> Y+53
;	wmode -> Y+52
;	bsect -> Y+48
;	fasize -> Y+44
;	tsect -> Y+40
;	sysect -> Y+36
;	nclst -> Y+32
;	szbfat -> Y+28
;	*fs -> Y+26
;	i -> Y+18
;	br -> Y+2
;	*pt -> Y+0
;PCODE: $00001771 VOL: 0
;PCODE: $00001772 VOL: 0
;PCODE: $00001773 VOL: 0
;PCODE: $00001774 VOL: 0
;PCODE: $00001775 VOL: 0
;PCODE: $00001776 VOL: 0
;PCODE: $00001777 VOL: 0
;PCODE: $00001778 VOL: 0
;PCODE: $00001779 VOL: 0
;PCODE: $0000177A VOL: 0
;PCODE: $0000177B VOL: 0
;PCODE: $0000177C VOL: 0
;PCODE: $0000177D VOL: 0
;PCODE: $0000177E VOL: 0
;PCODE: $0000177F VOL: 0
;PCODE: $00001780 VOL: 0
;PCODE: $00001781 VOL: 0
;PCODE: $00001782 VOL: 0
;PCODE: $00001783 VOL: 0
;PCODE: $00001784 VOL: 0
;PCODE: $00001785 VOL: 0
;PCODE: $00001786 VOL: 0
;PCODE: $00001787 VOL: 0
;PCODE: $00001788 VOL: 0
;PCODE: $00001789 VOL: 0
;PCODE: $0000178A VOL: 0
;PCODE: $0000178B VOL: 0
;PCODE: $0000178C VOL: 0
;PCODE: $0000178D VOL: 0
;PCODE: $0000178E VOL: 0
;PCODE: $0000178F VOL: 0
;PCODE: $00001790 VOL: 0
;PCODE: $00001791 VOL: 0
;PCODE: $00001792 VOL: 0
;PCODE: $00001793 VOL: 0
;PCODE: $00001794 VOL: 0
;PCODE: $00001795 VOL: 0
;PCODE: $00001796 VOL: 0
;PCODE: $00001797 VOL: 0
;PCODE: $00001798 VOL: 0
;PCODE: $00001799 VOL: 0
;PCODE: $0000179A VOL: 0
;PCODE: $0000179B VOL: 0
;PCODE: $0000179C VOL: 0
;PCODE: $0000179D VOL: 0
;PCODE: $0000179E VOL: 0
;PCODE: $0000179F VOL: 0
;PCODE: $000017A0 VOL: 0
;PCODE: $000017A1 VOL: 0
;PCODE: $000017A2 VOL: 0
;PCODE: $000017A3 VOL: 0
;PCODE: $000017A4 VOL: 0
;		}
;PCODE: $000017A5 VOL: 0
;PCODE: $000017A6 VOL: 0
;PCODE: $000017A7 VOL: 0
;PCODE: $000017A8 VOL: 0
;PCODE: $000017A9 VOL: 0
;PCODE: $000017AA VOL: 0
;PCODE: $000017AB VOL: 0
;		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;PCODE: $000017AC VOL: 0
;PCODE: $000017AD VOL: 0
;		if (i) i--;
;PCODE: $000017AE VOL: 0
;PCODE: $000017AF VOL: 0
;PCODE: $000017B0 VOL: 0
;PCODE: $000017B1 VOL: 0
;PCODE: $000017B2 VOL: 0
;PCODE: $000017B3 VOL: 0
;		do {								/* Find an FAT volume */
;PCODE: $000017B4 VOL: 0
;PCODE: $000017B5 VOL: 0
;			bsect = br[i];
;PCODE: $000017B6 VOL: 0
;PCODE: $000017B7 VOL: 0
;PCODE: $000017B8 VOL: 0
;PCODE: $000017B9 VOL: 0
;PCODE: $000017BA VOL: 0
;PCODE: $000017BB VOL: 0
;			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;PCODE: $000017BC VOL: 0
;PCODE: $000017BD VOL: 0
;PCODE: $000017BE VOL: 0
;PCODE: $000017BF VOL: 0
;PCODE: $000017C0 VOL: 0
;PCODE: $000017C1 VOL: 0
;PCODE: $000017C2 VOL: 0
;PCODE: $000017C3 VOL: 0
;PCODE: $000017C4 VOL: 0
;PCODE: $000017C5 VOL: 0
;PCODE: $000017C6 VOL: 0
;PCODE: $000017C7 VOL: 0
;PCODE: $000017C8 VOL: 0
;		} while (!LD2PT(vol) && fmt && ++i < 4);
;PCODE: $000017C9 VOL: 0
;PCODE: $000017CA VOL: 0
;PCODE: $000017CB VOL: 0
;PCODE: $000017CC VOL: 0
;PCODE: $000017CD VOL: 0
;PCODE: $000017CE VOL: 0
;PCODE: $000017CF VOL: 0
;PCODE: $000017D0 VOL: 0
;PCODE: $000017D1 VOL: 0
;PCODE: $000017D2 VOL: 0
;PCODE: $000017D3 VOL: 0
;PCODE: $000017D4 VOL: 0
;PCODE: $000017D5 VOL: 0
;PCODE: $000017D6 VOL: 0
;PCODE: $000017D7 VOL: 0
;PCODE: $000017D8 VOL: 0
;PCODE: $000017D9 VOL: 0
;	}
;PCODE: $000017DA VOL: 0
;	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;PCODE: $000017DB VOL: 0
;PCODE: $000017DC VOL: 0
;PCODE: $000017DD VOL: 0
;PCODE: $000017DE VOL: 0
;PCODE: $000017DF VOL: 0
;PCODE: $000017E0 VOL: 0
;PCODE: $000017E1 VOL: 0
;PCODE: $000017E2 VOL: 0
;	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;PCODE: $000017E3 VOL: 0
;PCODE: $000017E4 VOL: 0
;PCODE: $000017E5 VOL: 0
;PCODE: $000017E6 VOL: 0
;PCODE: $000017E7 VOL: 0
;PCODE: $000017E8 VOL: 0
;PCODE: $000017E9 VOL: 0
;
;	/* An FAT volume is found. Following code initializes the file system object */
;
;	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;PCODE: $000017EA VOL: 0
;PCODE: $000017EB VOL: 0
;PCODE: $000017EC VOL: 0
;PCODE: $000017ED VOL: 0
;PCODE: $000017EE VOL: 0
;PCODE: $000017EF VOL: 0
;PCODE: $000017F0 VOL: 0
;PCODE: $000017F1 VOL: 0
;PCODE: $000017F2 VOL: 0
;PCODE: $000017F3 VOL: 0
;PCODE: $000017F4 VOL: 0
;		return FR_NO_FILESYSTEM;
;PCODE: $000017F5 VOL: 0
;PCODE: $000017F6 VOL: 0
;PCODE: $000017F7 VOL: 0
;PCODE: $000017F8 VOL: 0
;
;	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;PCODE: $000017F9 VOL: 0
;PCODE: $000017FA VOL: 0
;PCODE: $000017FB VOL: 0
;PCODE: $000017FC VOL: 0
;PCODE: $000017FD VOL: 0
;PCODE: $000017FE VOL: 0
;PCODE: $000017FF VOL: 0
;PCODE: $00001800 VOL: 0
;PCODE: $00001801 VOL: 0
;PCODE: $00001802 VOL: 0
;PCODE: $00001803 VOL: 0
;PCODE: $00001804 VOL: 0
;PCODE: $00001805 VOL: 0
;	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;PCODE: $00001806 VOL: 0
;PCODE: $00001807 VOL: 0
;PCODE: $00001808 VOL: 0
;PCODE: $00001809 VOL: 0
;PCODE: $0000180A VOL: 0
;PCODE: $0000180B VOL: 0
;PCODE: $0000180C VOL: 0
;PCODE: $0000180D VOL: 0
;PCODE: $0000180E VOL: 0
;PCODE: $0000180F VOL: 0
;PCODE: $00001810 VOL: 0
;PCODE: $00001811 VOL: 0
;PCODE: $00001812 VOL: 0
;PCODE: $00001813 VOL: 0
;PCODE: $00001814 VOL: 0
;PCODE: $00001815 VOL: 0
;PCODE: $00001816 VOL: 0
;PCODE: $00001817 VOL: 0
;PCODE: $00001818 VOL: 0
;PCODE: $00001819 VOL: 0
;PCODE: $0000181A VOL: 0
;PCODE: $0000181B VOL: 0
;PCODE: $0000181C VOL: 0
;PCODE: $0000181D VOL: 0
;PCODE: $0000181E VOL: 0
;PCODE: $0000181F VOL: 0
;PCODE: $00001820 VOL: 0
;PCODE: $00001821 VOL: 0
;PCODE: $00001822 VOL: 0
;PCODE: $00001823 VOL: 0
;PCODE: $00001824 VOL: 0
;PCODE: $00001825 VOL: 0
;PCODE: $00001826 VOL: 0
;	fs->fsize = fasize;
;PCODE: $00001827 VOL: 0
;PCODE: $00001828 VOL: 0
;PCODE: $00001829 VOL: 0
;PCODE: $0000182A VOL: 0
;
;	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;PCODE: $0000182B VOL: 0
;PCODE: $0000182C VOL: 0
;PCODE: $0000182D VOL: 0
;PCODE: $0000182E VOL: 0
;	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;PCODE: $0000182F VOL: 0
;PCODE: $00001830 VOL: 0
;PCODE: $00001831 VOL: 0
;PCODE: $00001832 VOL: 0
;PCODE: $00001833 VOL: 0
;PCODE: $00001834 VOL: 0
;PCODE: $00001835 VOL: 0
;PCODE: $00001836 VOL: 0
;PCODE: $00001837 VOL: 0
;PCODE: $00001838 VOL: 0
;PCODE: $00001839 VOL: 0
;PCODE: $0000183A VOL: 0
;		return FR_NO_FILESYSTEM;
;PCODE: $0000183B VOL: 0
;PCODE: $0000183C VOL: 0
;PCODE: $0000183D VOL: 0
;PCODE: $0000183E VOL: 0
;	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;PCODE: $0000183F VOL: 0
;PCODE: $00001840 VOL: 0
;PCODE: $00001841 VOL: 0
;PCODE: $00001842 VOL: 0
;PCODE: $00001843 VOL: 0
;PCODE: $00001844 VOL: 0
;PCODE: $00001845 VOL: 0
;PCODE: $00001846 VOL: 0
;
;	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;PCODE: $00001847 VOL: 0
;PCODE: $00001848 VOL: 0
;PCODE: $00001849 VOL: 0
;PCODE: $0000184A VOL: 0
;	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;PCODE: $0000184B VOL: 0
;PCODE: $0000184C VOL: 0
;PCODE: $0000184D VOL: 0
;PCODE: $0000184E VOL: 0
;PCODE: $0000184F VOL: 0
;PCODE: $00001850 VOL: 0
;PCODE: $00001851 VOL: 0
;PCODE: $00001852 VOL: 0
;PCODE: $00001853 VOL: 0
;PCODE: $00001854 VOL: 0
;PCODE: $00001855 VOL: 0
;PCODE: $00001856 VOL: 0
;PCODE: $00001857 VOL: 0
;PCODE: $00001858 VOL: 0
;PCODE: $00001859 VOL: 0
;PCODE: $0000185A VOL: 0
;		return FR_NO_FILESYSTEM;
;PCODE: $0000185B VOL: 0
;PCODE: $0000185C VOL: 0
;PCODE: $0000185D VOL: 0
;PCODE: $0000185E VOL: 0
;
;	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;PCODE: $0000185F VOL: 0
;PCODE: $00001860 VOL: 0
;PCODE: $00001861 VOL: 0
;PCODE: $00001862 VOL: 0
;PCODE: $00001863 VOL: 0
;PCODE: $00001864 VOL: 0
;PCODE: $00001865 VOL: 0
;PCODE: $00001866 VOL: 0
;PCODE: $00001867 VOL: 0
;PCODE: $00001868 VOL: 0
;PCODE: $00001869 VOL: 0
;PCODE: $0000186A VOL: 0
;	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
;PCODE: $0000186B VOL: 0
;PCODE: $0000186C VOL: 0
;PCODE: $0000186D VOL: 0
;PCODE: $0000186E VOL: 0
;PCODE: $0000186F VOL: 0
;		return FR_NO_FILESYSTEM;
;PCODE: $00001870 VOL: 0
;PCODE: $00001871 VOL: 0
;PCODE: $00001872 VOL: 0
;PCODE: $00001873 VOL: 0
;
;	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;PCODE: $00001874 VOL: 0
;PCODE: $00001875 VOL: 0
;PCODE: $00001876 VOL: 0
;PCODE: $00001877 VOL: 0
;PCODE: $00001878 VOL: 0
;PCODE: $00001879 VOL: 0
;PCODE: $0000187A VOL: 0
;PCODE: $0000187B VOL: 0
;PCODE: $0000187C VOL: 0
;PCODE: $0000187D VOL: 0
;PCODE: $0000187E VOL: 0
;PCODE: $0000187F VOL: 0
;PCODE: $00001880 VOL: 0
;	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;PCODE: $00001881 VOL: 0
;PCODE: $00001882 VOL: 0
;PCODE: $00001883 VOL: 0
;PCODE: $00001884 VOL: 0
;PCODE: $00001885 VOL: 0
;PCODE: $00001886 VOL: 0
;PCODE: $00001887 VOL: 0
;PCODE: $00001888 VOL: 0
;PCODE: $00001889 VOL: 0
;PCODE: $0000188A VOL: 0
;PCODE: $0000188B VOL: 0
;PCODE: $0000188C VOL: 0
;PCODE: $0000188D VOL: 0
;PCODE: $0000188E VOL: 0
;PCODE: $0000188F VOL: 0
;PCODE: $00001890 VOL: 0
;PCODE: $00001891 VOL: 0
;PCODE: $00001892 VOL: 0
;PCODE: $00001893 VOL: 0
;PCODE: $00001894 VOL: 0
;PCODE: $00001895 VOL: 0
;PCODE: $00001896 VOL: 0
;PCODE: $00001897 VOL: 0
;PCODE: $00001898 VOL: 0
;PCODE: $00001899 VOL: 0
;PCODE: $0000189A VOL: 0
;PCODE: $0000189B VOL: 0
;PCODE: $0000189C VOL: 0
;PCODE: $0000189D VOL: 0
;PCODE: $0000189E VOL: 0
;PCODE: $0000189F VOL: 0
;PCODE: $000018A0 VOL: 0
;PCODE: $000018A1 VOL: 0
;
;	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;PCODE: $000018A2 VOL: 0
;PCODE: $000018A3 VOL: 0
;PCODE: $000018A4 VOL: 0
;PCODE: $000018A5 VOL: 0
;PCODE: $000018A6 VOL: 0
;PCODE: $000018A7 VOL: 0
;PCODE: $000018A8 VOL: 0
;PCODE: $000018A9 VOL: 0
;PCODE: $000018AA VOL: 0
;PCODE: $000018AB VOL: 0
;	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;PCODE: $000018AC VOL: 0
;PCODE: $000018AD VOL: 0
;PCODE: $000018AE VOL: 0
;PCODE: $000018AF VOL: 0
;PCODE: $000018B0 VOL: 0
;PCODE: $000018B1 VOL: 0
;
;	/* Determine the FAT sub type */
;	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;PCODE: $000018B2 VOL: 0
;PCODE: $000018B3 VOL: 0
;PCODE: $000018B4 VOL: 0
;PCODE: $000018B5 VOL: 0
;PCODE: $000018B6 VOL: 0
;PCODE: $000018B7 VOL: 0
;PCODE: $000018B8 VOL: 0
;PCODE: $000018B9 VOL: 0
;PCODE: $000018BA VOL: 0
;PCODE: $000018BB VOL: 0
;PCODE: $000018BC VOL: 0
;PCODE: $000018BD VOL: 0
;PCODE: $000018BE VOL: 0
;PCODE: $000018BF VOL: 0
;	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;PCODE: $000018C0 VOL: 0
;PCODE: $000018C1 VOL: 0
;PCODE: $000018C2 VOL: 0
;PCODE: $000018C3 VOL: 0
;PCODE: $000018C4 VOL: 0
;PCODE: $000018C5 VOL: 0
;PCODE: $000018C6 VOL: 0
;PCODE: $000018C7 VOL: 0
;	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;PCODE: $000018C8 VOL: 0
;PCODE: $000018C9 VOL: 0
;PCODE: $000018CA VOL: 0
;PCODE: $000018CB VOL: 0
;PCODE: $000018CC VOL: 0
;PCODE: $000018CD VOL: 0
;PCODE: $000018CE VOL: 0
;PCODE: $000018CF VOL: 0
;PCODE: $000018D0 VOL: 0
;PCODE: $000018D1 VOL: 0
;PCODE: $000018D2 VOL: 0
;	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;PCODE: $000018D3 VOL: 0
;PCODE: $000018D4 VOL: 0
;PCODE: $000018D5 VOL: 0
;PCODE: $000018D6 VOL: 0
;PCODE: $000018D7 VOL: 0
;PCODE: $000018D8 VOL: 0
;PCODE: $000018D9 VOL: 0
;	fmt = FS_FAT12;
;PCODE: $000018DA VOL: 0
;PCODE: $000018DB VOL: 0
;PCODE: $000018DC VOL: 0
;	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;PCODE: $000018DD VOL: 0
;PCODE: $000018DE VOL: 0
;PCODE: $000018DF VOL: 0
;PCODE: $000018E0 VOL: 0
;PCODE: $000018E1 VOL: 0
;	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;PCODE: $000018E2 VOL: 0
;PCODE: $000018E3 VOL: 0
;PCODE: $000018E4 VOL: 0
;PCODE: $000018E5 VOL: 0
;PCODE: $000018E6 VOL: 0
;PCODE: $000018E7 VOL: 0
;
;	/* Boundaries and Limits */
;	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;PCODE: $000018E8 VOL: 0
;PCODE: $000018E9 VOL: 0
;PCODE: $000018EA VOL: 0
;PCODE: $000018EB VOL: 0
;PCODE: $000018EC VOL: 0
;	fs->volbase = bsect;								/* Volume start sector */
;PCODE: $000018ED VOL: 0
;PCODE: $000018EE VOL: 0
;PCODE: $000018EF VOL: 0
;	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;PCODE: $000018F0 VOL: 0
;PCODE: $000018F1 VOL: 0
;PCODE: $000018F2 VOL: 0
;PCODE: $000018F3 VOL: 0
;PCODE: $000018F4 VOL: 0
;PCODE: $000018F5 VOL: 0
;	fs->database = bsect + sysect;						/* Data start sector */
;PCODE: $000018F6 VOL: 0
;PCODE: $000018F7 VOL: 0
;PCODE: $000018F8 VOL: 0
;PCODE: $000018F9 VOL: 0
;PCODE: $000018FA VOL: 0
;	if (fmt == FS_FAT32) {
;PCODE: $000018FB VOL: 0
;PCODE: $000018FC VOL: 0
;PCODE: $000018FD VOL: 0
;		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;PCODE: $000018FE VOL: 0
;PCODE: $000018FF VOL: 0
;PCODE: $00001900 VOL: 0
;PCODE: $00001901 VOL: 0
;PCODE: $00001902 VOL: 0
;PCODE: $00001903 VOL: 0
;PCODE: $00001904 VOL: 0
;PCODE: $00001905 VOL: 0
;PCODE: $00001906 VOL: 0
;		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;PCODE: $00001907 VOL: 0
;PCODE: $00001908 VOL: 0
;PCODE: $00001909 VOL: 0
;PCODE: $0000190A VOL: 0
;PCODE: $0000190B VOL: 0
;PCODE: $0000190C VOL: 0
;PCODE: $0000190D VOL: 0
;PCODE: $0000190E VOL: 0
;PCODE: $0000190F VOL: 0
;PCODE: $00001910 VOL: 0
;PCODE: $00001911 VOL: 0
;PCODE: $00001912 VOL: 0
;PCODE: $00001913 VOL: 0
;PCODE: $00001914 VOL: 0
;PCODE: $00001915 VOL: 0
;PCODE: $00001916 VOL: 0
;PCODE: $00001917 VOL: 0
;PCODE: $00001918 VOL: 0
;PCODE: $00001919 VOL: 0
;PCODE: $0000191A VOL: 0
;PCODE: $0000191B VOL: 0
;PCODE: $0000191C VOL: 0
;PCODE: $0000191D VOL: 0
;PCODE: $0000191E VOL: 0
;PCODE: $0000191F VOL: 0
;PCODE: $00001920 VOL: 0
;PCODE: $00001921 VOL: 0
;PCODE: $00001922 VOL: 0
;PCODE: $00001923 VOL: 0
;PCODE: $00001924 VOL: 0
;PCODE: $00001925 VOL: 0
;PCODE: $00001926 VOL: 0
;		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
;PCODE: $00001927 VOL: 0
;PCODE: $00001928 VOL: 0
;PCODE: $00001929 VOL: 0
;PCODE: $0000192A VOL: 0
;PCODE: $0000192B VOL: 0
;	} else {
;PCODE: $0000192C VOL: 0
;PCODE: $0000192D VOL: 0
;		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;PCODE: $0000192E VOL: 0
;PCODE: $0000192F VOL: 0
;PCODE: $00001930 VOL: 0
;PCODE: $00001931 VOL: 0
;PCODE: $00001932 VOL: 0
;PCODE: $00001933 VOL: 0
;PCODE: $00001934 VOL: 0
;PCODE: $00001935 VOL: 0
;PCODE: $00001936 VOL: 0
;		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;PCODE: $00001937 VOL: 0
;PCODE: $00001938 VOL: 0
;PCODE: $00001939 VOL: 0
;PCODE: $0000193A VOL: 0
;PCODE: $0000193B VOL: 0
;PCODE: $0000193C VOL: 0
;PCODE: $0000193D VOL: 0
;		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
;			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;PCODE: $0000193E VOL: 0
;PCODE: $0000193F VOL: 0
;PCODE: $00001940 VOL: 0
;PCODE: $00001941 VOL: 0
;PCODE: $00001942 VOL: 0
;PCODE: $00001943 VOL: 0
;PCODE: $00001944 VOL: 0
;PCODE: $00001945 VOL: 0
;PCODE: $00001946 VOL: 0
;PCODE: $00001947 VOL: 0
;PCODE: $00001948 VOL: 0
;PCODE: $00001949 VOL: 0
;PCODE: $0000194A VOL: 0
;PCODE: $0000194B VOL: 0
;PCODE: $0000194C VOL: 0
;PCODE: $0000194D VOL: 0
;PCODE: $0000194E VOL: 0
;PCODE: $0000194F VOL: 0
;PCODE: $00001950 VOL: 0
;PCODE: $00001951 VOL: 0
;PCODE: $00001952 VOL: 0
;PCODE: $00001953 VOL: 0
;PCODE: $00001954 VOL: 0
;PCODE: $00001955 VOL: 0
;PCODE: $00001956 VOL: 0
;	}
;PCODE: $00001957 VOL: 0
;	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
;PCODE: $00001958 VOL: 0
;PCODE: $00001959 VOL: 0
;PCODE: $0000195A VOL: 0
;PCODE: $0000195B VOL: 0
;PCODE: $0000195C VOL: 0
;PCODE: $0000195D VOL: 0
;PCODE: $0000195E VOL: 0
;PCODE: $0000195F VOL: 0
;PCODE: $00001960 VOL: 0
;PCODE: $00001961 VOL: 0
;		return FR_NO_FILESYSTEM;
;PCODE: $00001962 VOL: 0
;PCODE: $00001963 VOL: 0
;PCODE: $00001964 VOL: 0
;PCODE: $00001965 VOL: 0
;
;#if !_FS_READONLY
;	/* Initialize cluster allocation information */
;	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;PCODE: $00001966 VOL: 0
;PCODE: $00001967 VOL: 0
;PCODE: $00001968 VOL: 0
;PCODE: $00001969 VOL: 0
;PCODE: $0000196A VOL: 0
;PCODE: $0000196B VOL: 0
;PCODE: $0000196C VOL: 0
;
;	/* Get fsinfo if available */
;	fs->fsi_flag = 0x80;
;PCODE: $0000196D VOL: 0
;PCODE: $0000196E VOL: 0
;PCODE: $0000196F VOL: 0
;PCODE: $00001970 VOL: 0
;	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
;		&& LD_WORD(fs->win+BPB_FSInfo) == 1
;		&& move_window(fs, bsect + 1) == FR_OK)
;PCODE: $00001971 VOL: 0
;PCODE: $00001972 VOL: 0
;PCODE: $00001973 VOL: 0
;PCODE: $00001974 VOL: 0
;PCODE: $00001975 VOL: 0
;PCODE: $00001976 VOL: 0
;PCODE: $00001977 VOL: 0
;PCODE: $00001978 VOL: 0
;PCODE: $00001979 VOL: 0
;PCODE: $0000197A VOL: 0
;PCODE: $0000197B VOL: 0
;PCODE: $0000197C VOL: 0
;PCODE: $0000197D VOL: 0
;PCODE: $0000197E VOL: 0
;PCODE: $0000197F VOL: 0
;PCODE: $00001980 VOL: 0
;PCODE: $00001981 VOL: 0
;PCODE: $00001982 VOL: 0
;PCODE: $00001983 VOL: 0
;PCODE: $00001984 VOL: 0
;PCODE: $00001985 VOL: 0
;PCODE: $00001986 VOL: 0
;PCODE: $00001987 VOL: 0
;PCODE: $00001988 VOL: 0
;PCODE: $00001989 VOL: 0
;PCODE: $0000198A VOL: 0
;	{
;		fs->fsi_flag = 0;
;PCODE: $0000198B VOL: 0
;PCODE: $0000198C VOL: 0
;PCODE: $0000198D VOL: 0
;PCODE: $0000198E VOL: 0
;		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
;			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
;PCODE: $0000198F VOL: 0
;PCODE: $00001990 VOL: 0
;PCODE: $00001991 VOL: 0
;PCODE: $00001992 VOL: 0
;PCODE: $00001993 VOL: 0
;PCODE: $00001994 VOL: 0
;PCODE: $00001995 VOL: 0
;PCODE: $00001996 VOL: 0
;PCODE: $00001997 VOL: 0
;PCODE: $00001998 VOL: 0
;PCODE: $00001999 VOL: 0
;PCODE: $0000199A VOL: 0
;PCODE: $0000199B VOL: 0
;PCODE: $0000199C VOL: 0
;PCODE: $0000199D VOL: 0
;PCODE: $0000199E VOL: 0
;PCODE: $0000199F VOL: 0
;PCODE: $000019A0 VOL: 0
;PCODE: $000019A1 VOL: 0
;PCODE: $000019A2 VOL: 0
;PCODE: $000019A3 VOL: 0
;PCODE: $000019A4 VOL: 0
;PCODE: $000019A5 VOL: 0
;PCODE: $000019A6 VOL: 0
;PCODE: $000019A7 VOL: 0
;PCODE: $000019A8 VOL: 0
;PCODE: $000019A9 VOL: 0
;PCODE: $000019AA VOL: 0
;PCODE: $000019AB VOL: 0
;PCODE: $000019AC VOL: 0
;PCODE: $000019AD VOL: 0
;PCODE: $000019AE VOL: 0
;PCODE: $000019AF VOL: 0
;PCODE: $000019B0 VOL: 0
;PCODE: $000019B1 VOL: 0
;PCODE: $000019B2 VOL: 0
;PCODE: $000019B3 VOL: 0
;PCODE: $000019B4 VOL: 0
;PCODE: $000019B5 VOL: 0
;PCODE: $000019B6 VOL: 0
;PCODE: $000019B7 VOL: 0
;PCODE: $000019B8 VOL: 0
;PCODE: $000019B9 VOL: 0
;PCODE: $000019BA VOL: 0
;PCODE: $000019BB VOL: 0
;PCODE: $000019BC VOL: 0
;PCODE: $000019BD VOL: 0
;PCODE: $000019BE VOL: 0
;PCODE: $000019BF VOL: 0
;PCODE: $000019C0 VOL: 0
;PCODE: $000019C1 VOL: 0
;PCODE: $000019C2 VOL: 0
;PCODE: $000019C3 VOL: 0
;PCODE: $000019C4 VOL: 0
;PCODE: $000019C5 VOL: 0
;PCODE: $000019C6 VOL: 0
;PCODE: $000019C7 VOL: 0
;PCODE: $000019C8 VOL: 0
;PCODE: $000019C9 VOL: 0
;PCODE: $000019CA VOL: 0
;PCODE: $000019CB VOL: 0
;PCODE: $000019CC VOL: 0
;PCODE: $000019CD VOL: 0
;PCODE: $000019CE VOL: 0
;PCODE: $000019CF VOL: 0
;PCODE: $000019D0 VOL: 0
;PCODE: $000019D1 VOL: 0
;PCODE: $000019D2 VOL: 0
;PCODE: $000019D3 VOL: 0
;PCODE: $000019D4 VOL: 0
;PCODE: $000019D5 VOL: 0
;PCODE: $000019D6 VOL: 0
;PCODE: $000019D7 VOL: 0
;PCODE: $000019D8 VOL: 0
;PCODE: $000019D9 VOL: 0
;PCODE: $000019DA VOL: 0
;PCODE: $000019DB VOL: 0
;		{
;#if !_FS_NOFSINFO
;			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;PCODE: $000019DC VOL: 0
;PCODE: $000019DD VOL: 0
;PCODE: $000019DE VOL: 0
;PCODE: $000019DF VOL: 0
;PCODE: $000019E0 VOL: 0
;PCODE: $000019E1 VOL: 0
;PCODE: $000019E2 VOL: 0
;PCODE: $000019E3 VOL: 0
;PCODE: $000019E4 VOL: 0
;PCODE: $000019E5 VOL: 0
;PCODE: $000019E6 VOL: 0
;PCODE: $000019E7 VOL: 0
;PCODE: $000019E8 VOL: 0
;PCODE: $000019E9 VOL: 0
;PCODE: $000019EA VOL: 0
;PCODE: $000019EB VOL: 0
;PCODE: $000019EC VOL: 0
;PCODE: $000019ED VOL: 0
;PCODE: $000019EE VOL: 0
;PCODE: $000019EF VOL: 0
;PCODE: $000019F0 VOL: 0
;PCODE: $000019F1 VOL: 0
;PCODE: $000019F2 VOL: 0
;PCODE: $000019F3 VOL: 0
;PCODE: $000019F4 VOL: 0
;PCODE: $000019F5 VOL: 0
;PCODE: $000019F6 VOL: 0
;PCODE: $000019F7 VOL: 0
;PCODE: $000019F8 VOL: 0
;PCODE: $000019F9 VOL: 0
;PCODE: $000019FA VOL: 0
;PCODE: $000019FB VOL: 0
;PCODE: $000019FC VOL: 0
;PCODE: $000019FD VOL: 0
;PCODE: $000019FE VOL: 0
;#endif
;			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;PCODE: $000019FF VOL: 0
;PCODE: $00001A00 VOL: 0
;PCODE: $00001A01 VOL: 0
;PCODE: $00001A02 VOL: 0
;PCODE: $00001A03 VOL: 0
;PCODE: $00001A04 VOL: 0
;PCODE: $00001A05 VOL: 0
;PCODE: $00001A06 VOL: 0
;PCODE: $00001A07 VOL: 0
;PCODE: $00001A08 VOL: 0
;PCODE: $00001A09 VOL: 0
;PCODE: $00001A0A VOL: 0
;PCODE: $00001A0B VOL: 0
;PCODE: $00001A0C VOL: 0
;PCODE: $00001A0D VOL: 0
;PCODE: $00001A0E VOL: 0
;PCODE: $00001A0F VOL: 0
;PCODE: $00001A10 VOL: 0
;PCODE: $00001A11 VOL: 0
;PCODE: $00001A12 VOL: 0
;PCODE: $00001A13 VOL: 0
;PCODE: $00001A14 VOL: 0
;PCODE: $00001A15 VOL: 0
;PCODE: $00001A16 VOL: 0
;PCODE: $00001A17 VOL: 0
;PCODE: $00001A18 VOL: 0
;PCODE: $00001A19 VOL: 0
;PCODE: $00001A1A VOL: 0
;PCODE: $00001A1B VOL: 0
;PCODE: $00001A1C VOL: 0
;PCODE: $00001A1D VOL: 0
;PCODE: $00001A1E VOL: 0
;PCODE: $00001A1F VOL: 0
;PCODE: $00001A20 VOL: 0
;PCODE: $00001A21 VOL: 0
;		}
;	}
;PCODE: $00001A22 VOL: 0
;#endif
;	fs->fs_type = fmt;	/* FAT sub-type */
;PCODE: $00001A23 VOL: 0
;PCODE: $00001A24 VOL: 0
;PCODE: $00001A25 VOL: 0
;	fs->id = ++Fsid;	/* File system mount ID */
;PCODE: $00001A26 VOL: 0
;PCODE: $00001A27 VOL: 0
;PCODE: $00001A28 VOL: 0
;PCODE: $00001A29 VOL: 0
;PCODE: $00001A2A VOL: 0
;PCODE: $00001A2B VOL: 0
;#if _FS_RPATH
;	fs->cdir = 0;		/* Current directory (root dir) */
;#endif
;#if _FS_LOCK			/* Clear file lock semaphores */
;	clear_lock(fs);
;#endif
;
;	return FR_OK;
;PCODE: $00001A2C VOL: 0
;PCODE: $00001A2D VOL: 0
;PCODE: $00001A2E VOL: 0
;PCODE: $00001A2F VOL: 0
;}
;PCODE: $00001A30 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Check if the file/directory object is valid or not                    */
;/*-----------------------------------------------------------------------*/
;
;static
;FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
;	void* obj		/* Pointer to the object FIL/DIR to check validity */
;)
;{
;PCODE: $00001A31 VOL: 0
;PCODE: $00001A32 VOL: 0
;	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;
;
;	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
;PCODE: $00001A33 VOL: 0
;PCODE: $00001A34 VOL: 0
;PCODE: $00001A35 VOL: 0
;	*obj -> Y+2
;	*fil -> R16,R17
;PCODE: $00001A36 VOL: 0
;PCODE: $00001A37 VOL: 0
;PCODE: $00001A38 VOL: 0
;PCODE: $00001A39 VOL: 0
;PCODE: $00001A3A VOL: 0
;PCODE: $00001A3B VOL: 0
;PCODE: $00001A3C VOL: 0
;PCODE: $00001A3D VOL: 0
;PCODE: $00001A3E VOL: 0
;PCODE: $00001A3F VOL: 0
;PCODE: $00001A40 VOL: 0
;PCODE: $00001A41 VOL: 0
;PCODE: $00001A42 VOL: 0
;PCODE: $00001A43 VOL: 0
;PCODE: $00001A44 VOL: 0
;PCODE: $00001A45 VOL: 0
;PCODE: $00001A46 VOL: 0
;PCODE: $00001A47 VOL: 0
;PCODE: $00001A48 VOL: 0
;PCODE: $00001A49 VOL: 0
;PCODE: $00001A4A VOL: 0
;PCODE: $00001A4B VOL: 0
;PCODE: $00001A4C VOL: 0
;PCODE: $00001A4D VOL: 0
;		return FR_INVALID_OBJECT;
;PCODE: $00001A4E VOL: 0
;PCODE: $00001A4F VOL: 0
;PCODE: $00001A50 VOL: 0
;PCODE: $00001A51 VOL: 0
;PCODE: $00001A52 VOL: 0
;PCODE: $00001A53 VOL: 0
;PCODE: $00001A54 VOL: 0
;
;	ENTER_FF(fil->fs);		/* Lock file system */
;
;	if (disk_status(fil->fs->drv) & STA_NOINIT)
;PCODE: $00001A55 VOL: 0
;PCODE: $00001A56 VOL: 0
;PCODE: $00001A57 VOL: 0
;PCODE: $00001A58 VOL: 0
;PCODE: $00001A59 VOL: 0
;PCODE: $00001A5A VOL: 0
;PCODE: $00001A5B VOL: 0
;		return FR_NOT_READY;
;PCODE: $00001A5C VOL: 0
;PCODE: $00001A5D VOL: 0
;PCODE: $00001A5E VOL: 0
;PCODE: $00001A5F VOL: 0
;PCODE: $00001A60 VOL: 0
;PCODE: $00001A61 VOL: 0
;PCODE: $00001A62 VOL: 0
;
;	return FR_OK;
;PCODE: $00001A63 VOL: 0
;PCODE: $00001A64 VOL: 0
;PCODE: $00001A65 VOL: 0
;PCODE: $00001A66 VOL: 0
;PCODE: $00001A67 VOL: 0
;PCODE: $00001A68 VOL: 0
;PCODE: $00001A69 VOL: 0
;PCODE: $00001A6A VOL: 0
;}
;PCODE: $00001A6B VOL: 0
;
;
;
;
;/*--------------------------------------------------------------------------
;
;   Public Functions
;
;--------------------------------------------------------------------------*/
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Mount/Unmount a Logical Drive                                         */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_mount (
;	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;)
;{
;PCODE: $00001A6C VOL: 0
;PCODE: $00001A6D VOL: 0
;	FATFS *cfs;
;	int vol;
;	FRESULT res;
;   //init_spi(1);
;
;	vol = get_ldnumber(&path);
;PCODE: $00001A6E VOL: 0
;PCODE: $00001A6F VOL: 0
;	*fs -> Y+9
;	*path -> Y+7
;	opt -> Y+6
;	*cfs -> R16,R17
;	vol -> R18,R19
;	res -> R21
;PCODE: $00001A70 VOL: 0
;PCODE: $00001A71 VOL: 0
;PCODE: $00001A72 VOL: 0
;	if (vol < 0) return FR_INVALID_DRIVE;
;PCODE: $00001A73 VOL: 0
;PCODE: $00001A74 VOL: 0
;PCODE: $00001A75 VOL: 0
;PCODE: $00001A76 VOL: 0
;PCODE: $00001A77 VOL: 0
;PCODE: $00001A78 VOL: 0
;	cfs = FatFs[vol];					/* Pointer to fs object */
;PCODE: $00001A79 VOL: 0
;PCODE: $00001A7A VOL: 0
;PCODE: $00001A7B VOL: 0
;PCODE: $00001A7C VOL: 0
;PCODE: $00001A7D VOL: 0
;PCODE: $00001A7E VOL: 0
;
;	if (cfs) {
;PCODE: $00001A7F VOL: 0
;PCODE: $00001A80 VOL: 0
;#if _FS_LOCK
;		clear_lock(cfs);
;#endif
;#if _FS_REENTRANT						/* Discard sync object of the current volume */
;		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;#endif
;		cfs->fs_type = 0;				/* Clear old fs object */
;PCODE: $00001A81 VOL: 0
;PCODE: $00001A82 VOL: 0
;PCODE: $00001A83 VOL: 0
;	}
;
;	if (fs) {
;PCODE: $00001A84 VOL: 0
;PCODE: $00001A85 VOL: 0
;PCODE: $00001A86 VOL: 0
;PCODE: $00001A87 VOL: 0
;		fs->fs_type = 0;				/* Clear new fs object */
;PCODE: $00001A88 VOL: 0
;PCODE: $00001A89 VOL: 0
;PCODE: $00001A8A VOL: 0
;#if _FS_REENTRANT						/* Create sync object for the new volume */
;		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
;#endif
;	}
;	FatFs[vol] = fs;					/* Register new fs object */
;PCODE: $00001A8B VOL: 0
;PCODE: $00001A8C VOL: 0
;PCODE: $00001A8D VOL: 0
;PCODE: $00001A8E VOL: 0
;PCODE: $00001A8F VOL: 0
;PCODE: $00001A90 VOL: 0
;PCODE: $00001A91 VOL: 0
;
;	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;PCODE: $00001A92 VOL: 0
;PCODE: $00001A93 VOL: 0
;PCODE: $00001A94 VOL: 0
;PCODE: $00001A95 VOL: 0
;PCODE: $00001A96 VOL: 0
;PCODE: $00001A97 VOL: 0
;PCODE: $00001A98 VOL: 0
;PCODE: $00001A99 VOL: 0
;PCODE: $00001A9A VOL: 0
;PCODE: $00001A9B VOL: 0
;PCODE: $00001A9C VOL: 0
;PCODE: $00001A9D VOL: 0
;
;	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;PCODE: $00001A9E VOL: 0
;PCODE: $00001A9F VOL: 0
;PCODE: $00001AA0 VOL: 0
;PCODE: $00001AA1 VOL: 0
;PCODE: $00001AA2 VOL: 0
;PCODE: $00001AA3 VOL: 0
;PCODE: $00001AA4 VOL: 0
;PCODE: $00001AA5 VOL: 0
;   // release_spi();
;	LEAVE_FF(fs, res);
;PCODE: $00001AA6 VOL: 0
;PCODE: $00001AA7 VOL: 0
;PCODE: $00001AA8 VOL: 0
;PCODE: $00001AA9 VOL: 0
;}
;PCODE: $00001AAA VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Open or Create a File                                                 */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_open (
;	FIL* fp,			/* Pointer to the blank file object */
;	const TCHAR* path,	/* Pointer to the file name */
;	BYTE mode			/* Access mode and file open mode flags */
;)
;{
;PCODE: $00001AAB VOL: 0
;PCODE: $00001AAC VOL: 0
;	FRESULT res;
;	DIR dj;
;	BYTE *dir;
;	DEF_NAMEBUF;
;    //init_spi(1);
;
;	if (!fp) return FR_INVALID_OBJECT;
;PCODE: $00001AAD VOL: 0
;PCODE: $00001AAE VOL: 0
;PCODE: $00001AAF VOL: 0
;	*fp -> Y+41
;	*path -> Y+39
;	mode -> Y+38
;	res -> R17
;	dj -> Y+16
;	*dir -> R18,R19
;	sfn -> Y+4
;PCODE: $00001AB0 VOL: 0
;PCODE: $00001AB1 VOL: 0
;PCODE: $00001AB2 VOL: 0
;PCODE: $00001AB3 VOL: 0
;PCODE: $00001AB4 VOL: 0
;PCODE: $00001AB5 VOL: 0
;PCODE: $00001AB6 VOL: 0
;	fp->fs = 0;			/* Clear file object */
;PCODE: $00001AB7 VOL: 0
;PCODE: $00001AB8 VOL: 0
;PCODE: $00001AB9 VOL: 0
;PCODE: $00001ABA VOL: 0
;
;	/* Get logical drive number */
;#if !_FS_READONLY
;	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
;PCODE: $00001ABB VOL: 0
;PCODE: $00001ABC VOL: 0
;PCODE: $00001ABD VOL: 0
;	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
;PCODE: $00001ABE VOL: 0
;PCODE: $00001ABF VOL: 0
;PCODE: $00001AC0 VOL: 0
;PCODE: $00001AC1 VOL: 0
;PCODE: $00001AC2 VOL: 0
;PCODE: $00001AC3 VOL: 0
;PCODE: $00001AC4 VOL: 0
;PCODE: $00001AC5 VOL: 0
;PCODE: $00001AC6 VOL: 0
;#else
;	mode &= FA_READ;
;	res = find_volume(&dj.fs, &path, 0);
;#endif
;	if (res == FR_OK) {
;PCODE: $00001AC7 VOL: 0
;PCODE: $00001AC8 VOL: 0
;		INIT_BUF(dj);
;PCODE: $00001AC9 VOL: 0
;PCODE: $00001ACA VOL: 0
;		res = follow_path(&dj, path);	/* Follow the file path */
;PCODE: $00001ACB VOL: 0
;PCODE: $00001ACC VOL: 0
;PCODE: $00001ACD VOL: 0
;PCODE: $00001ACE VOL: 0
;PCODE: $00001ACF VOL: 0
;		dir = dj.dir;
;PCODE: $00001AD0 VOL: 0
;PCODE: $00001AD1 VOL: 0
;#if !_FS_READONLY	/* R/W configuration */
;		if (res == FR_OK) {
;PCODE: $00001AD2 VOL: 0
;PCODE: $00001AD3 VOL: 0
;			if (!dir)	/* Default directory itself */
;PCODE: $00001AD4 VOL: 0
;PCODE: $00001AD5 VOL: 0
;				res = FR_INVALID_NAME;
;PCODE: $00001AD6 VOL: 0
;PCODE: $00001AD7 VOL: 0
;#if _FS_LOCK
;			else
;				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;#endif
;		}
;PCODE: $00001AD8 VOL: 0
;		/* Create or Open a file */
;		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;PCODE: $00001AD9 VOL: 0
;PCODE: $00001ADA VOL: 0
;PCODE: $00001ADB VOL: 0
;PCODE: $00001ADC VOL: 0
;			DWORD dw, cl;
;
;			if (res != FR_OK) {					/* No file, create new */
;PCODE: $00001ADD VOL: 0
;	*fp -> Y+49
;	*path -> Y+47
;	mode -> Y+46
;	dj -> Y+24
;	sfn -> Y+12
;	dw -> Y+4
;	cl -> Y+0
;PCODE: $00001ADE VOL: 0
;PCODE: $00001ADF VOL: 0
;				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;PCODE: $00001AE0 VOL: 0
;PCODE: $00001AE1 VOL: 0
;PCODE: $00001AE2 VOL: 0
;#if _FS_LOCK
;					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;#else
;					res = dir_register(&dj);
;PCODE: $00001AE3 VOL: 0
;PCODE: $00001AE4 VOL: 0
;PCODE: $00001AE5 VOL: 0
;#endif
;				mode |= FA_CREATE_ALWAYS;		/* File is created */
;PCODE: $00001AE6 VOL: 0
;PCODE: $00001AE7 VOL: 0
;PCODE: $00001AE8 VOL: 0
;PCODE: $00001AE9 VOL: 0
;				dir = dj.dir;					/* New entry */
;PCODE: $00001AEA VOL: 0
;PCODE: $00001AEB VOL: 0
;			}
;			else {								/* Any object is already existing */
;PCODE: $00001AEC VOL: 0
;PCODE: $00001AED VOL: 0
;				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;PCODE: $00001AEE VOL: 0
;PCODE: $00001AEF VOL: 0
;PCODE: $00001AF0 VOL: 0
;PCODE: $00001AF1 VOL: 0
;					res = FR_DENIED;
;PCODE: $00001AF2 VOL: 0
;PCODE: $00001AF3 VOL: 0
;				} else {
;PCODE: $00001AF4 VOL: 0
;PCODE: $00001AF5 VOL: 0
;					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;PCODE: $00001AF6 VOL: 0
;PCODE: $00001AF7 VOL: 0
;PCODE: $00001AF8 VOL: 0
;						res = FR_EXIST;
;PCODE: $00001AF9 VOL: 0
;PCODE: $00001AFA VOL: 0
;				}
;PCODE: $00001AFB VOL: 0
;PCODE: $00001AFC VOL: 0
;			}
;PCODE: $00001AFD VOL: 0
;			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;PCODE: $00001AFE VOL: 0
;PCODE: $00001AFF VOL: 0
;PCODE: $00001B00 VOL: 0
;PCODE: $00001B01 VOL: 0
;PCODE: $00001B02 VOL: 0
;PCODE: $00001B03 VOL: 0
;PCODE: $00001B04 VOL: 0
;PCODE: $00001B05 VOL: 0
;PCODE: $00001B06 VOL: 0
;				dw = get_fattime();				/* Created time */
;PCODE: $00001B07 VOL: 0
;PCODE: $00001B08 VOL: 0
;				ST_DWORD(dir+DIR_CrtTime, dw);
;PCODE: $00001B09 VOL: 0
;PCODE: $00001B0A VOL: 0
;PCODE: $00001B0B VOL: 0
;PCODE: $00001B0C VOL: 0
;PCODE: $00001B0D VOL: 0
;PCODE: $00001B0E VOL: 0
;PCODE: $00001B0F VOL: 0
;PCODE: $00001B10 VOL: 0
;PCODE: $00001B11 VOL: 0
;PCODE: $00001B12 VOL: 0
;PCODE: $00001B13 VOL: 0
;PCODE: $00001B14 VOL: 0
;PCODE: $00001B15 VOL: 0
;PCODE: $00001B16 VOL: 0
;PCODE: $00001B17 VOL: 0
;				dir[DIR_Attr] = 0;				/* Reset attribute */
;PCODE: $00001B18 VOL: 0
;PCODE: $00001B19 VOL: 0
;PCODE: $00001B1A VOL: 0
;PCODE: $00001B1B VOL: 0
;				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
;PCODE: $00001B1C VOL: 0
;PCODE: $00001B1D VOL: 0
;PCODE: $00001B1E VOL: 0
;PCODE: $00001B1F VOL: 0
;PCODE: $00001B20 VOL: 0
;PCODE: $00001B21 VOL: 0
;PCODE: $00001B22 VOL: 0
;PCODE: $00001B23 VOL: 0
;PCODE: $00001B24 VOL: 0
;PCODE: $00001B25 VOL: 0
;PCODE: $00001B26 VOL: 0
;PCODE: $00001B27 VOL: 0
;PCODE: $00001B28 VOL: 0
;PCODE: $00001B29 VOL: 0
;PCODE: $00001B2A VOL: 0
;PCODE: $00001B2B VOL: 0
;				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
;PCODE: $00001B2C VOL: 0
;PCODE: $00001B2D VOL: 0
;PCODE: $00001B2E VOL: 0
;PCODE: $00001B2F VOL: 0
;PCODE: $00001B30 VOL: 0
;				st_clust(dir, 0);				/* cluster = 0 */
;PCODE: $00001B31 VOL: 0
;PCODE: $00001B32 VOL: 0
;PCODE: $00001B33 VOL: 0
;				dj.fs->wflag = 1;
;PCODE: $00001B34 VOL: 0
;PCODE: $00001B35 VOL: 0
;PCODE: $00001B36 VOL: 0
;PCODE: $00001B37 VOL: 0
;				if (cl) {						/* Remove the cluster chain if exist */
;PCODE: $00001B38 VOL: 0
;PCODE: $00001B39 VOL: 0
;PCODE: $00001B3A VOL: 0
;					dw = dj.fs->winsect;
;PCODE: $00001B3B VOL: 0
;PCODE: $00001B3C VOL: 0
;PCODE: $00001B3D VOL: 0
;PCODE: $00001B3E VOL: 0
;					res = remove_chain(dj.fs, cl);
;PCODE: $00001B3F VOL: 0
;PCODE: $00001B40 VOL: 0
;PCODE: $00001B41 VOL: 0
;PCODE: $00001B42 VOL: 0
;PCODE: $00001B43 VOL: 0
;					if (res == FR_OK) {
;PCODE: $00001B44 VOL: 0
;PCODE: $00001B45 VOL: 0
;						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;PCODE: $00001B46 VOL: 0
;PCODE: $00001B47 VOL: 0
;PCODE: $00001B48 VOL: 0
;PCODE: $00001B49 VOL: 0
;						res = move_window(dj.fs, dw);
;PCODE: $00001B4A VOL: 0
;PCODE: $00001B4B VOL: 0
;PCODE: $00001B4C VOL: 0
;PCODE: $00001B4D VOL: 0
;PCODE: $00001B4E VOL: 0
;					}
;				}
;PCODE: $00001B4F VOL: 0
;			}
;PCODE: $00001B50 VOL: 0
;		}
;PCODE: $00001B51 VOL: 0
;PCODE: $00001B52 VOL: 0
;		else {	/* Open an existing file */
;PCODE: $00001B53 VOL: 0
;PCODE: $00001B54 VOL: 0
;			if (res == FR_OK) {					/* Follow succeeded */
;PCODE: $00001B55 VOL: 0
;PCODE: $00001B56 VOL: 0
;				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;PCODE: $00001B57 VOL: 0
;PCODE: $00001B58 VOL: 0
;PCODE: $00001B59 VOL: 0
;PCODE: $00001B5A VOL: 0
;					res = FR_NO_FILE;
;PCODE: $00001B5B VOL: 0
;PCODE: $00001B5C VOL: 0
;				} else {
;PCODE: $00001B5D VOL: 0
;PCODE: $00001B5E VOL: 0
;					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;PCODE: $00001B5F VOL: 0
;PCODE: $00001B60 VOL: 0
;PCODE: $00001B61 VOL: 0
;PCODE: $00001B62 VOL: 0
;PCODE: $00001B63 VOL: 0
;PCODE: $00001B64 VOL: 0
;PCODE: $00001B65 VOL: 0
;PCODE: $00001B66 VOL: 0
;PCODE: $00001B67 VOL: 0
;PCODE: $00001B68 VOL: 0
;PCODE: $00001B69 VOL: 0
;						res = FR_DENIED;
;PCODE: $00001B6A VOL: 0
;PCODE: $00001B6B VOL: 0
;				}
;PCODE: $00001B6C VOL: 0
;PCODE: $00001B6D VOL: 0
;			}
;		}
;PCODE: $00001B6E VOL: 0
;PCODE: $00001B6F VOL: 0
;		if (res == FR_OK) {
;PCODE: $00001B70 VOL: 0
;PCODE: $00001B71 VOL: 0
;			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;PCODE: $00001B72 VOL: 0
;PCODE: $00001B73 VOL: 0
;PCODE: $00001B74 VOL: 0
;				mode |= FA__WRITTEN;
;PCODE: $00001B75 VOL: 0
;PCODE: $00001B76 VOL: 0
;PCODE: $00001B77 VOL: 0
;			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;PCODE: $00001B78 VOL: 0
;PCODE: $00001B79 VOL: 0
;PCODE: $00001B7A VOL: 0
;PCODE: $00001B7B VOL: 0
;PCODE: $00001B7C VOL: 0
;PCODE: $00001B7D VOL: 0
;			fp->dir_ptr = dir;
;PCODE: $00001B7E VOL: 0
;PCODE: $00001B7F VOL: 0
;PCODE: $00001B80 VOL: 0
;#if _FS_LOCK
;			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;			if (!fp->lockid) res = FR_INT_ERR;
;#endif
;		}
;
;#else				/* R/O configuration */
;		if (res == FR_OK) {					/* Follow succeeded */
;			dir = dj.dir;
;			if (!dir) {						/* Current directory itself */
;				res = FR_INVALID_NAME;
;			} else {
;				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;					res = FR_NO_FILE;
;			}
;		}
;#endif
;		FREE_BUF();
;PCODE: $00001B81 VOL: 0
;
;		if (res == FR_OK) {
;PCODE: $00001B82 VOL: 0
;PCODE: $00001B83 VOL: 0
;			fp->flag = mode;					/* File access mode */
;PCODE: $00001B84 VOL: 0
;PCODE: $00001B85 VOL: 0
;PCODE: $00001B86 VOL: 0
;			fp->err = 0;						/* Clear error flag */
;PCODE: $00001B87 VOL: 0
;PCODE: $00001B88 VOL: 0
;PCODE: $00001B89 VOL: 0
;PCODE: $00001B8A VOL: 0
;			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;PCODE: $00001B8B VOL: 0
;PCODE: $00001B8C VOL: 0
;PCODE: $00001B8D VOL: 0
;PCODE: $00001B8E VOL: 0
;PCODE: $00001B8F VOL: 0
;PCODE: $00001B90 VOL: 0
;			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
;PCODE: $00001B91 VOL: 0
;PCODE: $00001B92 VOL: 0
;PCODE: $00001B93 VOL: 0
;PCODE: $00001B94 VOL: 0
;PCODE: $00001B95 VOL: 0
;PCODE: $00001B96 VOL: 0
;PCODE: $00001B97 VOL: 0
;PCODE: $00001B98 VOL: 0
;PCODE: $00001B99 VOL: 0
;PCODE: $00001B9A VOL: 0
;PCODE: $00001B9B VOL: 0
;PCODE: $00001B9C VOL: 0
;PCODE: $00001B9D VOL: 0
;PCODE: $00001B9E VOL: 0
;PCODE: $00001B9F VOL: 0
;PCODE: $00001BA0 VOL: 0
;PCODE: $00001BA1 VOL: 0
;PCODE: $00001BA2 VOL: 0
;PCODE: $00001BA3 VOL: 0
;PCODE: $00001BA4 VOL: 0
;PCODE: $00001BA5 VOL: 0
;PCODE: $00001BA6 VOL: 0
;PCODE: $00001BA7 VOL: 0
;PCODE: $00001BA8 VOL: 0
;PCODE: $00001BA9 VOL: 0
;PCODE: $00001BAA VOL: 0
;PCODE: $00001BAB VOL: 0
;PCODE: $00001BAC VOL: 0
;			fp->fptr = 0;						/* File pointer */
;PCODE: $00001BAD VOL: 0
;PCODE: $00001BAE VOL: 0
;PCODE: $00001BAF VOL: 0
;PCODE: $00001BB0 VOL: 0
;			fp->dsect = 0;
;PCODE: $00001BB1 VOL: 0
;PCODE: $00001BB2 VOL: 0
;PCODE: $00001BB3 VOL: 0
;PCODE: $00001BB4 VOL: 0
;#if _USE_FASTSEEK
;			fp->cltbl = 0;						/* Normal seek mode */
;#endif
;			fp->fs = dj.fs;	 					/* Validate file object */
;PCODE: $00001BB5 VOL: 0
;PCODE: $00001BB6 VOL: 0
;PCODE: $00001BB7 VOL: 0
;			fp->id = fp->fs->id;
;PCODE: $00001BB8 VOL: 0
;PCODE: $00001BB9 VOL: 0
;PCODE: $00001BBA VOL: 0
;PCODE: $00001BBB VOL: 0
;PCODE: $00001BBC VOL: 0
;PCODE: $00001BBD VOL: 0
;PCODE: $00001BBE VOL: 0
;		}
;	}
;PCODE: $00001BBF VOL: 0
;   //release_spi();
;	LEAVE_FF(dj.fs, res);
;PCODE: $00001BC0 VOL: 0
;PCODE: $00001BC1 VOL: 0
;PCODE: $00001BC2 VOL: 0
;PCODE: $00001BC3 VOL: 0
;PCODE: $00001BC4 VOL: 0
;}
;PCODE: $00001BC5 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read File                                                             */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_read (
;	FIL* fp, 		/* Pointer to the file object */
;	void* buff,		/* Pointer to data buffer */
;	UINT btr,		/* Number of bytes to read */
;	UINT* br		/* Pointer to number of bytes read */
;)
;{
;PCODE: $00001BC6 VOL: 0
;PCODE: $00001BC7 VOL: 0
;	FRESULT res;
;	DWORD clst, sect, remain;
;	UINT rcnt, cc;
;	BYTE csect, *rbuff = (BYTE*)buff;
;
;
;	*br = 0;	/* Clear read byte counter */
;PCODE: $00001BC8 VOL: 0
;PCODE: $00001BC9 VOL: 0
;PCODE: $00001BCA VOL: 0
;	*fp -> Y+26
;	*buff -> Y+24
;	btr -> Y+22
;	*br -> Y+20
;	res -> R17
;	clst -> Y+16
;	sect -> Y+12
;	remain -> Y+8
;	rcnt -> R18,R19
;	cc -> R20,R21
;	csect -> R16
;	*rbuff -> Y+6
;PCODE: $00001BCB VOL: 0
;PCODE: $00001BCC VOL: 0
;PCODE: $00001BCD VOL: 0
;PCODE: $00001BCE VOL: 0
;PCODE: $00001BCF VOL: 0
;
;	res = validate(fp);							/* Check validity */
;PCODE: $00001BD0 VOL: 0
;PCODE: $00001BD1 VOL: 0
;PCODE: $00001BD2 VOL: 0
;	if (res != FR_OK) LEAVE_FF(fp->fs, res);
;PCODE: $00001BD3 VOL: 0
;PCODE: $00001BD4 VOL: 0
;PCODE: $00001BD5 VOL: 0
;PCODE: $00001BD6 VOL: 0
;PCODE: $00001BD7 VOL: 0
;PCODE: $00001BD8 VOL: 0
;	if (fp->err)								/* Check error */
;PCODE: $00001BD9 VOL: 0
;PCODE: $00001BDA VOL: 0
;PCODE: $00001BDB VOL: 0
;PCODE: $00001BDC VOL: 0
;PCODE: $00001BDD VOL: 0
;		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;PCODE: $00001BDE VOL: 0
;PCODE: $00001BDF VOL: 0
;PCODE: $00001BE0 VOL: 0
;PCODE: $00001BE1 VOL: 0
;PCODE: $00001BE2 VOL: 0
;	if (!(fp->flag & FA_READ)) 					/* Check access mode */
;PCODE: $00001BE3 VOL: 0
;PCODE: $00001BE4 VOL: 0
;PCODE: $00001BE5 VOL: 0
;PCODE: $00001BE6 VOL: 0
;PCODE: $00001BE7 VOL: 0
;		LEAVE_FF(fp->fs, FR_DENIED);
;PCODE: $00001BE8 VOL: 0
;PCODE: $00001BE9 VOL: 0
;PCODE: $00001BEA VOL: 0
;PCODE: $00001BEB VOL: 0
;	remain = fp->fsize - fp->fptr;
;PCODE: $00001BEC VOL: 0
;PCODE: $00001BED VOL: 0
;PCODE: $00001BEE VOL: 0
;PCODE: $00001BEF VOL: 0
;PCODE: $00001BF0 VOL: 0
;PCODE: $00001BF1 VOL: 0
;PCODE: $00001BF2 VOL: 0
;PCODE: $00001BF3 VOL: 0
;PCODE: $00001BF4 VOL: 0
;	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;PCODE: $00001BF5 VOL: 0
;PCODE: $00001BF6 VOL: 0
;PCODE: $00001BF7 VOL: 0
;PCODE: $00001BF8 VOL: 0
;PCODE: $00001BF9 VOL: 0
;PCODE: $00001BFA VOL: 0
;PCODE: $00001BFB VOL: 0
;
;	for ( ;  btr;								/* Repeat until all data read */
;PCODE: $00001BFC VOL: 0
;PCODE: $00001BFD VOL: 0
;PCODE: $00001BFE VOL: 0
;PCODE: $00001BFF VOL: 0
;PCODE: $00001C00 VOL: 0
;PCODE: $00001C01 VOL: 0
;		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;PCODE: $00001C02 VOL: 0
;PCODE: $00001C03 VOL: 0
;PCODE: $00001C04 VOL: 0
;PCODE: $00001C05 VOL: 0
;PCODE: $00001C06 VOL: 0
;PCODE: $00001C07 VOL: 0
;PCODE: $00001C08 VOL: 0
;PCODE: $00001C09 VOL: 0
;PCODE: $00001C0A VOL: 0
;PCODE: $00001C0B VOL: 0
;PCODE: $00001C0C VOL: 0
;PCODE: $00001C0D VOL: 0
;PCODE: $00001C0E VOL: 0
;PCODE: $00001C0F VOL: 0
;PCODE: $00001C10 VOL: 0
;PCODE: $00001C11 VOL: 0
;PCODE: $00001C12 VOL: 0
;PCODE: $00001C13 VOL: 0
;PCODE: $00001C14 VOL: 0
;PCODE: $00001C15 VOL: 0
;PCODE: $00001C16 VOL: 0
;PCODE: $00001C17 VOL: 0
;		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;PCODE: $00001C18 VOL: 0
;PCODE: $00001C19 VOL: 0
;PCODE: $00001C1A VOL: 0
;PCODE: $00001C1B VOL: 0
;PCODE: $00001C1C VOL: 0
;PCODE: $00001C1D VOL: 0
;			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;PCODE: $00001C1E VOL: 0
;PCODE: $00001C1F VOL: 0
;PCODE: $00001C20 VOL: 0
;PCODE: $00001C21 VOL: 0
;PCODE: $00001C22 VOL: 0
;PCODE: $00001C23 VOL: 0
;PCODE: $00001C24 VOL: 0
;PCODE: $00001C25 VOL: 0
;PCODE: $00001C26 VOL: 0
;PCODE: $00001C27 VOL: 0
;PCODE: $00001C28 VOL: 0
;PCODE: $00001C29 VOL: 0
;			if (!csect) {						/* On the cluster boundary? */
;PCODE: $00001C2A VOL: 0
;PCODE: $00001C2B VOL: 0
;				if (fp->fptr == 0) {			/* On the top of the file? */
;PCODE: $00001C2C VOL: 0
;PCODE: $00001C2D VOL: 0
;PCODE: $00001C2E VOL: 0
;PCODE: $00001C2F VOL: 0
;PCODE: $00001C30 VOL: 0
;					clst = fp->sclust;			/* Follow from the origin */
;PCODE: $00001C31 VOL: 0
;PCODE: $00001C32 VOL: 0
;PCODE: $00001C33 VOL: 0
;PCODE: $00001C34 VOL: 0
;				} else {						/* Middle or end of the file */
;PCODE: $00001C35 VOL: 0
;PCODE: $00001C36 VOL: 0
;#if _USE_FASTSEEK
;					if (fp->cltbl)
;						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;					else
;#endif
;						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;PCODE: $00001C37 VOL: 0
;PCODE: $00001C38 VOL: 0
;PCODE: $00001C39 VOL: 0
;PCODE: $00001C3A VOL: 0
;PCODE: $00001C3B VOL: 0
;PCODE: $00001C3C VOL: 0
;PCODE: $00001C3D VOL: 0
;				}
;PCODE: $00001C3E VOL: 0
;				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00001C3F VOL: 0
;PCODE: $00001C40 VOL: 0
;PCODE: $00001C41 VOL: 0
;PCODE: $00001C42 VOL: 0
;PCODE: $00001C43 VOL: 0
;PCODE: $00001C44 VOL: 0
;PCODE: $00001C45 VOL: 0
;PCODE: $00001C46 VOL: 0
;PCODE: $00001C47 VOL: 0
;PCODE: $00001C48 VOL: 0
;PCODE: $00001C49 VOL: 0
;PCODE: $00001C4A VOL: 0
;				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001C4B VOL: 0
;PCODE: $00001C4C VOL: 0
;PCODE: $00001C4D VOL: 0
;PCODE: $00001C4E VOL: 0
;PCODE: $00001C4F VOL: 0
;PCODE: $00001C50 VOL: 0
;PCODE: $00001C51 VOL: 0
;PCODE: $00001C52 VOL: 0
;PCODE: $00001C53 VOL: 0
;PCODE: $00001C54 VOL: 0
;PCODE: $00001C55 VOL: 0
;PCODE: $00001C56 VOL: 0
;				fp->clust = clst;				/* Update current cluster */
;PCODE: $00001C57 VOL: 0
;PCODE: $00001C58 VOL: 0
;PCODE: $00001C59 VOL: 0
;			}
;			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;PCODE: $00001C5A VOL: 0
;PCODE: $00001C5B VOL: 0
;PCODE: $00001C5C VOL: 0
;PCODE: $00001C5D VOL: 0
;PCODE: $00001C5E VOL: 0
;PCODE: $00001C5F VOL: 0
;PCODE: $00001C60 VOL: 0
;PCODE: $00001C61 VOL: 0
;			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00001C62 VOL: 0
;PCODE: $00001C63 VOL: 0
;PCODE: $00001C64 VOL: 0
;PCODE: $00001C65 VOL: 0
;PCODE: $00001C66 VOL: 0
;PCODE: $00001C67 VOL: 0
;PCODE: $00001C68 VOL: 0
;PCODE: $00001C69 VOL: 0
;PCODE: $00001C6A VOL: 0
;PCODE: $00001C6B VOL: 0
;PCODE: $00001C6C VOL: 0
;PCODE: $00001C6D VOL: 0
;			sect += csect;
;PCODE: $00001C6E VOL: 0
;PCODE: $00001C6F VOL: 0
;PCODE: $00001C70 VOL: 0
;PCODE: $00001C71 VOL: 0
;PCODE: $00001C72 VOL: 0
;PCODE: $00001C73 VOL: 0
;			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;PCODE: $00001C74 VOL: 0
;PCODE: $00001C75 VOL: 0
;PCODE: $00001C76 VOL: 0
;PCODE: $00001C77 VOL: 0
;			if (cc) {							/* Read maximum contiguous sectors directly */
;PCODE: $00001C78 VOL: 0
;PCODE: $00001C79 VOL: 0
;				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;PCODE: $00001C7A VOL: 0
;PCODE: $00001C7B VOL: 0
;PCODE: $00001C7C VOL: 0
;PCODE: $00001C7D VOL: 0
;PCODE: $00001C7E VOL: 0
;PCODE: $00001C7F VOL: 0
;PCODE: $00001C80 VOL: 0
;PCODE: $00001C81 VOL: 0
;PCODE: $00001C82 VOL: 0
;PCODE: $00001C83 VOL: 0
;PCODE: $00001C84 VOL: 0
;					cc = fp->fs->csize - csect;
;PCODE: $00001C85 VOL: 0
;PCODE: $00001C86 VOL: 0
;PCODE: $00001C87 VOL: 0
;PCODE: $00001C88 VOL: 0
;PCODE: $00001C89 VOL: 0
;PCODE: $00001C8A VOL: 0
;PCODE: $00001C8B VOL: 0
;PCODE: $00001C8C VOL: 0
;PCODE: $00001C8D VOL: 0
;				if (disk_read(fp->fs->drv, rbuff, sect, cc))
;PCODE: $00001C8E VOL: 0
;PCODE: $00001C8F VOL: 0
;PCODE: $00001C90 VOL: 0
;PCODE: $00001C91 VOL: 0
;PCODE: $00001C92 VOL: 0
;PCODE: $00001C93 VOL: 0
;PCODE: $00001C94 VOL: 0
;PCODE: $00001C95 VOL: 0
;PCODE: $00001C96 VOL: 0
;PCODE: $00001C97 VOL: 0
;PCODE: $00001C98 VOL: 0
;PCODE: $00001C99 VOL: 0
;PCODE: $00001C9A VOL: 0
;					ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001C9B VOL: 0
;PCODE: $00001C9C VOL: 0
;PCODE: $00001C9D VOL: 0
;PCODE: $00001C9E VOL: 0
;PCODE: $00001C9F VOL: 0
;PCODE: $00001CA0 VOL: 0
;PCODE: $00001CA1 VOL: 0
;PCODE: $00001CA2 VOL: 0
;PCODE: $00001CA3 VOL: 0
;#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sect ...
;#if _FS_TINY
;				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;PCODE: $00001CA4 VOL: 0
;PCODE: $00001CA5 VOL: 0
;PCODE: $00001CA6 VOL: 0
;PCODE: $00001CA7 VOL: 0
;PCODE: $00001CA8 VOL: 0
;PCODE: $00001CA9 VOL: 0
;PCODE: $00001CAA VOL: 0
;PCODE: $00001CAB VOL: 0
;PCODE: $00001CAC VOL: 0
;PCODE: $00001CAD VOL: 0
;PCODE: $00001CAE VOL: 0
;PCODE: $00001CAF VOL: 0
;PCODE: $00001CB0 VOL: 0
;PCODE: $00001CB1 VOL: 0
;PCODE: $00001CB2 VOL: 0
;PCODE: $00001CB3 VOL: 0
;PCODE: $00001CB4 VOL: 0
;PCODE: $00001CB5 VOL: 0
;PCODE: $00001CB6 VOL: 0
;PCODE: $00001CB7 VOL: 0
;PCODE: $00001CB8 VOL: 0
;					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;PCODE: $00001CB9 VOL: 0
;PCODE: $00001CBA VOL: 0
;PCODE: $00001CBB VOL: 0
;PCODE: $00001CBC VOL: 0
;PCODE: $00001CBD VOL: 0
;PCODE: $00001CBE VOL: 0
;PCODE: $00001CBF VOL: 0
;PCODE: $00001CC0 VOL: 0
;PCODE: $00001CC1 VOL: 0
;PCODE: $00001CC2 VOL: 0
;PCODE: $00001CC3 VOL: 0
;PCODE: $00001CC4 VOL: 0
;PCODE: $00001CC5 VOL: 0
;PCODE: $00001CC6 VOL: 0
;PCODE: $00001CC7 VOL: 0
;PCODE: $00001CC8 VOL: 0
;PCODE: $00001CC9 VOL: 0
;PCODE: $00001CCA VOL: 0
;PCODE: $00001CCB VOL: 0
;PCODE: $00001CCC VOL: 0
;#else
;				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
;#endif
;#endif
;				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;PCODE: $00001CCD VOL: 0
;PCODE: $00001CCE VOL: 0
;PCODE: $00001CCF VOL: 0
;PCODE: $00001CD0 VOL: 0
;PCODE: $00001CD1 VOL: 0
;				continue;
;PCODE: $00001CD2 VOL: 0
;			}
;#if !_FS_TINY
;			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;#if !_FS_READONLY
;				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;						ABORT(fp->fs, FR_DISK_ERR);
;					fp->flag &= ~FA__DIRTY;
;				}
;#endif
;				if (disk_read(fp->fs->drv, fp->buf, sect, 1))	/* Fill sector cache */
;					ABORT(fp->fs, FR_DISK_ERR);
;			}
;#endif
;			fp->dsect = sect;
;PCODE: $00001CD3 VOL: 0
;PCODE: $00001CD4 VOL: 0
;PCODE: $00001CD5 VOL: 0
;PCODE: $00001CD6 VOL: 0
;		}
;		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;PCODE: $00001CD7 VOL: 0
;PCODE: $00001CD8 VOL: 0
;PCODE: $00001CD9 VOL: 0
;PCODE: $00001CDA VOL: 0
;PCODE: $00001CDB VOL: 0
;PCODE: $00001CDC VOL: 0
;PCODE: $00001CDD VOL: 0
;PCODE: $00001CDE VOL: 0
;		if (rcnt > btr) rcnt = btr;
;PCODE: $00001CDF VOL: 0
;PCODE: $00001CE0 VOL: 0
;PCODE: $00001CE1 VOL: 0
;PCODE: $00001CE2 VOL: 0
;PCODE: $00001CE3 VOL: 0
;#if _FS_TINY
;		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
;PCODE: $00001CE4 VOL: 0
;PCODE: $00001CE5 VOL: 0
;PCODE: $00001CE6 VOL: 0
;PCODE: $00001CE7 VOL: 0
;PCODE: $00001CE8 VOL: 0
;PCODE: $00001CE9 VOL: 0
;PCODE: $00001CEA VOL: 0
;PCODE: $00001CEB VOL: 0
;PCODE: $00001CEC VOL: 0
;			ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001CED VOL: 0
;PCODE: $00001CEE VOL: 0
;PCODE: $00001CEF VOL: 0
;PCODE: $00001CF0 VOL: 0
;PCODE: $00001CF1 VOL: 0
;PCODE: $00001CF2 VOL: 0
;PCODE: $00001CF3 VOL: 0
;PCODE: $00001CF4 VOL: 0
;PCODE: $00001CF5 VOL: 0
;		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;PCODE: $00001CF6 VOL: 0
;PCODE: $00001CF7 VOL: 0
;PCODE: $00001CF8 VOL: 0
;PCODE: $00001CF9 VOL: 0
;PCODE: $00001CFA VOL: 0
;PCODE: $00001CFB VOL: 0
;PCODE: $00001CFC VOL: 0
;PCODE: $00001CFD VOL: 0
;PCODE: $00001CFE VOL: 0
;PCODE: $00001CFF VOL: 0
;PCODE: $00001D00 VOL: 0
;PCODE: $00001D01 VOL: 0
;PCODE: $00001D02 VOL: 0
;PCODE: $00001D03 VOL: 0
;#else
;		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;#endif
;	}
;PCODE: $00001D04 VOL: 0
;PCODE: $00001D05 VOL: 0
;PCODE: $00001D06 VOL: 0
;PCODE: $00001D07 VOL: 0
;PCODE: $00001D08 VOL: 0
;PCODE: $00001D09 VOL: 0
;PCODE: $00001D0A VOL: 0
;PCODE: $00001D0B VOL: 0
;PCODE: $00001D0C VOL: 0
;PCODE: $00001D0D VOL: 0
;PCODE: $00001D0E VOL: 0
;PCODE: $00001D0F VOL: 0
;PCODE: $00001D10 VOL: 0
;PCODE: $00001D11 VOL: 0
;PCODE: $00001D12 VOL: 0
;PCODE: $00001D13 VOL: 0
;PCODE: $00001D14 VOL: 0
;PCODE: $00001D15 VOL: 0
;PCODE: $00001D16 VOL: 0
;PCODE: $00001D17 VOL: 0
;PCODE: $00001D18 VOL: 0
;PCODE: $00001D19 VOL: 0
;PCODE: $00001D1A VOL: 0
;PCODE: $00001D1B VOL: 0
;PCODE: $00001D1C VOL: 0
;
;	LEAVE_FF(fp->fs, FR_OK);
;PCODE: $00001D1D VOL: 0
;PCODE: $00001D1E VOL: 0
;PCODE: $00001D1F VOL: 0
;PCODE: $00001D20 VOL: 0
;}
;PCODE: $00001D21 VOL: 0
;
;
;
;
;#if !_FS_READONLY
;/*-----------------------------------------------------------------------*/
;/* Write File                                                            */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_write (
;	FIL* fp,			/* Pointer to the file object */
;	const void *buff,	/* Pointer to the data to be written */
;	UINT btw,			/* Number of bytes to write */
;	UINT* bw			/* Pointer to number of bytes written */
;)
;{
;PCODE: $00001D22 VOL: 0
;PCODE: $00001D23 VOL: 0
;	FRESULT res;
;	DWORD clst, sect;
;	UINT wcnt, cc;
;	const BYTE *wbuff = (const BYTE*)buff;
;	BYTE csect;
;    //init_spi(1);
;
;	*bw = 0;	/* Clear write byte counter */
;PCODE: $00001D24 VOL: 0
;PCODE: $00001D25 VOL: 0
;PCODE: $00001D26 VOL: 0
;	*fp -> Y+22
;	*buff -> Y+20
;	btw -> Y+18
;	*bw -> Y+16
;	res -> R17
;	clst -> Y+12
;	sect -> Y+8
;	wcnt -> R18,R19
;	cc -> R20,R21
;	*wbuff -> Y+6
;	csect -> R16
;PCODE: $00001D27 VOL: 0
;PCODE: $00001D28 VOL: 0
;PCODE: $00001D29 VOL: 0
;PCODE: $00001D2A VOL: 0
;PCODE: $00001D2B VOL: 0
;
;	res = validate(fp);						/* Check validity */
;PCODE: $00001D2C VOL: 0
;PCODE: $00001D2D VOL: 0
;PCODE: $00001D2E VOL: 0
;	if (res != FR_OK) LEAVE_FF(fp->fs, res);
;PCODE: $00001D2F VOL: 0
;PCODE: $00001D30 VOL: 0
;PCODE: $00001D31 VOL: 0
;PCODE: $00001D32 VOL: 0
;PCODE: $00001D33 VOL: 0
;PCODE: $00001D34 VOL: 0
;	if (fp->err)							/* Check error */
;PCODE: $00001D35 VOL: 0
;PCODE: $00001D36 VOL: 0
;PCODE: $00001D37 VOL: 0
;PCODE: $00001D38 VOL: 0
;PCODE: $00001D39 VOL: 0
;		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;PCODE: $00001D3A VOL: 0
;PCODE: $00001D3B VOL: 0
;PCODE: $00001D3C VOL: 0
;PCODE: $00001D3D VOL: 0
;PCODE: $00001D3E VOL: 0
;	if (!(fp->flag & FA_WRITE))				/* Check access mode */
;PCODE: $00001D3F VOL: 0
;PCODE: $00001D40 VOL: 0
;PCODE: $00001D41 VOL: 0
;PCODE: $00001D42 VOL: 0
;PCODE: $00001D43 VOL: 0
;		LEAVE_FF(fp->fs, FR_DENIED);
;PCODE: $00001D44 VOL: 0
;PCODE: $00001D45 VOL: 0
;PCODE: $00001D46 VOL: 0
;PCODE: $00001D47 VOL: 0
;	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;PCODE: $00001D48 VOL: 0
;PCODE: $00001D49 VOL: 0
;PCODE: $00001D4A VOL: 0
;PCODE: $00001D4B VOL: 0
;PCODE: $00001D4C VOL: 0
;PCODE: $00001D4D VOL: 0
;PCODE: $00001D4E VOL: 0
;PCODE: $00001D4F VOL: 0
;PCODE: $00001D50 VOL: 0
;PCODE: $00001D51 VOL: 0
;PCODE: $00001D52 VOL: 0
;PCODE: $00001D53 VOL: 0
;PCODE: $00001D54 VOL: 0
;PCODE: $00001D55 VOL: 0
;PCODE: $00001D56 VOL: 0
;
;	for ( ;  btw;							/* Repeat until all data written */
;PCODE: $00001D57 VOL: 0
;PCODE: $00001D58 VOL: 0
;PCODE: $00001D59 VOL: 0
;PCODE: $00001D5A VOL: 0
;PCODE: $00001D5B VOL: 0
;PCODE: $00001D5C VOL: 0
;		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;PCODE: $00001D5D VOL: 0
;PCODE: $00001D5E VOL: 0
;PCODE: $00001D5F VOL: 0
;PCODE: $00001D60 VOL: 0
;PCODE: $00001D61 VOL: 0
;PCODE: $00001D62 VOL: 0
;PCODE: $00001D63 VOL: 0
;PCODE: $00001D64 VOL: 0
;PCODE: $00001D65 VOL: 0
;PCODE: $00001D66 VOL: 0
;PCODE: $00001D67 VOL: 0
;PCODE: $00001D68 VOL: 0
;PCODE: $00001D69 VOL: 0
;PCODE: $00001D6A VOL: 0
;PCODE: $00001D6B VOL: 0
;PCODE: $00001D6C VOL: 0
;PCODE: $00001D6D VOL: 0
;PCODE: $00001D6E VOL: 0
;PCODE: $00001D6F VOL: 0
;PCODE: $00001D70 VOL: 0
;PCODE: $00001D71 VOL: 0
;PCODE: $00001D72 VOL: 0
;		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;PCODE: $00001D73 VOL: 0
;PCODE: $00001D74 VOL: 0
;PCODE: $00001D75 VOL: 0
;PCODE: $00001D76 VOL: 0
;PCODE: $00001D77 VOL: 0
;PCODE: $00001D78 VOL: 0
;			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;PCODE: $00001D79 VOL: 0
;PCODE: $00001D7A VOL: 0
;PCODE: $00001D7B VOL: 0
;PCODE: $00001D7C VOL: 0
;PCODE: $00001D7D VOL: 0
;PCODE: $00001D7E VOL: 0
;PCODE: $00001D7F VOL: 0
;PCODE: $00001D80 VOL: 0
;PCODE: $00001D81 VOL: 0
;PCODE: $00001D82 VOL: 0
;PCODE: $00001D83 VOL: 0
;PCODE: $00001D84 VOL: 0
;			if (!csect) {					/* On the cluster boundary? */
;PCODE: $00001D85 VOL: 0
;PCODE: $00001D86 VOL: 0
;				if (fp->fptr == 0) {		/* On the top of the file? */
;PCODE: $00001D87 VOL: 0
;PCODE: $00001D88 VOL: 0
;PCODE: $00001D89 VOL: 0
;PCODE: $00001D8A VOL: 0
;PCODE: $00001D8B VOL: 0
;					clst = fp->sclust;		/* Follow from the origin */
;PCODE: $00001D8C VOL: 0
;PCODE: $00001D8D VOL: 0
;PCODE: $00001D8E VOL: 0
;PCODE: $00001D8F VOL: 0
;					if (clst == 0)			/* When no cluster is allocated, */
;PCODE: $00001D90 VOL: 0
;PCODE: $00001D91 VOL: 0
;PCODE: $00001D92 VOL: 0
;						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;PCODE: $00001D93 VOL: 0
;PCODE: $00001D94 VOL: 0
;PCODE: $00001D95 VOL: 0
;PCODE: $00001D96 VOL: 0
;PCODE: $00001D97 VOL: 0
;PCODE: $00001D98 VOL: 0
;PCODE: $00001D99 VOL: 0
;PCODE: $00001D9A VOL: 0
;				} else {					/* Middle or end of the file */
;PCODE: $00001D9B VOL: 0
;PCODE: $00001D9C VOL: 0
;PCODE: $00001D9D VOL: 0
;#if _USE_FASTSEEK
;					if (fp->cltbl)
;						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;					else
;#endif
;						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;PCODE: $00001D9E VOL: 0
;PCODE: $00001D9F VOL: 0
;PCODE: $00001DA0 VOL: 0
;PCODE: $00001DA1 VOL: 0
;PCODE: $00001DA2 VOL: 0
;PCODE: $00001DA3 VOL: 0
;PCODE: $00001DA4 VOL: 0
;				}
;PCODE: $00001DA5 VOL: 0
;				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;PCODE: $00001DA6 VOL: 0
;PCODE: $00001DA7 VOL: 0
;PCODE: $00001DA8 VOL: 0
;PCODE: $00001DA9 VOL: 0
;				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00001DAA VOL: 0
;PCODE: $00001DAB VOL: 0
;PCODE: $00001DAC VOL: 0
;PCODE: $00001DAD VOL: 0
;PCODE: $00001DAE VOL: 0
;PCODE: $00001DAF VOL: 0
;PCODE: $00001DB0 VOL: 0
;PCODE: $00001DB1 VOL: 0
;PCODE: $00001DB2 VOL: 0
;PCODE: $00001DB3 VOL: 0
;PCODE: $00001DB4 VOL: 0
;PCODE: $00001DB5 VOL: 0
;PCODE: $00001DB6 VOL: 0
;				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001DB7 VOL: 0
;PCODE: $00001DB8 VOL: 0
;PCODE: $00001DB9 VOL: 0
;PCODE: $00001DBA VOL: 0
;PCODE: $00001DBB VOL: 0
;PCODE: $00001DBC VOL: 0
;PCODE: $00001DBD VOL: 0
;PCODE: $00001DBE VOL: 0
;PCODE: $00001DBF VOL: 0
;PCODE: $00001DC0 VOL: 0
;PCODE: $00001DC1 VOL: 0
;PCODE: $00001DC2 VOL: 0
;				fp->clust = clst;			/* Update current cluster */
;PCODE: $00001DC3 VOL: 0
;PCODE: $00001DC4 VOL: 0
;PCODE: $00001DC5 VOL: 0
;			}
;#if _FS_TINY
;			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;PCODE: $00001DC6 VOL: 0
;PCODE: $00001DC7 VOL: 0
;PCODE: $00001DC8 VOL: 0
;PCODE: $00001DC9 VOL: 0
;PCODE: $00001DCA VOL: 0
;PCODE: $00001DCB VOL: 0
;PCODE: $00001DCC VOL: 0
;PCODE: $00001DCD VOL: 0
;PCODE: $00001DCE VOL: 0
;PCODE: $00001DCF VOL: 0
;PCODE: $00001DD0 VOL: 0
;PCODE: $00001DD1 VOL: 0
;PCODE: $00001DD2 VOL: 0
;PCODE: $00001DD3 VOL: 0
;PCODE: $00001DD4 VOL: 0
;PCODE: $00001DD5 VOL: 0
;PCODE: $00001DD6 VOL: 0
;PCODE: $00001DD7 VOL: 0
;PCODE: $00001DD8 VOL: 0
;PCODE: $00001DD9 VOL: 0
;PCODE: $00001DDA VOL: 0
;PCODE: $00001DDB VOL: 0
;PCODE: $00001DDC VOL: 0
;				ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001DDD VOL: 0
;PCODE: $00001DDE VOL: 0
;PCODE: $00001DDF VOL: 0
;PCODE: $00001DE0 VOL: 0
;PCODE: $00001DE1 VOL: 0
;PCODE: $00001DE2 VOL: 0
;PCODE: $00001DE3 VOL: 0
;PCODE: $00001DE4 VOL: 0
;PCODE: $00001DE5 VOL: 0
;#else
;			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;					ABORT(fp->fs, FR_DISK_ERR);
;				fp->flag &= ~FA__DIRTY;
;			}
;#endif
;			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;PCODE: $00001DE6 VOL: 0
;PCODE: $00001DE7 VOL: 0
;PCODE: $00001DE8 VOL: 0
;PCODE: $00001DE9 VOL: 0
;PCODE: $00001DEA VOL: 0
;PCODE: $00001DEB VOL: 0
;PCODE: $00001DEC VOL: 0
;			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00001DED VOL: 0
;PCODE: $00001DEE VOL: 0
;PCODE: $00001DEF VOL: 0
;PCODE: $00001DF0 VOL: 0
;PCODE: $00001DF1 VOL: 0
;PCODE: $00001DF2 VOL: 0
;PCODE: $00001DF3 VOL: 0
;PCODE: $00001DF4 VOL: 0
;PCODE: $00001DF5 VOL: 0
;PCODE: $00001DF6 VOL: 0
;PCODE: $00001DF7 VOL: 0
;PCODE: $00001DF8 VOL: 0
;			sect += csect;
;PCODE: $00001DF9 VOL: 0
;PCODE: $00001DFA VOL: 0
;PCODE: $00001DFB VOL: 0
;PCODE: $00001DFC VOL: 0
;PCODE: $00001DFD VOL: 0
;PCODE: $00001DFE VOL: 0
;			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;PCODE: $00001DFF VOL: 0
;PCODE: $00001E00 VOL: 0
;PCODE: $00001E01 VOL: 0
;PCODE: $00001E02 VOL: 0
;			if (cc) {						/* Write maximum contiguous sectors directly */
;PCODE: $00001E03 VOL: 0
;PCODE: $00001E04 VOL: 0
;				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;PCODE: $00001E05 VOL: 0
;PCODE: $00001E06 VOL: 0
;PCODE: $00001E07 VOL: 0
;PCODE: $00001E08 VOL: 0
;PCODE: $00001E09 VOL: 0
;PCODE: $00001E0A VOL: 0
;PCODE: $00001E0B VOL: 0
;PCODE: $00001E0C VOL: 0
;PCODE: $00001E0D VOL: 0
;PCODE: $00001E0E VOL: 0
;PCODE: $00001E0F VOL: 0
;					cc = fp->fs->csize - csect;
;PCODE: $00001E10 VOL: 0
;PCODE: $00001E11 VOL: 0
;PCODE: $00001E12 VOL: 0
;PCODE: $00001E13 VOL: 0
;PCODE: $00001E14 VOL: 0
;PCODE: $00001E15 VOL: 0
;PCODE: $00001E16 VOL: 0
;PCODE: $00001E17 VOL: 0
;PCODE: $00001E18 VOL: 0
;				if (disk_write(fp->fs->drv, wbuff, sect, cc))
;PCODE: $00001E19 VOL: 0
;PCODE: $00001E1A VOL: 0
;PCODE: $00001E1B VOL: 0
;PCODE: $00001E1C VOL: 0
;PCODE: $00001E1D VOL: 0
;PCODE: $00001E1E VOL: 0
;PCODE: $00001E1F VOL: 0
;PCODE: $00001E20 VOL: 0
;PCODE: $00001E21 VOL: 0
;PCODE: $00001E22 VOL: 0
;PCODE: $00001E23 VOL: 0
;PCODE: $00001E24 VOL: 0
;PCODE: $00001E25 VOL: 0
;					ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001E26 VOL: 0
;PCODE: $00001E27 VOL: 0
;PCODE: $00001E28 VOL: 0
;PCODE: $00001E29 VOL: 0
;PCODE: $00001E2A VOL: 0
;PCODE: $00001E2B VOL: 0
;PCODE: $00001E2C VOL: 0
;PCODE: $00001E2D VOL: 0
;PCODE: $00001E2E VOL: 0
;#if _FS_MINIMIZE <= 2
;#if _FS_TINY
;				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;PCODE: $00001E2F VOL: 0
;PCODE: $00001E30 VOL: 0
;PCODE: $00001E31 VOL: 0
;PCODE: $00001E32 VOL: 0
;PCODE: $00001E33 VOL: 0
;PCODE: $00001E34 VOL: 0
;PCODE: $00001E35 VOL: 0
;PCODE: $00001E36 VOL: 0
;PCODE: $00001E37 VOL: 0
;PCODE: $00001E38 VOL: 0
;PCODE: $00001E39 VOL: 0
;PCODE: $00001E3A VOL: 0
;					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;PCODE: $00001E3B VOL: 0
;PCODE: $00001E3C VOL: 0
;PCODE: $00001E3D VOL: 0
;PCODE: $00001E3E VOL: 0
;PCODE: $00001E3F VOL: 0
;PCODE: $00001E40 VOL: 0
;PCODE: $00001E41 VOL: 0
;PCODE: $00001E42 VOL: 0
;PCODE: $00001E43 VOL: 0
;PCODE: $00001E44 VOL: 0
;PCODE: $00001E45 VOL: 0
;PCODE: $00001E46 VOL: 0
;PCODE: $00001E47 VOL: 0
;PCODE: $00001E48 VOL: 0
;PCODE: $00001E49 VOL: 0
;PCODE: $00001E4A VOL: 0
;PCODE: $00001E4B VOL: 0
;PCODE: $00001E4C VOL: 0
;PCODE: $00001E4D VOL: 0
;PCODE: $00001E4E VOL: 0
;					fp->fs->wflag = 0;
;PCODE: $00001E4F VOL: 0
;PCODE: $00001E50 VOL: 0
;PCODE: $00001E51 VOL: 0
;PCODE: $00001E52 VOL: 0
;PCODE: $00001E53 VOL: 0
;				}
;#else
;				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;					fp->flag &= ~FA__DIRTY;
;				}
;#endif
;#endif
;				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;PCODE: $00001E54 VOL: 0
;PCODE: $00001E55 VOL: 0
;PCODE: $00001E56 VOL: 0
;PCODE: $00001E57 VOL: 0
;PCODE: $00001E58 VOL: 0
;				continue;
;PCODE: $00001E59 VOL: 0
;			}
;#if _FS_TINY
;			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;PCODE: $00001E5A VOL: 0
;PCODE: $00001E5B VOL: 0
;PCODE: $00001E5C VOL: 0
;PCODE: $00001E5D VOL: 0
;PCODE: $00001E5E VOL: 0
;PCODE: $00001E5F VOL: 0
;PCODE: $00001E60 VOL: 0
;PCODE: $00001E61 VOL: 0
;PCODE: $00001E62 VOL: 0
;PCODE: $00001E63 VOL: 0
;				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001E64 VOL: 0
;PCODE: $00001E65 VOL: 0
;PCODE: $00001E66 VOL: 0
;PCODE: $00001E67 VOL: 0
;PCODE: $00001E68 VOL: 0
;PCODE: $00001E69 VOL: 0
;PCODE: $00001E6A VOL: 0
;PCODE: $00001E6B VOL: 0
;PCODE: $00001E6C VOL: 0
;PCODE: $00001E6D VOL: 0
;PCODE: $00001E6E VOL: 0
;PCODE: $00001E6F VOL: 0
;PCODE: $00001E70 VOL: 0
;PCODE: $00001E71 VOL: 0
;PCODE: $00001E72 VOL: 0
;				fp->fs->winsect = sect;
;PCODE: $00001E73 VOL: 0
;PCODE: $00001E74 VOL: 0
;PCODE: $00001E75 VOL: 0
;PCODE: $00001E76 VOL: 0
;PCODE: $00001E77 VOL: 0
;			}
;#else
;			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;				if (fp->fptr < fp->fsize &&
;					disk_read(fp->fs->drv, fp->buf, sect, 1))
;						ABORT(fp->fs, FR_DISK_ERR);
;			}
;#endif
;			fp->dsect = sect;
;PCODE: $00001E78 VOL: 0
;PCODE: $00001E79 VOL: 0
;PCODE: $00001E7A VOL: 0
;PCODE: $00001E7B VOL: 0
;		}
;		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;PCODE: $00001E7C VOL: 0
;PCODE: $00001E7D VOL: 0
;PCODE: $00001E7E VOL: 0
;PCODE: $00001E7F VOL: 0
;PCODE: $00001E80 VOL: 0
;PCODE: $00001E81 VOL: 0
;PCODE: $00001E82 VOL: 0
;PCODE: $00001E83 VOL: 0
;		if (wcnt > btw) wcnt = btw;
;PCODE: $00001E84 VOL: 0
;PCODE: $00001E85 VOL: 0
;PCODE: $00001E86 VOL: 0
;PCODE: $00001E87 VOL: 0
;PCODE: $00001E88 VOL: 0
;#if _FS_TINY
;		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
;PCODE: $00001E89 VOL: 0
;PCODE: $00001E8A VOL: 0
;PCODE: $00001E8B VOL: 0
;PCODE: $00001E8C VOL: 0
;PCODE: $00001E8D VOL: 0
;PCODE: $00001E8E VOL: 0
;PCODE: $00001E8F VOL: 0
;PCODE: $00001E90 VOL: 0
;PCODE: $00001E91 VOL: 0
;			ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001E92 VOL: 0
;PCODE: $00001E93 VOL: 0
;PCODE: $00001E94 VOL: 0
;PCODE: $00001E95 VOL: 0
;PCODE: $00001E96 VOL: 0
;PCODE: $00001E97 VOL: 0
;PCODE: $00001E98 VOL: 0
;PCODE: $00001E99 VOL: 0
;PCODE: $00001E9A VOL: 0
;		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;PCODE: $00001E9B VOL: 0
;PCODE: $00001E9C VOL: 0
;PCODE: $00001E9D VOL: 0
;PCODE: $00001E9E VOL: 0
;PCODE: $00001E9F VOL: 0
;PCODE: $00001EA0 VOL: 0
;PCODE: $00001EA1 VOL: 0
;PCODE: $00001EA2 VOL: 0
;PCODE: $00001EA3 VOL: 0
;PCODE: $00001EA4 VOL: 0
;PCODE: $00001EA5 VOL: 0
;PCODE: $00001EA6 VOL: 0
;PCODE: $00001EA7 VOL: 0
;PCODE: $00001EA8 VOL: 0
;		fp->fs->wflag = 1;
;PCODE: $00001EA9 VOL: 0
;PCODE: $00001EAA VOL: 0
;PCODE: $00001EAB VOL: 0
;PCODE: $00001EAC VOL: 0
;PCODE: $00001EAD VOL: 0
;#else
;		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;		fp->flag |= FA__DIRTY;
;#endif
;	}
;PCODE: $00001EAE VOL: 0
;PCODE: $00001EAF VOL: 0
;PCODE: $00001EB0 VOL: 0
;PCODE: $00001EB1 VOL: 0
;PCODE: $00001EB2 VOL: 0
;PCODE: $00001EB3 VOL: 0
;PCODE: $00001EB4 VOL: 0
;PCODE: $00001EB5 VOL: 0
;PCODE: $00001EB6 VOL: 0
;PCODE: $00001EB7 VOL: 0
;PCODE: $00001EB8 VOL: 0
;PCODE: $00001EB9 VOL: 0
;PCODE: $00001EBA VOL: 0
;PCODE: $00001EBB VOL: 0
;PCODE: $00001EBC VOL: 0
;PCODE: $00001EBD VOL: 0
;PCODE: $00001EBE VOL: 0
;PCODE: $00001EBF VOL: 0
;PCODE: $00001EC0 VOL: 0
;PCODE: $00001EC1 VOL: 0
;PCODE: $00001EC2 VOL: 0
;PCODE: $00001EC3 VOL: 0
;PCODE: $00001EC4 VOL: 0
;PCODE: $00001EC5 VOL: 0
;PCODE: $00001EC6 VOL: 0
;
;	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;PCODE: $00001EC7 VOL: 0
;PCODE: $00001EC8 VOL: 0
;PCODE: $00001EC9 VOL: 0
;PCODE: $00001ECA VOL: 0
;PCODE: $00001ECB VOL: 0
;PCODE: $00001ECC VOL: 0
;PCODE: $00001ECD VOL: 0
;PCODE: $00001ECE VOL: 0
;PCODE: $00001ECF VOL: 0
;PCODE: $00001ED0 VOL: 0
;PCODE: $00001ED1 VOL: 0
;PCODE: $00001ED2 VOL: 0
;PCODE: $00001ED3 VOL: 0
;PCODE: $00001ED4 VOL: 0
;	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;PCODE: $00001ED5 VOL: 0
;PCODE: $00001ED6 VOL: 0
;PCODE: $00001ED7 VOL: 0
;PCODE: $00001ED8 VOL: 0
;PCODE: $00001ED9 VOL: 0
;PCODE: $00001EDA VOL: 0
;    //release_spi();
;	LEAVE_FF(fp->fs, FR_OK);
;PCODE: $00001EDB VOL: 0
;PCODE: $00001EDC VOL: 0
;PCODE: $00001EDD VOL: 0
;PCODE: $00001EDE VOL: 0
;}
;PCODE: $00001EDF VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Synchronize the File                                                  */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_sync (
;	FIL* fp		/* Pointer to the file object */
;)
;{
;PCODE: $00001EE0 VOL: 0
;PCODE: $00001EE1 VOL: 0
;	FRESULT res;
;	DWORD tm;
;	BYTE *dir;
;
;
;	res = validate(fp);					/* Check validity of the object */
;PCODE: $00001EE2 VOL: 0
;PCODE: $00001EE3 VOL: 0
;PCODE: $00001EE4 VOL: 0
;	*fp -> Y+8
;	res -> R17
;	tm -> Y+4
;	*dir -> R18,R19
;PCODE: $00001EE5 VOL: 0
;PCODE: $00001EE6 VOL: 0
;PCODE: $00001EE7 VOL: 0
;	if (res == FR_OK) {
;PCODE: $00001EE8 VOL: 0
;PCODE: $00001EE9 VOL: 0
;		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
;PCODE: $00001EEA VOL: 0
;PCODE: $00001EEB VOL: 0
;PCODE: $00001EEC VOL: 0
;PCODE: $00001EED VOL: 0
;			/* Write-back dirty buffer */
;
;#if !_FS_TINY
;			if (fp->flag & FA__DIRTY) {
;				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;					LEAVE_FF(fp->fs, FR_DISK_ERR);
;				fp->flag &= ~FA__DIRTY;
;			}
;#endif
;			res = move_window(fp->fs, fp->dir_sect);
;PCODE: $00001EEE VOL: 0
;PCODE: $00001EEF VOL: 0
;PCODE: $00001EF0 VOL: 0
;PCODE: $00001EF1 VOL: 0
;PCODE: $00001EF2 VOL: 0
;PCODE: $00001EF3 VOL: 0
;PCODE: $00001EF4 VOL: 0
;			if (res == FR_OK) {
;PCODE: $00001EF5 VOL: 0
;PCODE: $00001EF6 VOL: 0
;				dir = fp->dir_ptr;
;PCODE: $00001EF7 VOL: 0
;PCODE: $00001EF8 VOL: 0
;PCODE: $00001EF9 VOL: 0
;				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;PCODE: $00001EFA VOL: 0
;PCODE: $00001EFB VOL: 0
;PCODE: $00001EFC VOL: 0
;PCODE: $00001EFD VOL: 0
;PCODE: $00001EFE VOL: 0
;				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;PCODE: $00001EFF VOL: 0
;PCODE: $00001F00 VOL: 0
;PCODE: $00001F01 VOL: 0
;PCODE: $00001F02 VOL: 0
;PCODE: $00001F03 VOL: 0
;PCODE: $00001F04 VOL: 0
;PCODE: $00001F05 VOL: 0
;PCODE: $00001F06 VOL: 0
;PCODE: $00001F07 VOL: 0
;PCODE: $00001F08 VOL: 0
;PCODE: $00001F09 VOL: 0
;PCODE: $00001F0A VOL: 0
;PCODE: $00001F0B VOL: 0
;PCODE: $00001F0C VOL: 0
;PCODE: $00001F0D VOL: 0
;PCODE: $00001F0E VOL: 0
;PCODE: $00001F0F VOL: 0
;PCODE: $00001F10 VOL: 0
;PCODE: $00001F11 VOL: 0
;PCODE: $00001F12 VOL: 0
;PCODE: $00001F13 VOL: 0
;PCODE: $00001F14 VOL: 0
;				st_clust(dir, fp->sclust);					/* Update start cluster */
;PCODE: $00001F15 VOL: 0
;PCODE: $00001F16 VOL: 0
;PCODE: $00001F17 VOL: 0
;PCODE: $00001F18 VOL: 0
;				tm = get_fattime();							/* Update updated time */
;PCODE: $00001F19 VOL: 0
;PCODE: $00001F1A VOL: 0
;				ST_DWORD(dir+DIR_WrtTime, tm);
;PCODE: $00001F1B VOL: 0
;PCODE: $00001F1C VOL: 0
;PCODE: $00001F1D VOL: 0
;PCODE: $00001F1E VOL: 0
;PCODE: $00001F1F VOL: 0
;PCODE: $00001F20 VOL: 0
;PCODE: $00001F21 VOL: 0
;PCODE: $00001F22 VOL: 0
;PCODE: $00001F23 VOL: 0
;PCODE: $00001F24 VOL: 0
;PCODE: $00001F25 VOL: 0
;PCODE: $00001F26 VOL: 0
;PCODE: $00001F27 VOL: 0
;PCODE: $00001F28 VOL: 0
;PCODE: $00001F29 VOL: 0
;				ST_WORD(dir+DIR_LstAccDate, 0);
;PCODE: $00001F2A VOL: 0
;PCODE: $00001F2B VOL: 0
;PCODE: $00001F2C VOL: 0
;PCODE: $00001F2D VOL: 0
;PCODE: $00001F2E VOL: 0
;PCODE: $00001F2F VOL: 0
;PCODE: $00001F30 VOL: 0
;PCODE: $00001F31 VOL: 0
;				fp->flag &= ~FA__WRITTEN;
;PCODE: $00001F32 VOL: 0
;PCODE: $00001F33 VOL: 0
;PCODE: $00001F34 VOL: 0
;PCODE: $00001F35 VOL: 0
;PCODE: $00001F36 VOL: 0
;				fp->fs->wflag = 1;
;PCODE: $00001F37 VOL: 0
;PCODE: $00001F38 VOL: 0
;PCODE: $00001F39 VOL: 0
;PCODE: $00001F3A VOL: 0
;PCODE: $00001F3B VOL: 0
;				res = sync_fs(fp->fs);
;PCODE: $00001F3C VOL: 0
;PCODE: $00001F3D VOL: 0
;PCODE: $00001F3E VOL: 0
;PCODE: $00001F3F VOL: 0
;PCODE: $00001F40 VOL: 0
;			}
;		}
;PCODE: $00001F41 VOL: 0
;	}
;PCODE: $00001F42 VOL: 0
;
;	LEAVE_FF(fp->fs, res);
;PCODE: $00001F43 VOL: 0
;PCODE: $00001F44 VOL: 0
;PCODE: $00001F45 VOL: 0
;PCODE: $00001F46 VOL: 0
;PCODE: $00001F47 VOL: 0
;}
;PCODE: $00001F48 VOL: 0
;
;#endif /* !_FS_READONLY */
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Close File                                                            */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_close (
;	FIL *fp		/* Pointer to the file object to be closed */
;)
;{
;PCODE: $00001F49 VOL: 0
;PCODE: $00001F4A VOL: 0
;	FRESULT res;
;
;    // init_spi(1);
;#if _FS_READONLY
;	res = validate(fp);
;	{
;#if _FS_REENTRANT
;		FATFS *fs = 0;
;		if (res == FR_OK) fs = fp->fs;	/* Get corresponding file system object */
;#endif
;		if (res == FR_OK) fp->fs = 0;	/* Invalidate file object */
;		LEAVE_FF(fs, res);
;	}
;#else
;	res = f_sync(fp);					/* Flush cached data */
;PCODE: $00001F4B VOL: 0
;PCODE: $00001F4C VOL: 0
;	*fp -> Y+1
;	res -> R17
;PCODE: $00001F4D VOL: 0
;PCODE: $00001F4E VOL: 0
;PCODE: $00001F4F VOL: 0
;   // release_spi();
;#if _FS_LOCK
;	if (res == FR_OK) {					/* Decrement open counter */
;#if _FS_REENTRANT
;		res = validate(fp);
;		if (res == FR_OK) {
;			res = dec_lock(fp->lockid);
;			unlock_fs(fp->fs, FR_OK);
;		}
;#else
;		res = dec_lock(fp->lockid);
;#endif
;	}
;#endif
;   // release_spi();
;	if (res == FR_OK) fp->fs = 0;		/* Invalidate file object */
;PCODE: $00001F50 VOL: 0
;PCODE: $00001F51 VOL: 0
;PCODE: $00001F52 VOL: 0
;PCODE: $00001F53 VOL: 0
;PCODE: $00001F54 VOL: 0
;	return res;
;PCODE: $00001F55 VOL: 0
;PCODE: $00001F56 VOL: 0
;PCODE: $00001F57 VOL: 0
;PCODE: $00001F58 VOL: 0
;PCODE: $00001F59 VOL: 0
;PCODE: $00001F5A VOL: 0
;#endif
;}
;PCODE: $00001F5B VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Change Current Directory or Current Drive, Get Current Directory      */
;/*-----------------------------------------------------------------------*/
;
;#if _FS_RPATH >= 1
;#if _VOLUMES >= 2
;FRESULT f_chdrive (
;	const TCHAR* path		/* Drive number */
;)
;{
;	int vol;
;
;
;	vol = get_ldnumber(&path);
;	if (vol < 0) return FR_INVALID_DRIVE;
;
;	CurrVol = (BYTE)vol;
;
;	return FR_OK;
;}
;#endif
;
;
;FRESULT f_chdir (
;	const TCHAR* path	/* Pointer to the directory path */
;)
;{
;	FRESULT res;
;	DIR dj;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 0);
;	if (res == FR_OK) {
;		INIT_BUF(dj);
;		res = follow_path(&dj, path);		/* Follow the path */
;		FREE_BUF();
;		if (res == FR_OK) {					/* Follow completed */
;			if (!dj.dir) {
;				dj.fs->cdir = dj.sclust;	/* Start directory itself */
;			} else {
;				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
;					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
;				else
;					res = FR_NO_PATH;		/* Reached but a file */
;			}
;		}
;		if (res == FR_NO_FILE) res = FR_NO_PATH;
;	}
;
;	LEAVE_FF(dj.fs, res);
;}
;
;
;#if _FS_RPATH >= 2
;FRESULT f_getcwd (
;	TCHAR* buff,	/* Pointer to the directory path */
;	UINT len		/* Size of path */
;)
;{
;	FRESULT res;
;	DIR dj;
;	UINT i, n;
;	DWORD ccl;
;	TCHAR *tp;
;	FILINFO fno;
;	DEF_NAMEBUF;
;
;
;	*buff = 0;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);	/* Get current volume */
;	if (res == FR_OK) {
;		INIT_BUF(dj);
;		i = len;			/* Bottom of buffer (directory stack base) */
;		dj.sclust = dj.fs->cdir;			/* Start to follow upper directory from current directory */
;		while ((ccl = dj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
;			res = dir_sdi(&dj, 1);			/* Get parent directory */
;			if (res != FR_OK) break;
;			res = dir_read(&dj, 0);
;			if (res != FR_OK) break;
;			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent directory */
;			res = dir_sdi(&dj, 0);
;			if (res != FR_OK) break;
;			do {							/* Find the entry links to the child directory */
;				res = dir_read(&dj, 0);
;				if (res != FR_OK) break;
;				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
;				res = dir_next(&dj, 0);
;			} while (res == FR_OK);
;			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
;			if (res != FR_OK) break;
;#if _USE_LFN
;			fno.lfname = buff;
;			fno.lfsize = i;
;#endif
;			get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
;			tp = fno.fname;
;#if _USE_LFN
;			if (*buff) tp = buff;
;#endif
;			for (n = 0; tp[n]; n++) ;
;			if (i < n + 3) {
;				res = FR_NOT_ENOUGH_CORE; break;
;			}
;			while (n) buff[--i] = tp[--n];
;			buff[--i] = '/';
;		}
;		tp = buff;
;		if (res == FR_OK) {
;#if _VOLUMES >= 2
;			*tp++ = '0' + CurrVol;			/* Put drive number */
;			*tp++ = ':';
;#endif
;			if (i == len) {					/* Root-directory */
;				*tp++ = '/';
;			} else {						/* Sub-directroy */
;				do		/* Add stacked path str */
;					*tp++ = buff[i++];
;				while (i < len);
;			}
;		}
;		*tp = 0;
;		FREE_BUF();
;	}
;
;	LEAVE_FF(dj.fs, res);
;}
;#endif /* _FS_RPATH >= 2 */
;#endif /* _FS_RPATH >= 1 */
;
;
;
;#if _FS_MINIMIZE <= 2
;/*-----------------------------------------------------------------------*/
;/* Seek File R/W Pointer                                                 */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_lseek (
;	FIL* fp,		/* Pointer to the file object */
;	DWORD ofs		/* File pointer from top of file */
;)
;{
;PCODE: $00001F5C VOL: 0
;PCODE: $00001F5D VOL: 0
;	FRESULT res;
;    //init_spi(1);
;
;	res = validate(fp);					/* Check validity of the object */
;PCODE: $00001F5E VOL: 0
;PCODE: $00001F5F VOL: 0
;	*fp -> Y+5
;	ofs -> Y+1
;	res -> R17
;PCODE: $00001F60 VOL: 0
;PCODE: $00001F61 VOL: 0
;PCODE: $00001F62 VOL: 0
;	if (res != FR_OK) LEAVE_FF(fp->fs, res);
;PCODE: $00001F63 VOL: 0
;PCODE: $00001F64 VOL: 0
;PCODE: $00001F65 VOL: 0
;PCODE: $00001F66 VOL: 0
;PCODE: $00001F67 VOL: 0
;PCODE: $00001F68 VOL: 0
;PCODE: $00001F69 VOL: 0
;	if (fp->err)						/* Check error */
;PCODE: $00001F6A VOL: 0
;PCODE: $00001F6B VOL: 0
;PCODE: $00001F6C VOL: 0
;PCODE: $00001F6D VOL: 0
;PCODE: $00001F6E VOL: 0
;		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;PCODE: $00001F6F VOL: 0
;PCODE: $00001F70 VOL: 0
;PCODE: $00001F71 VOL: 0
;PCODE: $00001F72 VOL: 0
;PCODE: $00001F73 VOL: 0
;PCODE: $00001F74 VOL: 0
;
;#if _USE_FASTSEEK
;	if (fp->cltbl) {	/* Fast seek */
;		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;
;		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;			tbl = fp->cltbl;
;			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;			cl = fp->sclust;			/* Top of the chain */
;			if (cl) {
;				do {
;					/* Get a fragment */
;					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;					do {
;						pcl = cl; ncl++;
;						cl = get_fat(fp->fs, cl);
;						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;					} while (cl == pcl + 1);
;					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;						*tbl++ = ncl; *tbl++ = tcl;
;					}
;				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;			}
;			*fp->cltbl = ulen;	/* Number of items used */
;			if (ulen <= tlen)
;				*tbl = 0;		/* Terminate table */
;			else
;				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;
;		} else {						/* Fast seek */
;			if (ofs > fp->fsize)		/* Clip offset at the file size */
;				ofs = fp->fsize;
;			fp->fptr = ofs;				/* Set file pointer */
;			if (ofs) {
;				fp->clust = clmt_clust(fp, ofs - 1);
;				dsc = clust2sect(fp->fs, fp->clust);
;				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;#if !_FS_TINY
;#if !_FS_READONLY
;					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;							ABORT(fp->fs, FR_DISK_ERR);
;						fp->flag &= ~FA__DIRTY;
;					}
;#endif
;					if (disk_read(fp->fs->drv, fp->buf, dsc, 1))	/* Load current sector */
;						ABORT(fp->fs, FR_DISK_ERR);
;#endif
;					fp->dsect = dsc;
;				}
;			}
;		}
;	} else
;#endif
;
;	/* Normal Seek */
;	{
;PCODE: $00001F75 VOL: 0
;		DWORD clst, bcs, nsect, ifptr;
;
;		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;PCODE: $00001F76 VOL: 0
;	*fp -> Y+21
;	ofs -> Y+17
;	clst -> Y+12
;	bcs -> Y+8
;	nsect -> Y+4
;	ifptr -> Y+0
;#if !_FS_READONLY
;			 && !(fp->flag & FA_WRITE)
;#endif
;			) ofs = fp->fsize;
;PCODE: $00001F77 VOL: 0
;PCODE: $00001F78 VOL: 0
;PCODE: $00001F79 VOL: 0
;PCODE: $00001F7A VOL: 0
;PCODE: $00001F7B VOL: 0
;PCODE: $00001F7C VOL: 0
;PCODE: $00001F7D VOL: 0
;PCODE: $00001F7E VOL: 0
;PCODE: $00001F7F VOL: 0
;PCODE: $00001F80 VOL: 0
;PCODE: $00001F81 VOL: 0
;PCODE: $00001F82 VOL: 0
;PCODE: $00001F83 VOL: 0
;PCODE: $00001F84 VOL: 0
;PCODE: $00001F85 VOL: 0
;PCODE: $00001F86 VOL: 0
;PCODE: $00001F87 VOL: 0
;PCODE: $00001F88 VOL: 0
;
;		ifptr = fp->fptr;
;PCODE: $00001F89 VOL: 0
;PCODE: $00001F8A VOL: 0
;PCODE: $00001F8B VOL: 0
;PCODE: $00001F8C VOL: 0
;PCODE: $00001F8D VOL: 0
;		fp->fptr = nsect = 0;
;PCODE: $00001F8E VOL: 0
;PCODE: $00001F8F VOL: 0
;PCODE: $00001F90 VOL: 0
;PCODE: $00001F91 VOL: 0
;		if (ofs) {
;PCODE: $00001F92 VOL: 0
;PCODE: $00001F93 VOL: 0
;PCODE: $00001F94 VOL: 0
;			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;PCODE: $00001F95 VOL: 0
;PCODE: $00001F96 VOL: 0
;PCODE: $00001F97 VOL: 0
;PCODE: $00001F98 VOL: 0
;PCODE: $00001F99 VOL: 0
;PCODE: $00001F9A VOL: 0
;PCODE: $00001F9B VOL: 0
;PCODE: $00001F9C VOL: 0
;			if (ifptr > 0 &&
;				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;PCODE: $00001F9D VOL: 0
;PCODE: $00001F9E VOL: 0
;PCODE: $00001F9F VOL: 0
;PCODE: $00001FA0 VOL: 0
;PCODE: $00001FA1 VOL: 0
;PCODE: $00001FA2 VOL: 0
;PCODE: $00001FA3 VOL: 0
;PCODE: $00001FA4 VOL: 0
;PCODE: $00001FA5 VOL: 0
;PCODE: $00001FA6 VOL: 0
;PCODE: $00001FA7 VOL: 0
;PCODE: $00001FA8 VOL: 0
;PCODE: $00001FA9 VOL: 0
;PCODE: $00001FAA VOL: 0
;PCODE: $00001FAB VOL: 0
;PCODE: $00001FAC VOL: 0
;PCODE: $00001FAD VOL: 0
;PCODE: $00001FAE VOL: 0
;PCODE: $00001FAF VOL: 0
;PCODE: $00001FB0 VOL: 0
;PCODE: $00001FB1 VOL: 0
;				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;PCODE: $00001FB2 VOL: 0
;PCODE: $00001FB3 VOL: 0
;PCODE: $00001FB4 VOL: 0
;PCODE: $00001FB5 VOL: 0
;PCODE: $00001FB6 VOL: 0
;PCODE: $00001FB7 VOL: 0
;PCODE: $00001FB8 VOL: 0
;PCODE: $00001FB9 VOL: 0
;PCODE: $00001FBA VOL: 0
;				ofs -= fp->fptr;
;PCODE: $00001FBB VOL: 0
;PCODE: $00001FBC VOL: 0
;PCODE: $00001FBD VOL: 0
;PCODE: $00001FBE VOL: 0
;PCODE: $00001FBF VOL: 0
;PCODE: $00001FC0 VOL: 0
;				clst = fp->clust;
;PCODE: $00001FC1 VOL: 0
;PCODE: $00001FC2 VOL: 0
;PCODE: $00001FC3 VOL: 0
;PCODE: $00001FC4 VOL: 0
;			} else {									/* When seek to back cluster, */
;PCODE: $00001FC5 VOL: 0
;PCODE: $00001FC6 VOL: 0
;				clst = fp->sclust;						/* start from the first cluster */
;PCODE: $00001FC7 VOL: 0
;PCODE: $00001FC8 VOL: 0
;PCODE: $00001FC9 VOL: 0
;PCODE: $00001FCA VOL: 0
;#if !_FS_READONLY
;				if (clst == 0) {						/* If no cluster chain, create a new chain */
;PCODE: $00001FCB VOL: 0
;PCODE: $00001FCC VOL: 0
;PCODE: $00001FCD VOL: 0
;					clst = create_chain(fp->fs, 0);
;PCODE: $00001FCE VOL: 0
;PCODE: $00001FCF VOL: 0
;PCODE: $00001FD0 VOL: 0
;PCODE: $00001FD1 VOL: 0
;PCODE: $00001FD2 VOL: 0
;PCODE: $00001FD3 VOL: 0
;					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00001FD4 VOL: 0
;PCODE: $00001FD5 VOL: 0
;PCODE: $00001FD6 VOL: 0
;PCODE: $00001FD7 VOL: 0
;PCODE: $00001FD8 VOL: 0
;PCODE: $00001FD9 VOL: 0
;PCODE: $00001FDA VOL: 0
;PCODE: $00001FDB VOL: 0
;PCODE: $00001FDC VOL: 0
;PCODE: $00001FDD VOL: 0
;PCODE: $00001FDE VOL: 0
;PCODE: $00001FDF VOL: 0
;PCODE: $00001FE0 VOL: 0
;PCODE: $00001FE1 VOL: 0
;					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00001FE2 VOL: 0
;PCODE: $00001FE3 VOL: 0
;PCODE: $00001FE4 VOL: 0
;PCODE: $00001FE5 VOL: 0
;PCODE: $00001FE6 VOL: 0
;PCODE: $00001FE7 VOL: 0
;PCODE: $00001FE8 VOL: 0
;PCODE: $00001FE9 VOL: 0
;PCODE: $00001FEA VOL: 0
;PCODE: $00001FEB VOL: 0
;PCODE: $00001FEC VOL: 0
;PCODE: $00001FED VOL: 0
;PCODE: $00001FEE VOL: 0
;PCODE: $00001FEF VOL: 0
;					fp->sclust = clst;
;PCODE: $00001FF0 VOL: 0
;PCODE: $00001FF1 VOL: 0
;PCODE: $00001FF2 VOL: 0
;				}
;#endif
;				fp->clust = clst;
;PCODE: $00001FF3 VOL: 0
;PCODE: $00001FF4 VOL: 0
;PCODE: $00001FF5 VOL: 0
;PCODE: $00001FF6 VOL: 0
;			}
;PCODE: $00001FF7 VOL: 0
;			if (clst != 0) {
;PCODE: $00001FF8 VOL: 0
;PCODE: $00001FF9 VOL: 0
;PCODE: $00001FFA VOL: 0
;				while (ofs > bcs) {						/* Cluster following loop */
;PCODE: $00001FFB VOL: 0
;PCODE: $00001FFC VOL: 0
;PCODE: $00001FFD VOL: 0
;PCODE: $00001FFE VOL: 0
;PCODE: $00001FFF VOL: 0
;#if !_FS_READONLY
;					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;PCODE: $00002000 VOL: 0
;PCODE: $00002001 VOL: 0
;PCODE: $00002002 VOL: 0
;PCODE: $00002003 VOL: 0
;						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;PCODE: $00002004 VOL: 0
;PCODE: $00002005 VOL: 0
;PCODE: $00002006 VOL: 0
;PCODE: $00002007 VOL: 0
;PCODE: $00002008 VOL: 0
;PCODE: $00002009 VOL: 0
;						if (clst == 0) {				/* When disk gets full, clip file size */
;PCODE: $0000200A VOL: 0
;PCODE: $0000200B VOL: 0
;PCODE: $0000200C VOL: 0
;							ofs = bcs; break;
;PCODE: $0000200D VOL: 0
;PCODE: $0000200E VOL: 0
;PCODE: $0000200F VOL: 0
;						}
;					} else
;PCODE: $00002010 VOL: 0
;PCODE: $00002011 VOL: 0
;PCODE: $00002012 VOL: 0
;#endif
;						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;PCODE: $00002013 VOL: 0
;PCODE: $00002014 VOL: 0
;PCODE: $00002015 VOL: 0
;PCODE: $00002016 VOL: 0
;PCODE: $00002017 VOL: 0
;PCODE: $00002018 VOL: 0
;					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;PCODE: $00002019 VOL: 0
;PCODE: $0000201A VOL: 0
;PCODE: $0000201B VOL: 0
;PCODE: $0000201C VOL: 0
;PCODE: $0000201D VOL: 0
;PCODE: $0000201E VOL: 0
;PCODE: $0000201F VOL: 0
;PCODE: $00002020 VOL: 0
;PCODE: $00002021 VOL: 0
;PCODE: $00002022 VOL: 0
;PCODE: $00002023 VOL: 0
;PCODE: $00002024 VOL: 0
;PCODE: $00002025 VOL: 0
;PCODE: $00002026 VOL: 0
;PCODE: $00002027 VOL: 0
;					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00002028 VOL: 0
;PCODE: $00002029 VOL: 0
;PCODE: $0000202A VOL: 0
;PCODE: $0000202B VOL: 0
;PCODE: $0000202C VOL: 0
;PCODE: $0000202D VOL: 0
;PCODE: $0000202E VOL: 0
;PCODE: $0000202F VOL: 0
;PCODE: $00002030 VOL: 0
;PCODE: $00002031 VOL: 0
;PCODE: $00002032 VOL: 0
;PCODE: $00002033 VOL: 0
;PCODE: $00002034 VOL: 0
;PCODE: $00002035 VOL: 0
;PCODE: $00002036 VOL: 0
;PCODE: $00002037 VOL: 0
;PCODE: $00002038 VOL: 0
;PCODE: $00002039 VOL: 0
;PCODE: $0000203A VOL: 0
;PCODE: $0000203B VOL: 0
;PCODE: $0000203C VOL: 0
;PCODE: $0000203D VOL: 0
;PCODE: $0000203E VOL: 0
;PCODE: $0000203F VOL: 0
;					fp->clust = clst;
;PCODE: $00002040 VOL: 0
;PCODE: $00002041 VOL: 0
;PCODE: $00002042 VOL: 0
;					fp->fptr += bcs;
;PCODE: $00002043 VOL: 0
;PCODE: $00002044 VOL: 0
;PCODE: $00002045 VOL: 0
;PCODE: $00002046 VOL: 0
;PCODE: $00002047 VOL: 0
;PCODE: $00002048 VOL: 0
;PCODE: $00002049 VOL: 0
;PCODE: $0000204A VOL: 0
;PCODE: $0000204B VOL: 0
;					ofs -= bcs;
;PCODE: $0000204C VOL: 0
;PCODE: $0000204D VOL: 0
;PCODE: $0000204E VOL: 0
;PCODE: $0000204F VOL: 0
;				}
;PCODE: $00002050 VOL: 0
;PCODE: $00002051 VOL: 0
;				fp->fptr += ofs;
;PCODE: $00002052 VOL: 0
;PCODE: $00002053 VOL: 0
;PCODE: $00002054 VOL: 0
;PCODE: $00002055 VOL: 0
;PCODE: $00002056 VOL: 0
;PCODE: $00002057 VOL: 0
;PCODE: $00002058 VOL: 0
;PCODE: $00002059 VOL: 0
;PCODE: $0000205A VOL: 0
;				if (ofs % SS(fp->fs)) {
;PCODE: $0000205B VOL: 0
;PCODE: $0000205C VOL: 0
;PCODE: $0000205D VOL: 0
;PCODE: $0000205E VOL: 0
;					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;PCODE: $0000205F VOL: 0
;PCODE: $00002060 VOL: 0
;PCODE: $00002061 VOL: 0
;PCODE: $00002062 VOL: 0
;PCODE: $00002063 VOL: 0
;PCODE: $00002064 VOL: 0
;					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;PCODE: $00002065 VOL: 0
;PCODE: $00002066 VOL: 0
;PCODE: $00002067 VOL: 0
;PCODE: $00002068 VOL: 0
;PCODE: $00002069 VOL: 0
;PCODE: $0000206A VOL: 0
;PCODE: $0000206B VOL: 0
;PCODE: $0000206C VOL: 0
;PCODE: $0000206D VOL: 0
;PCODE: $0000206E VOL: 0
;PCODE: $0000206F VOL: 0
;PCODE: $00002070 VOL: 0
;PCODE: $00002071 VOL: 0
;PCODE: $00002072 VOL: 0
;					nsect += ofs / SS(fp->fs);
;PCODE: $00002073 VOL: 0
;PCODE: $00002074 VOL: 0
;PCODE: $00002075 VOL: 0
;PCODE: $00002076 VOL: 0
;PCODE: $00002077 VOL: 0
;PCODE: $00002078 VOL: 0
;				}
;			}
;PCODE: $00002079 VOL: 0
;		}
;PCODE: $0000207A VOL: 0
;		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;PCODE: $0000207B VOL: 0
;PCODE: $0000207C VOL: 0
;PCODE: $0000207D VOL: 0
;PCODE: $0000207E VOL: 0
;PCODE: $0000207F VOL: 0
;PCODE: $00002080 VOL: 0
;PCODE: $00002081 VOL: 0
;PCODE: $00002082 VOL: 0
;PCODE: $00002083 VOL: 0
;PCODE: $00002084 VOL: 0
;PCODE: $00002085 VOL: 0
;PCODE: $00002086 VOL: 0
;PCODE: $00002087 VOL: 0
;PCODE: $00002088 VOL: 0
;PCODE: $00002089 VOL: 0
;PCODE: $0000208A VOL: 0
;PCODE: $0000208B VOL: 0
;#if !_FS_TINY
;#if !_FS_READONLY
;			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;					ABORT(fp->fs, FR_DISK_ERR);
;				fp->flag &= ~FA__DIRTY;
;			}
;#endif
;			if (disk_read(fp->fs->drv, fp->buf, nsect, 1))	/* Fill sector cache */
;				ABORT(fp->fs, FR_DISK_ERR);
;#endif
;			fp->dsect = nsect;
;PCODE: $0000208C VOL: 0
;PCODE: $0000208D VOL: 0
;PCODE: $0000208E VOL: 0
;		}
;#if !_FS_READONLY
;		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;PCODE: $0000208F VOL: 0
;PCODE: $00002090 VOL: 0
;PCODE: $00002091 VOL: 0
;PCODE: $00002092 VOL: 0
;PCODE: $00002093 VOL: 0
;PCODE: $00002094 VOL: 0
;PCODE: $00002095 VOL: 0
;PCODE: $00002096 VOL: 0
;PCODE: $00002097 VOL: 0
;PCODE: $00002098 VOL: 0
;			fp->fsize = fp->fptr;
;PCODE: $00002099 VOL: 0
;PCODE: $0000209A VOL: 0
;PCODE: $0000209B VOL: 0
;PCODE: $0000209C VOL: 0
;PCODE: $0000209D VOL: 0
;			fp->flag |= FA__WRITTEN;
;PCODE: $0000209E VOL: 0
;PCODE: $0000209F VOL: 0
;PCODE: $000020A0 VOL: 0
;PCODE: $000020A1 VOL: 0
;PCODE: $000020A2 VOL: 0
;		}
;#endif
;	}
;PCODE: $000020A3 VOL: 0
;PCODE: $000020A4 VOL: 0
;   // release_spi();
;	LEAVE_FF(fp->fs, res);
;PCODE: $000020A5 VOL: 0
;PCODE: $000020A6 VOL: 0
;PCODE: $000020A7 VOL: 0
;PCODE: $000020A8 VOL: 0
;PCODE: $000020A9 VOL: 0
;}
;PCODE: $000020AA VOL: 0
;
;
;
;#if _FS_MINIMIZE <= 1
;/*-----------------------------------------------------------------------*/
;/* Create a Directory Object                                             */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_opendir (
;	DIR* dp,			/* Pointer to directory object to create */
;	const TCHAR* path	/* Pointer to the directory path */
;)
;{
;PCODE: $000020AB VOL: 0
;PCODE: $000020AC VOL: 0
;	FRESULT res;
;	FATFS* fs;
;	DEF_NAMEBUF;
;
;
;	if (!dp) return FR_INVALID_OBJECT;
;PCODE: $000020AD VOL: 0
;PCODE: $000020AE VOL: 0
;PCODE: $000020AF VOL: 0
;	*dp -> Y+18
;	*path -> Y+16
;	res -> R17
;	*fs -> R18,R19
;	sfn -> Y+4
;PCODE: $000020B0 VOL: 0
;PCODE: $000020B1 VOL: 0
;PCODE: $000020B2 VOL: 0
;PCODE: $000020B3 VOL: 0
;PCODE: $000020B4 VOL: 0
;PCODE: $000020B5 VOL: 0
;PCODE: $000020B6 VOL: 0
;
;	/* Get logical drive number */
;	res = find_volume(&fs, &path, 0);
;PCODE: $000020B7 VOL: 0
;PCODE: $000020B8 VOL: 0
;PCODE: $000020B9 VOL: 0
;PCODE: $000020BA VOL: 0
;PCODE: $000020BB VOL: 0
;PCODE: $000020BC VOL: 0
;PCODE: $000020BD VOL: 0
;PCODE: $000020BE VOL: 0
;PCODE: $000020BF VOL: 0
;PCODE: $000020C0 VOL: 0
;PCODE: $000020C1 VOL: 0
;PCODE: $000020C2 VOL: 0
;PCODE: $000020C3 VOL: 0
;	if (res == FR_OK) {
;PCODE: $000020C4 VOL: 0
;PCODE: $000020C5 VOL: 0
;		dp->fs = fs;
;PCODE: $000020C6 VOL: 0
;PCODE: $000020C7 VOL: 0
;		INIT_BUF(*dp);
;PCODE: $000020C8 VOL: 0
;PCODE: $000020C9 VOL: 0
;PCODE: $000020CA VOL: 0
;		res = follow_path(dp, path);			/* Follow the path to the directory */
;PCODE: $000020CB VOL: 0
;PCODE: $000020CC VOL: 0
;PCODE: $000020CD VOL: 0
;PCODE: $000020CE VOL: 0
;PCODE: $000020CF VOL: 0
;		FREE_BUF();
;		if (res == FR_OK) {						/* Follow completed */
;PCODE: $000020D0 VOL: 0
;PCODE: $000020D1 VOL: 0
;			if (dp->dir) {						/* It is not the origin directory itself */
;PCODE: $000020D2 VOL: 0
;PCODE: $000020D3 VOL: 0
;PCODE: $000020D4 VOL: 0
;PCODE: $000020D5 VOL: 0
;PCODE: $000020D6 VOL: 0
;				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;PCODE: $000020D7 VOL: 0
;PCODE: $000020D8 VOL: 0
;PCODE: $000020D9 VOL: 0
;PCODE: $000020DA VOL: 0
;PCODE: $000020DB VOL: 0
;PCODE: $000020DC VOL: 0
;					dp->sclust = ld_clust(fs, dp->dir);
;PCODE: $000020DD VOL: 0
;PCODE: $000020DE VOL: 0
;PCODE: $000020DF VOL: 0
;PCODE: $000020E0 VOL: 0
;PCODE: $000020E1 VOL: 0
;PCODE: $000020E2 VOL: 0
;				else							/* The object is a file */
;PCODE: $000020E3 VOL: 0
;PCODE: $000020E4 VOL: 0
;					res = FR_NO_PATH;
;PCODE: $000020E5 VOL: 0
;PCODE: $000020E6 VOL: 0
;			}
;PCODE: $000020E7 VOL: 0
;			if (res == FR_OK) {
;PCODE: $000020E8 VOL: 0
;PCODE: $000020E9 VOL: 0
;PCODE: $000020EA VOL: 0
;				dp->id = fs->id;
;PCODE: $000020EB VOL: 0
;PCODE: $000020EC VOL: 0
;PCODE: $000020ED VOL: 0
;PCODE: $000020EE VOL: 0
;PCODE: $000020EF VOL: 0
;				res = dir_sdi(dp, 0);			/* Rewind directory */
;PCODE: $000020F0 VOL: 0
;PCODE: $000020F1 VOL: 0
;PCODE: $000020F2 VOL: 0
;PCODE: $000020F3 VOL: 0
;PCODE: $000020F4 VOL: 0
;PCODE: $000020F5 VOL: 0
;#if _FS_LOCK
;				if (res == FR_OK) {
;					if (dp->sclust) {
;						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;						if (!dp->lockid)
;							res = FR_TOO_MANY_OPEN_FILES;
;					} else {
;						dp->lockid = 0;	/* Root directory need not to be locked */
;					}
;				}
;#endif
;			}
;		}
;PCODE: $000020F6 VOL: 0
;		if (res == FR_NO_FILE) res = FR_NO_PATH;
;PCODE: $000020F7 VOL: 0
;PCODE: $000020F8 VOL: 0
;PCODE: $000020F9 VOL: 0
;PCODE: $000020FA VOL: 0
;PCODE: $000020FB VOL: 0
;PCODE: $000020FC VOL: 0
;	}
;PCODE: $000020FD VOL: 0
;	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;PCODE: $000020FE VOL: 0
;PCODE: $000020FF VOL: 0
;PCODE: $00002100 VOL: 0
;PCODE: $00002101 VOL: 0
;PCODE: $00002102 VOL: 0
;PCODE: $00002103 VOL: 0
;
;	LEAVE_FF(fs, res);
;PCODE: $00002104 VOL: 0
;PCODE: $00002105 VOL: 0
;PCODE: $00002106 VOL: 0
;PCODE: $00002107 VOL: 0
;PCODE: $00002108 VOL: 0
;}
;PCODE: $00002109 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Close Directory                                                       */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_closedir (
;	DIR *dp		/* Pointer to the directory object to be closed */
;)
;{
;PCODE: $0000210A VOL: 0
;PCODE: $0000210B VOL: 0
;	FRESULT res;
;
;
;	res = validate(dp);
;PCODE: $0000210C VOL: 0
;PCODE: $0000210D VOL: 0
;	*dp -> Y+1
;	res -> R17
;PCODE: $0000210E VOL: 0
;PCODE: $0000210F VOL: 0
;PCODE: $00002110 VOL: 0
;#if _FS_LOCK
;	if (res == FR_OK) {				/* Decrement open counter */
;		if (dp->lockid)
;			res = dec_lock(dp->lockid);
;#if _FS_REENTRANT
;		unlock_fs(dp->fs, FR_OK);
;#endif
;	}
;#endif
;	if (res == FR_OK) dp->fs = 0;	/* Invalidate directory object */
;PCODE: $00002111 VOL: 0
;PCODE: $00002112 VOL: 0
;PCODE: $00002113 VOL: 0
;PCODE: $00002114 VOL: 0
;PCODE: $00002115 VOL: 0
;	return res;
;PCODE: $00002116 VOL: 0
;PCODE: $00002117 VOL: 0
;PCODE: $00002118 VOL: 0
;PCODE: $00002119 VOL: 0
;PCODE: $0000211A VOL: 0
;PCODE: $0000211B VOL: 0
;}
;PCODE: $0000211C VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Read Directory Entries in Sequence                                    */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_readdir (
;	DIR* dp,			/* Pointer to the open directory object */
;	FILINFO* fno		/* Pointer to file information to return */
;)
;{
;PCODE: $0000211D VOL: 0
;PCODE: $0000211E VOL: 0
;	FRESULT res;
;	DEF_NAMEBUF;
;
;
;	res = validate(dp);						/* Check validity of the object */
;PCODE: $0000211F VOL: 0
;PCODE: $00002120 VOL: 0
;PCODE: $00002121 VOL: 0
;	*dp -> Y+15
;	*fno -> Y+13
;	res -> R17
;	sfn -> Y+1
;PCODE: $00002122 VOL: 0
;PCODE: $00002123 VOL: 0
;PCODE: $00002124 VOL: 0
;	if (res == FR_OK) {
;PCODE: $00002125 VOL: 0
;PCODE: $00002126 VOL: 0
;		if (!fno) {
;PCODE: $00002127 VOL: 0
;PCODE: $00002128 VOL: 0
;PCODE: $00002129 VOL: 0
;			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;PCODE: $0000212A VOL: 0
;PCODE: $0000212B VOL: 0
;PCODE: $0000212C VOL: 0
;PCODE: $0000212D VOL: 0
;PCODE: $0000212E VOL: 0
;PCODE: $0000212F VOL: 0
;		} else {
;PCODE: $00002130 VOL: 0
;PCODE: $00002131 VOL: 0
;			INIT_BUF(*dp);
;PCODE: $00002132 VOL: 0
;PCODE: $00002133 VOL: 0
;PCODE: $00002134 VOL: 0
;			res = dir_read(dp, 0);			/* Read an item */
;PCODE: $00002135 VOL: 0
;PCODE: $00002136 VOL: 0
;PCODE: $00002137 VOL: 0
;PCODE: $00002138 VOL: 0
;PCODE: $00002139 VOL: 0
;PCODE: $0000213A VOL: 0
;			if (res == FR_NO_FILE) {		/* Reached end of directory */
;PCODE: $0000213B VOL: 0
;PCODE: $0000213C VOL: 0
;PCODE: $0000213D VOL: 0
;				dp->sect = 0;
;PCODE: $0000213E VOL: 0
;PCODE: $0000213F VOL: 0
;PCODE: $00002140 VOL: 0
;PCODE: $00002141 VOL: 0
;				res = FR_OK;
;PCODE: $00002142 VOL: 0
;PCODE: $00002143 VOL: 0
;			}
;			if (res == FR_OK) {				/* A valid entry is found */
;PCODE: $00002144 VOL: 0
;PCODE: $00002145 VOL: 0
;PCODE: $00002146 VOL: 0
;				get_fileinfo(dp, fno);		/* Get the object information */
;PCODE: $00002147 VOL: 0
;PCODE: $00002148 VOL: 0
;PCODE: $00002149 VOL: 0
;PCODE: $0000214A VOL: 0
;				res = dir_next(dp, 0);		/* Increment index for next */
;PCODE: $0000214B VOL: 0
;PCODE: $0000214C VOL: 0
;PCODE: $0000214D VOL: 0
;PCODE: $0000214E VOL: 0
;PCODE: $0000214F VOL: 0
;PCODE: $00002150 VOL: 0
;				if (res == FR_NO_FILE) {
;PCODE: $00002151 VOL: 0
;PCODE: $00002152 VOL: 0
;PCODE: $00002153 VOL: 0
;					dp->sect = 0;
;PCODE: $00002154 VOL: 0
;PCODE: $00002155 VOL: 0
;PCODE: $00002156 VOL: 0
;PCODE: $00002157 VOL: 0
;					res = FR_OK;
;PCODE: $00002158 VOL: 0
;PCODE: $00002159 VOL: 0
;				}
;			}
;PCODE: $0000215A VOL: 0
;			FREE_BUF();
;PCODE: $0000215B VOL: 0
;		}
;PCODE: $0000215C VOL: 0
;	}
;
;	LEAVE_FF(dp->fs, res);
;PCODE: $0000215D VOL: 0
;PCODE: $0000215E VOL: 0
;PCODE: $0000215F VOL: 0
;PCODE: $00002160 VOL: 0
;PCODE: $00002161 VOL: 0
;PCODE: $00002162 VOL: 0
;}
;PCODE: $00002163 VOL: 0
;
;
;
;#if _FS_MINIMIZE == 0
;/*-----------------------------------------------------------------------*/
;/* Get File Status                                                       */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_stat (
;	const TCHAR* path,	/* Pointer to the file path */
;	FILINFO* fno		/* Pointer to file information to return */
;)
;{
;PCODE: $00002164 VOL: 0
;PCODE: $00002165 VOL: 0
;	FRESULT res;
;	DIR dj;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 0);
;PCODE: $00002166 VOL: 0
;PCODE: $00002167 VOL: 0
;PCODE: $00002168 VOL: 0
;	*path -> Y+37
;	*fno -> Y+35
;	res -> R17
;	dj -> Y+13
;	sfn -> Y+1
;PCODE: $00002169 VOL: 0
;PCODE: $0000216A VOL: 0
;PCODE: $0000216B VOL: 0
;PCODE: $0000216C VOL: 0
;PCODE: $0000216D VOL: 0
;PCODE: $0000216E VOL: 0
;PCODE: $0000216F VOL: 0
;	if (res == FR_OK) {
;PCODE: $00002170 VOL: 0
;PCODE: $00002171 VOL: 0
;		INIT_BUF(dj);
;PCODE: $00002172 VOL: 0
;PCODE: $00002173 VOL: 0
;		res = follow_path(&dj, path);	/* Follow the file path */
;PCODE: $00002174 VOL: 0
;PCODE: $00002175 VOL: 0
;PCODE: $00002176 VOL: 0
;PCODE: $00002177 VOL: 0
;PCODE: $00002178 VOL: 0
;		if (res == FR_OK) {				/* Follow completed */
;PCODE: $00002179 VOL: 0
;PCODE: $0000217A VOL: 0
;			if (dj.dir) {		/* Found an object */
;PCODE: $0000217B VOL: 0
;PCODE: $0000217C VOL: 0
;PCODE: $0000217D VOL: 0
;				if (fno) get_fileinfo(&dj, fno);
;PCODE: $0000217E VOL: 0
;PCODE: $0000217F VOL: 0
;PCODE: $00002180 VOL: 0
;PCODE: $00002181 VOL: 0
;PCODE: $00002182 VOL: 0
;PCODE: $00002183 VOL: 0
;PCODE: $00002184 VOL: 0
;			} else {			/* It is root directory */
;PCODE: $00002185 VOL: 0
;PCODE: $00002186 VOL: 0
;PCODE: $00002187 VOL: 0
;				res = FR_INVALID_NAME;
;PCODE: $00002188 VOL: 0
;PCODE: $00002189 VOL: 0
;			}
;PCODE: $0000218A VOL: 0
;		}
;		FREE_BUF();
;PCODE: $0000218B VOL: 0
;	}
;
;	LEAVE_FF(dj.fs, res);
;PCODE: $0000218C VOL: 0
;PCODE: $0000218D VOL: 0
;PCODE: $0000218E VOL: 0
;PCODE: $0000218F VOL: 0
;PCODE: $00002190 VOL: 0
;PCODE: $00002191 VOL: 0
;}
;PCODE: $00002192 VOL: 0
;
;
;
;#if !_FS_READONLY
;/*-----------------------------------------------------------------------*/
;/* Get Number of Free Clusters                                           */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_getfree (
;	const TCHAR* path,	/* Path name of the logical drive number */
;	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;)
;{
;PCODE: $00002193 VOL: 0
;PCODE: $00002194 VOL: 0
;	FRESULT res;
;	FATFS *fs;
;	DWORD n, clst, sect, stat;
;	UINT i;
;	BYTE fat, *p;
;
;
;	/* Get logical drive number */
;	res = find_volume(fatfs, &path, 0);
;PCODE: $00002195 VOL: 0
;PCODE: $00002196 VOL: 0
;PCODE: $00002197 VOL: 0
;	*path -> Y+28
;	*nclst -> Y+26
;	*fatfs -> Y+24
;	res -> R17
;	*fs -> R18,R19
;	n -> Y+20
;	clst -> Y+16
;	sect -> Y+12
;	stat -> Y+8
;	i -> R20,R21
;	fat -> R16
;	*p -> Y+6
;PCODE: $00002198 VOL: 0
;PCODE: $00002199 VOL: 0
;PCODE: $0000219A VOL: 0
;PCODE: $0000219B VOL: 0
;PCODE: $0000219C VOL: 0
;PCODE: $0000219D VOL: 0
;PCODE: $0000219E VOL: 0
;	fs = *fatfs;
;PCODE: $0000219F VOL: 0
;PCODE: $000021A0 VOL: 0
;	if (res == FR_OK) {
;PCODE: $000021A1 VOL: 0
;PCODE: $000021A2 VOL: 0
;		/* If free_clust is valid, return it without full cluster scan */
;		if (fs->free_clust <= fs->n_fatent - 2) {
;PCODE: $000021A3 VOL: 0
;PCODE: $000021A4 VOL: 0
;PCODE: $000021A5 VOL: 0
;PCODE: $000021A6 VOL: 0
;PCODE: $000021A7 VOL: 0
;PCODE: $000021A8 VOL: 0
;PCODE: $000021A9 VOL: 0
;PCODE: $000021AA VOL: 0
;PCODE: $000021AB VOL: 0
;PCODE: $000021AC VOL: 0
;PCODE: $000021AD VOL: 0
;			*nclst = fs->free_clust;
;PCODE: $000021AE VOL: 0
;PCODE: $000021AF VOL: 0
;PCODE: $000021B0 VOL: 0
;PCODE: $000021B1 VOL: 0
;PCODE: $000021B2 VOL: 0
;		} else {
;PCODE: $000021B3 VOL: 0
;PCODE: $000021B4 VOL: 0
;			/* Get number of free clusters */
;			fat = fs->fs_type;
;PCODE: $000021B5 VOL: 0
;PCODE: $000021B6 VOL: 0
;			n = 0;
;PCODE: $000021B7 VOL: 0
;PCODE: $000021B8 VOL: 0
;			if (fat == FS_FAT12) {
;PCODE: $000021B9 VOL: 0
;PCODE: $000021BA VOL: 0
;PCODE: $000021BB VOL: 0
;				clst = 2;
;PCODE: $000021BC VOL: 0
;PCODE: $000021BD VOL: 0
;				do {
;PCODE: $000021BE VOL: 0
;					stat = get_fat(fs, clst);
;PCODE: $000021BF VOL: 0
;PCODE: $000021C0 VOL: 0
;PCODE: $000021C1 VOL: 0
;PCODE: $000021C2 VOL: 0
;					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;PCODE: $000021C3 VOL: 0
;PCODE: $000021C4 VOL: 0
;PCODE: $000021C5 VOL: 0
;PCODE: $000021C6 VOL: 0
;PCODE: $000021C7 VOL: 0
;PCODE: $000021C8 VOL: 0
;					if (stat == 1) { res = FR_INT_ERR; break; }
;PCODE: $000021C9 VOL: 0
;PCODE: $000021CA VOL: 0
;PCODE: $000021CB VOL: 0
;PCODE: $000021CC VOL: 0
;PCODE: $000021CD VOL: 0
;PCODE: $000021CE VOL: 0
;PCODE: $000021CF VOL: 0
;					if (stat == 0) n++;
;PCODE: $000021D0 VOL: 0
;PCODE: $000021D1 VOL: 0
;PCODE: $000021D2 VOL: 0
;PCODE: $000021D3 VOL: 0
;PCODE: $000021D4 VOL: 0
;PCODE: $000021D5 VOL: 0
;PCODE: $000021D6 VOL: 0
;				} while (++clst < fs->n_fatent);
;PCODE: $000021D7 VOL: 0
;PCODE: $000021D8 VOL: 0
;PCODE: $000021D9 VOL: 0
;PCODE: $000021DA VOL: 0
;PCODE: $000021DB VOL: 0
;PCODE: $000021DC VOL: 0
;PCODE: $000021DD VOL: 0
;PCODE: $000021DE VOL: 0
;PCODE: $000021DF VOL: 0
;PCODE: $000021E0 VOL: 0
;PCODE: $000021E1 VOL: 0
;PCODE: $000021E2 VOL: 0
;PCODE: $000021E3 VOL: 0
;PCODE: $000021E4 VOL: 0
;			} else {
;PCODE: $000021E5 VOL: 0
;PCODE: $000021E6 VOL: 0
;				clst = fs->n_fatent;
;PCODE: $000021E7 VOL: 0
;PCODE: $000021E8 VOL: 0
;PCODE: $000021E9 VOL: 0
;PCODE: $000021EA VOL: 0
;				sect = fs->fatbase;
;PCODE: $000021EB VOL: 0
;PCODE: $000021EC VOL: 0
;PCODE: $000021ED VOL: 0
;PCODE: $000021EE VOL: 0
;				i = 0; p = 0;
;PCODE: $000021EF VOL: 0
;PCODE: $000021F0 VOL: 0
;PCODE: $000021F1 VOL: 0
;PCODE: $000021F2 VOL: 0
;				do {
;PCODE: $000021F3 VOL: 0
;					if (!i) {
;PCODE: $000021F4 VOL: 0
;PCODE: $000021F5 VOL: 0
;						res = move_window(fs, sect++);
;PCODE: $000021F6 VOL: 0
;PCODE: $000021F7 VOL: 0
;PCODE: $000021F8 VOL: 0
;PCODE: $000021F9 VOL: 0
;PCODE: $000021FA VOL: 0
;PCODE: $000021FB VOL: 0
;PCODE: $000021FC VOL: 0
;PCODE: $000021FD VOL: 0
;						if (res != FR_OK) break;
;PCODE: $000021FE VOL: 0
;PCODE: $000021FF VOL: 0
;PCODE: $00002200 VOL: 0
;						p = fs->win;
;PCODE: $00002201 VOL: 0
;PCODE: $00002202 VOL: 0
;PCODE: $00002203 VOL: 0
;PCODE: $00002204 VOL: 0
;						i = SS(fs);
;PCODE: $00002205 VOL: 0
;PCODE: $00002206 VOL: 0
;					}
;					if (fat == FS_FAT16) {
;PCODE: $00002207 VOL: 0
;PCODE: $00002208 VOL: 0
;PCODE: $00002209 VOL: 0
;PCODE: $0000220A VOL: 0
;						if (LD_WORD(p) == 0) n++;
;PCODE: $0000220B VOL: 0
;PCODE: $0000220C VOL: 0
;PCODE: $0000220D VOL: 0
;PCODE: $0000220E VOL: 0
;PCODE: $0000220F VOL: 0
;PCODE: $00002210 VOL: 0
;PCODE: $00002211 VOL: 0
;PCODE: $00002212 VOL: 0
;PCODE: $00002213 VOL: 0
;PCODE: $00002214 VOL: 0
;PCODE: $00002215 VOL: 0
;PCODE: $00002216 VOL: 0
;PCODE: $00002217 VOL: 0
;						p += 2; i -= 2;
;PCODE: $00002218 VOL: 0
;PCODE: $00002219 VOL: 0
;PCODE: $0000221A VOL: 0
;PCODE: $0000221B VOL: 0
;PCODE: $0000221C VOL: 0
;PCODE: $0000221D VOL: 0
;					} else {
;PCODE: $0000221E VOL: 0
;PCODE: $0000221F VOL: 0
;						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
;PCODE: $00002220 VOL: 0
;PCODE: $00002221 VOL: 0
;PCODE: $00002222 VOL: 0
;PCODE: $00002223 VOL: 0
;PCODE: $00002224 VOL: 0
;PCODE: $00002225 VOL: 0
;PCODE: $00002226 VOL: 0
;PCODE: $00002227 VOL: 0
;PCODE: $00002228 VOL: 0
;PCODE: $00002229 VOL: 0
;PCODE: $0000222A VOL: 0
;PCODE: $0000222B VOL: 0
;PCODE: $0000222C VOL: 0
;PCODE: $0000222D VOL: 0
;PCODE: $0000222E VOL: 0
;PCODE: $0000222F VOL: 0
;PCODE: $00002230 VOL: 0
;PCODE: $00002231 VOL: 0
;PCODE: $00002232 VOL: 0
;PCODE: $00002233 VOL: 0
;PCODE: $00002234 VOL: 0
;PCODE: $00002235 VOL: 0
;PCODE: $00002236 VOL: 0
;PCODE: $00002237 VOL: 0
;PCODE: $00002238 VOL: 0
;PCODE: $00002239 VOL: 0
;PCODE: $0000223A VOL: 0
;PCODE: $0000223B VOL: 0
;PCODE: $0000223C VOL: 0
;PCODE: $0000223D VOL: 0
;						p += 4; i -= 4;
;PCODE: $0000223E VOL: 0
;PCODE: $0000223F VOL: 0
;PCODE: $00002240 VOL: 0
;PCODE: $00002241 VOL: 0
;PCODE: $00002242 VOL: 0
;PCODE: $00002243 VOL: 0
;					}
;PCODE: $00002244 VOL: 0
;				} while (--clst);
;PCODE: $00002245 VOL: 0
;PCODE: $00002246 VOL: 0
;PCODE: $00002247 VOL: 0
;PCODE: $00002248 VOL: 0
;PCODE: $00002249 VOL: 0
;PCODE: $0000224A VOL: 0
;PCODE: $0000224B VOL: 0
;			}
;PCODE: $0000224C VOL: 0
;			fs->free_clust = n;
;PCODE: $0000224D VOL: 0
;PCODE: $0000224E VOL: 0
;PCODE: $0000224F VOL: 0
;			fs->fsi_flag |= 1;
;PCODE: $00002250 VOL: 0
;PCODE: $00002251 VOL: 0
;PCODE: $00002252 VOL: 0
;PCODE: $00002253 VOL: 0
;PCODE: $00002254 VOL: 0
;			*nclst = n;
;PCODE: $00002255 VOL: 0
;PCODE: $00002256 VOL: 0
;PCODE: $00002257 VOL: 0
;		}
;PCODE: $00002258 VOL: 0
;	}
;	LEAVE_FF(fs, res);
;PCODE: $00002259 VOL: 0
;PCODE: $0000225A VOL: 0
;PCODE: $0000225B VOL: 0
;PCODE: $0000225C VOL: 0
;PCODE: $0000225D VOL: 0
;}
;PCODE: $0000225E VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Truncate File                                                         */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_truncate (
;	FIL* fp		/* Pointer to the file object */
;)
;{
;PCODE: $0000225F VOL: 0
;PCODE: $00002260 VOL: 0
;	FRESULT res;
;	DWORD ncl;
;
;
;	res = validate(fp);						/* Check validity of the object */
;PCODE: $00002261 VOL: 0
;PCODE: $00002262 VOL: 0
;PCODE: $00002263 VOL: 0
;	*fp -> Y+5
;	res -> R17
;	ncl -> Y+1
;PCODE: $00002264 VOL: 0
;PCODE: $00002265 VOL: 0
;PCODE: $00002266 VOL: 0
;	if (res == FR_OK) {
;PCODE: $00002267 VOL: 0
;PCODE: $00002268 VOL: 0
;		if (fp->err) {						/* Check error */
;PCODE: $00002269 VOL: 0
;PCODE: $0000226A VOL: 0
;PCODE: $0000226B VOL: 0
;PCODE: $0000226C VOL: 0
;			res = (FRESULT)fp->err;
;PCODE: $0000226D VOL: 0
;PCODE: $0000226E VOL: 0
;PCODE: $0000226F VOL: 0
;		} else {
;PCODE: $00002270 VOL: 0
;PCODE: $00002271 VOL: 0
;			if (!(fp->flag & FA_WRITE))		/* Check access mode */
;PCODE: $00002272 VOL: 0
;PCODE: $00002273 VOL: 0
;PCODE: $00002274 VOL: 0
;PCODE: $00002275 VOL: 0
;				res = FR_DENIED;
;PCODE: $00002276 VOL: 0
;PCODE: $00002277 VOL: 0
;		}
;PCODE: $00002278 VOL: 0
;PCODE: $00002279 VOL: 0
;	}
;	if (res == FR_OK) {
;PCODE: $0000227A VOL: 0
;PCODE: $0000227B VOL: 0
;PCODE: $0000227C VOL: 0
;		if (fp->fsize > fp->fptr) {
;PCODE: $0000227D VOL: 0
;PCODE: $0000227E VOL: 0
;PCODE: $0000227F VOL: 0
;PCODE: $00002280 VOL: 0
;PCODE: $00002281 VOL: 0
;PCODE: $00002282 VOL: 0
;PCODE: $00002283 VOL: 0
;PCODE: $00002284 VOL: 0
;PCODE: $00002285 VOL: 0
;			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;PCODE: $00002286 VOL: 0
;PCODE: $00002287 VOL: 0
;PCODE: $00002288 VOL: 0
;PCODE: $00002289 VOL: 0
;PCODE: $0000228A VOL: 0
;			fp->flag |= FA__WRITTEN;
;PCODE: $0000228B VOL: 0
;PCODE: $0000228C VOL: 0
;PCODE: $0000228D VOL: 0
;PCODE: $0000228E VOL: 0
;PCODE: $0000228F VOL: 0
;			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
;PCODE: $00002290 VOL: 0
;PCODE: $00002291 VOL: 0
;PCODE: $00002292 VOL: 0
;PCODE: $00002293 VOL: 0
;PCODE: $00002294 VOL: 0
;				res = remove_chain(fp->fs, fp->sclust);
;PCODE: $00002295 VOL: 0
;PCODE: $00002296 VOL: 0
;PCODE: $00002297 VOL: 0
;PCODE: $00002298 VOL: 0
;PCODE: $00002299 VOL: 0
;PCODE: $0000229A VOL: 0
;PCODE: $0000229B VOL: 0
;				fp->sclust = 0;
;PCODE: $0000229C VOL: 0
;PCODE: $0000229D VOL: 0
;PCODE: $0000229E VOL: 0
;PCODE: $0000229F VOL: 0
;			} else {				/* When truncate a part of the file, remove remaining clusters */
;PCODE: $000022A0 VOL: 0
;PCODE: $000022A1 VOL: 0
;				ncl = get_fat(fp->fs, fp->clust);
;PCODE: $000022A2 VOL: 0
;PCODE: $000022A3 VOL: 0
;PCODE: $000022A4 VOL: 0
;PCODE: $000022A5 VOL: 0
;PCODE: $000022A6 VOL: 0
;PCODE: $000022A7 VOL: 0
;PCODE: $000022A8 VOL: 0
;				res = FR_OK;
;PCODE: $000022A9 VOL: 0
;PCODE: $000022AA VOL: 0
;				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
;PCODE: $000022AB VOL: 0
;PCODE: $000022AC VOL: 0
;PCODE: $000022AD VOL: 0
;PCODE: $000022AE VOL: 0
;PCODE: $000022AF VOL: 0
;				if (ncl == 1) res = FR_INT_ERR;
;PCODE: $000022B0 VOL: 0
;PCODE: $000022B1 VOL: 0
;PCODE: $000022B2 VOL: 0
;PCODE: $000022B3 VOL: 0
;PCODE: $000022B4 VOL: 0
;PCODE: $000022B5 VOL: 0
;				if (res == FR_OK && ncl < fp->fs->n_fatent) {
;PCODE: $000022B6 VOL: 0
;PCODE: $000022B7 VOL: 0
;PCODE: $000022B8 VOL: 0
;PCODE: $000022B9 VOL: 0
;PCODE: $000022BA VOL: 0
;PCODE: $000022BB VOL: 0
;PCODE: $000022BC VOL: 0
;PCODE: $000022BD VOL: 0
;PCODE: $000022BE VOL: 0
;PCODE: $000022BF VOL: 0
;PCODE: $000022C0 VOL: 0
;PCODE: $000022C1 VOL: 0
;PCODE: $000022C2 VOL: 0
;PCODE: $000022C3 VOL: 0
;PCODE: $000022C4 VOL: 0
;					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
;PCODE: $000022C5 VOL: 0
;PCODE: $000022C6 VOL: 0
;PCODE: $000022C7 VOL: 0
;PCODE: $000022C8 VOL: 0
;PCODE: $000022C9 VOL: 0
;PCODE: $000022CA VOL: 0
;PCODE: $000022CB VOL: 0
;PCODE: $000022CC VOL: 0
;PCODE: $000022CD VOL: 0
;					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
;PCODE: $000022CE VOL: 0
;PCODE: $000022CF VOL: 0
;PCODE: $000022D0 VOL: 0
;PCODE: $000022D1 VOL: 0
;PCODE: $000022D2 VOL: 0
;PCODE: $000022D3 VOL: 0
;PCODE: $000022D4 VOL: 0
;PCODE: $000022D5 VOL: 0
;				}
;PCODE: $000022D6 VOL: 0
;			}
;PCODE: $000022D7 VOL: 0
;PCODE: $000022D8 VOL: 0
;#if !_FS_TINY
;			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
;				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;					res = FR_DISK_ERR;
;				else
;					fp->flag &= ~FA__DIRTY;
;			}
;#endif
;		}
;		if (res != FR_OK) fp->err = (FRESULT)res;
;PCODE: $000022D9 VOL: 0
;PCODE: $000022DA VOL: 0
;PCODE: $000022DB VOL: 0
;PCODE: $000022DC VOL: 0
;PCODE: $000022DD VOL: 0
;PCODE: $000022DE VOL: 0
;	}
;PCODE: $000022DF VOL: 0
;
;	LEAVE_FF(fp->fs, res);
;PCODE: $000022E0 VOL: 0
;PCODE: $000022E1 VOL: 0
;PCODE: $000022E2 VOL: 0
;PCODE: $000022E3 VOL: 0
;PCODE: $000022E4 VOL: 0
;PCODE: $000022E5 VOL: 0
;}
;PCODE: $000022E6 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Delete a File or Directory                                            */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_unlink (
;	const TCHAR* path		/* Pointer to the file or directory path */
;)
;{
;PCODE: $000022E7 VOL: 0
;PCODE: $000022E8 VOL: 0
;	FRESULT res;
;	DIR dj, sdj;
;	BYTE *dir;
;	DWORD dclst;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 1);
;PCODE: $000022E9 VOL: 0
;PCODE: $000022EA VOL: 0
;PCODE: $000022EB VOL: 0
;	*path -> Y+64
;	res -> R17
;	dj -> Y+42
;	sdj -> Y+20
;	*dir -> R18,R19
;	dclst -> Y+16
;	sfn -> Y+4
;PCODE: $000022EC VOL: 0
;PCODE: $000022ED VOL: 0
;PCODE: $000022EE VOL: 0
;PCODE: $000022EF VOL: 0
;PCODE: $000022F0 VOL: 0
;PCODE: $000022F1 VOL: 0
;PCODE: $000022F2 VOL: 0
;	if (res == FR_OK) {
;PCODE: $000022F3 VOL: 0
;PCODE: $000022F4 VOL: 0
;		INIT_BUF(dj);
;PCODE: $000022F5 VOL: 0
;PCODE: $000022F6 VOL: 0
;		res = follow_path(&dj, path);		/* Follow the file path */
;PCODE: $000022F7 VOL: 0
;PCODE: $000022F8 VOL: 0
;PCODE: $000022F9 VOL: 0
;PCODE: $000022FA VOL: 0
;PCODE: $000022FB VOL: 0
;		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;PCODE: $000022FC VOL: 0
;PCODE: $000022FD VOL: 0
;PCODE: $000022FE VOL: 0
;PCODE: $000022FF VOL: 0
;PCODE: $00002300 VOL: 0
;PCODE: $00002301 VOL: 0
;PCODE: $00002302 VOL: 0
;PCODE: $00002303 VOL: 0
;PCODE: $00002304 VOL: 0
;PCODE: $00002305 VOL: 0
;PCODE: $00002306 VOL: 0
;PCODE: $00002307 VOL: 0
;PCODE: $00002308 VOL: 0
;			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;PCODE: $00002309 VOL: 0
;PCODE: $0000230A VOL: 0
;#if _FS_LOCK
;		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
;#endif
;		if (res == FR_OK) {					/* The object is accessible */
;PCODE: $0000230B VOL: 0
;PCODE: $0000230C VOL: 0
;PCODE: $0000230D VOL: 0
;			dir = dj.dir;
;PCODE: $0000230E VOL: 0
;PCODE: $0000230F VOL: 0
;			if (!dir) {
;PCODE: $00002310 VOL: 0
;PCODE: $00002311 VOL: 0
;				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
;PCODE: $00002312 VOL: 0
;PCODE: $00002313 VOL: 0
;			} else {
;PCODE: $00002314 VOL: 0
;PCODE: $00002315 VOL: 0
;				if (dir[DIR_Attr] & AM_RDO)
;PCODE: $00002316 VOL: 0
;PCODE: $00002317 VOL: 0
;PCODE: $00002318 VOL: 0
;PCODE: $00002319 VOL: 0
;					res = FR_DENIED;		/* Cannot remove R/O object */
;PCODE: $0000231A VOL: 0
;PCODE: $0000231B VOL: 0
;			}
;PCODE: $0000231C VOL: 0
;PCODE: $0000231D VOL: 0
;			dclst = ld_clust(dj.fs, dir);
;PCODE: $0000231E VOL: 0
;PCODE: $0000231F VOL: 0
;PCODE: $00002320 VOL: 0
;PCODE: $00002321 VOL: 0
;PCODE: $00002322 VOL: 0
;			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
;PCODE: $00002323 VOL: 0
;PCODE: $00002324 VOL: 0
;PCODE: $00002325 VOL: 0
;PCODE: $00002326 VOL: 0
;PCODE: $00002327 VOL: 0
;PCODE: $00002328 VOL: 0
;PCODE: $00002329 VOL: 0
;PCODE: $0000232A VOL: 0
;PCODE: $0000232B VOL: 0
;PCODE: $0000232C VOL: 0
;				if (dclst < 2) {
;PCODE: $0000232D VOL: 0
;PCODE: $0000232E VOL: 0
;PCODE: $0000232F VOL: 0
;					res = FR_INT_ERR;
;PCODE: $00002330 VOL: 0
;PCODE: $00002331 VOL: 0
;				} else {
;PCODE: $00002332 VOL: 0
;PCODE: $00002333 VOL: 0
;					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-directory is empty or not */
;PCODE: $00002334 VOL: 0
;PCODE: $00002335 VOL: 0
;PCODE: $00002336 VOL: 0
;PCODE: $00002337 VOL: 0
;PCODE: $00002338 VOL: 0
;PCODE: $00002339 VOL: 0
;PCODE: $0000233A VOL: 0
;					sdj.sclust = dclst;
;PCODE: $0000233B VOL: 0
;PCODE: $0000233C VOL: 0
;					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
;PCODE: $0000233D VOL: 0
;PCODE: $0000233E VOL: 0
;PCODE: $0000233F VOL: 0
;PCODE: $00002340 VOL: 0
;PCODE: $00002341 VOL: 0
;PCODE: $00002342 VOL: 0
;					if (res == FR_OK) {
;PCODE: $00002343 VOL: 0
;PCODE: $00002344 VOL: 0
;						res = dir_read(&sdj, 0);	/* Read an item */
;PCODE: $00002345 VOL: 0
;PCODE: $00002346 VOL: 0
;PCODE: $00002347 VOL: 0
;PCODE: $00002348 VOL: 0
;PCODE: $00002349 VOL: 0
;PCODE: $0000234A VOL: 0
;						if (res == FR_OK		/* Not empty directory */
;#if _FS_RPATH
;						|| dclst == dj.fs->cdir	/* Current directory */
;#endif
;						) res = FR_DENIED;
;PCODE: $0000234B VOL: 0
;PCODE: $0000234C VOL: 0
;PCODE: $0000234D VOL: 0
;PCODE: $0000234E VOL: 0
;						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
;PCODE: $0000234F VOL: 0
;PCODE: $00002350 VOL: 0
;PCODE: $00002351 VOL: 0
;PCODE: $00002352 VOL: 0
;PCODE: $00002353 VOL: 0
;PCODE: $00002354 VOL: 0
;					}
;PCODE: $00002355 VOL: 0
;				}
;PCODE: $00002356 VOL: 0
;PCODE: $00002357 VOL: 0
;			}
;			if (res == FR_OK) {
;PCODE: $00002358 VOL: 0
;PCODE: $00002359 VOL: 0
;PCODE: $0000235A VOL: 0
;				res = dir_remove(&dj);		/* Remove the directory entry */
;PCODE: $0000235B VOL: 0
;PCODE: $0000235C VOL: 0
;PCODE: $0000235D VOL: 0
;				if (res == FR_OK) {
;PCODE: $0000235E VOL: 0
;PCODE: $0000235F VOL: 0
;					if (dclst)				/* Remove the cluster chain if exist */
;PCODE: $00002360 VOL: 0
;PCODE: $00002361 VOL: 0
;PCODE: $00002362 VOL: 0
;						res = remove_chain(dj.fs, dclst);
;PCODE: $00002363 VOL: 0
;PCODE: $00002364 VOL: 0
;PCODE: $00002365 VOL: 0
;PCODE: $00002366 VOL: 0
;PCODE: $00002367 VOL: 0
;					if (res == FR_OK) res = sync_fs(dj.fs);
;PCODE: $00002368 VOL: 0
;PCODE: $00002369 VOL: 0
;PCODE: $0000236A VOL: 0
;PCODE: $0000236B VOL: 0
;PCODE: $0000236C VOL: 0
;PCODE: $0000236D VOL: 0
;				}
;PCODE: $0000236E VOL: 0
;			}
;PCODE: $0000236F VOL: 0
;		}
;PCODE: $00002370 VOL: 0
;		FREE_BUF();
;PCODE: $00002371 VOL: 0
;	}
;
;	LEAVE_FF(dj.fs, res);
;PCODE: $00002372 VOL: 0
;PCODE: $00002373 VOL: 0
;PCODE: $00002374 VOL: 0
;PCODE: $00002375 VOL: 0
;PCODE: $00002376 VOL: 0
;}
;PCODE: $00002377 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Create a Directory                                                    */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_mkdir (
;	const TCHAR* path		/* Pointer to the directory path */
;)
;{
;PCODE: $00002378 VOL: 0
;PCODE: $00002379 VOL: 0
;	FRESULT res;
;	DIR dj;
;	BYTE *dir, n;
;	DWORD dsc, dcl, pcl, tm = get_fattime();
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 1);
;PCODE: $0000237A VOL: 0
;PCODE: $0000237B VOL: 0
;PCODE: $0000237C VOL: 0
;	*path -> Y+54
;	res -> R17
;	dj -> Y+32
;	*dir -> R18,R19
;	n -> R16
;	dsc -> Y+28
;	dcl -> Y+24
;	pcl -> Y+20
;	tm -> Y+16
;	sfn -> Y+4
;PCODE: $0000237D VOL: 0
;PCODE: $0000237E VOL: 0
;PCODE: $0000237F VOL: 0
;PCODE: $00002380 VOL: 0
;PCODE: $00002381 VOL: 0
;PCODE: $00002382 VOL: 0
;PCODE: $00002383 VOL: 0
;PCODE: $00002384 VOL: 0
;PCODE: $00002385 VOL: 0
;	if (res == FR_OK) {
;PCODE: $00002386 VOL: 0
;PCODE: $00002387 VOL: 0
;		INIT_BUF(dj);
;PCODE: $00002388 VOL: 0
;PCODE: $00002389 VOL: 0
;		res = follow_path(&dj, path);			/* Follow the file path */
;PCODE: $0000238A VOL: 0
;PCODE: $0000238B VOL: 0
;PCODE: $0000238C VOL: 0
;PCODE: $0000238D VOL: 0
;PCODE: $0000238E VOL: 0
;		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
;PCODE: $0000238F VOL: 0
;PCODE: $00002390 VOL: 0
;PCODE: $00002391 VOL: 0
;PCODE: $00002392 VOL: 0
;		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
;PCODE: $00002393 VOL: 0
;PCODE: $00002394 VOL: 0
;PCODE: $00002395 VOL: 0
;PCODE: $00002396 VOL: 0
;PCODE: $00002397 VOL: 0
;PCODE: $00002398 VOL: 0
;PCODE: $00002399 VOL: 0
;PCODE: $0000239A VOL: 0
;PCODE: $0000239B VOL: 0
;PCODE: $0000239C VOL: 0
;PCODE: $0000239D VOL: 0
;PCODE: $0000239E VOL: 0
;PCODE: $0000239F VOL: 0
;PCODE: $000023A0 VOL: 0
;PCODE: $000023A1 VOL: 0
;			res = FR_INVALID_NAME;
;PCODE: $000023A2 VOL: 0
;PCODE: $000023A3 VOL: 0
;		if (res == FR_NO_FILE) {				/* Can create a new directory */
;PCODE: $000023A4 VOL: 0
;PCODE: $000023A5 VOL: 0
;PCODE: $000023A6 VOL: 0
;PCODE: $000023A7 VOL: 0
;			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
;PCODE: $000023A8 VOL: 0
;PCODE: $000023A9 VOL: 0
;PCODE: $000023AA VOL: 0
;PCODE: $000023AB VOL: 0
;PCODE: $000023AC VOL: 0
;			res = FR_OK;
;PCODE: $000023AD VOL: 0
;PCODE: $000023AE VOL: 0
;			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
;PCODE: $000023AF VOL: 0
;PCODE: $000023B0 VOL: 0
;PCODE: $000023B1 VOL: 0
;PCODE: $000023B2 VOL: 0
;PCODE: $000023B3 VOL: 0
;			if (dcl == 1) res = FR_INT_ERR;
;PCODE: $000023B4 VOL: 0
;PCODE: $000023B5 VOL: 0
;PCODE: $000023B6 VOL: 0
;PCODE: $000023B7 VOL: 0
;PCODE: $000023B8 VOL: 0
;PCODE: $000023B9 VOL: 0
;			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
;PCODE: $000023BA VOL: 0
;PCODE: $000023BB VOL: 0
;PCODE: $000023BC VOL: 0
;PCODE: $000023BD VOL: 0
;PCODE: $000023BE VOL: 0
;PCODE: $000023BF VOL: 0
;			if (res == FR_OK)					/* Flush FAT */
;PCODE: $000023C0 VOL: 0
;PCODE: $000023C1 VOL: 0
;PCODE: $000023C2 VOL: 0
;				res = sync_window(dj.fs);
;PCODE: $000023C3 VOL: 0
;PCODE: $000023C4 VOL: 0
;PCODE: $000023C5 VOL: 0
;			if (res == FR_OK) {					/* Initialize the new directory table */
;PCODE: $000023C6 VOL: 0
;PCODE: $000023C7 VOL: 0
;PCODE: $000023C8 VOL: 0
;				dsc = clust2sect(dj.fs, dcl);
;PCODE: $000023C9 VOL: 0
;PCODE: $000023CA VOL: 0
;PCODE: $000023CB VOL: 0
;PCODE: $000023CC VOL: 0
;PCODE: $000023CD VOL: 0
;				dir = dj.fs->win;
;PCODE: $000023CE VOL: 0
;PCODE: $000023CF VOL: 0
;PCODE: $000023D0 VOL: 0
;				mem_set(dir, 0, SS(dj.fs));
;PCODE: $000023D1 VOL: 0
;PCODE: $000023D2 VOL: 0
;PCODE: $000023D3 VOL: 0
;PCODE: $000023D4 VOL: 0
;PCODE: $000023D5 VOL: 0
;				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
;PCODE: $000023D6 VOL: 0
;PCODE: $000023D7 VOL: 0
;PCODE: $000023D8 VOL: 0
;PCODE: $000023D9 VOL: 0
;PCODE: $000023DA VOL: 0
;PCODE: $000023DB VOL: 0
;PCODE: $000023DC VOL: 0
;PCODE: $000023DD VOL: 0
;				dir[DIR_Name] = '.';
;PCODE: $000023DE VOL: 0
;PCODE: $000023DF VOL: 0
;PCODE: $000023E0 VOL: 0
;				dir[DIR_Attr] = AM_DIR;
;PCODE: $000023E1 VOL: 0
;PCODE: $000023E2 VOL: 0
;PCODE: $000023E3 VOL: 0
;PCODE: $000023E4 VOL: 0
;				ST_DWORD(dir+DIR_WrtTime, tm);
;PCODE: $000023E5 VOL: 0
;PCODE: $000023E6 VOL: 0
;PCODE: $000023E7 VOL: 0
;PCODE: $000023E8 VOL: 0
;PCODE: $000023E9 VOL: 0
;PCODE: $000023EA VOL: 0
;PCODE: $000023EB VOL: 0
;PCODE: $000023EC VOL: 0
;PCODE: $000023ED VOL: 0
;PCODE: $000023EE VOL: 0
;PCODE: $000023EF VOL: 0
;PCODE: $000023F0 VOL: 0
;PCODE: $000023F1 VOL: 0
;PCODE: $000023F2 VOL: 0
;PCODE: $000023F3 VOL: 0
;				st_clust(dir, dcl);
;PCODE: $000023F4 VOL: 0
;PCODE: $000023F5 VOL: 0
;PCODE: $000023F6 VOL: 0
;				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
;PCODE: $000023F7 VOL: 0
;PCODE: $000023F8 VOL: 0
;PCODE: $000023F9 VOL: 0
;PCODE: $000023FA VOL: 0
;PCODE: $000023FB VOL: 0
;PCODE: $000023FC VOL: 0
;PCODE: $000023FD VOL: 0
;				dir[SZ_DIR+1] = '.'; pcl = dj.sclust;
;PCODE: $000023FE VOL: 0
;PCODE: $000023FF VOL: 0
;PCODE: $00002400 VOL: 0
;PCODE: $00002401 VOL: 0
;PCODE: $00002402 VOL: 0
;PCODE: $00002403 VOL: 0
;				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
;PCODE: $00002404 VOL: 0
;PCODE: $00002405 VOL: 0
;PCODE: $00002406 VOL: 0
;PCODE: $00002407 VOL: 0
;PCODE: $00002408 VOL: 0
;PCODE: $00002409 VOL: 0
;PCODE: $0000240A VOL: 0
;PCODE: $0000240B VOL: 0
;PCODE: $0000240C VOL: 0
;PCODE: $0000240D VOL: 0
;PCODE: $0000240E VOL: 0
;PCODE: $0000240F VOL: 0
;PCODE: $00002410 VOL: 0
;PCODE: $00002411 VOL: 0
;					pcl = 0;
;PCODE: $00002412 VOL: 0
;PCODE: $00002413 VOL: 0
;				st_clust(dir+SZ_DIR, pcl);
;PCODE: $00002414 VOL: 0
;PCODE: $00002415 VOL: 0
;PCODE: $00002416 VOL: 0
;PCODE: $00002417 VOL: 0
;PCODE: $00002418 VOL: 0
;PCODE: $00002419 VOL: 0
;				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
;PCODE: $0000241A VOL: 0
;PCODE: $0000241B VOL: 0
;PCODE: $0000241C VOL: 0
;PCODE: $0000241D VOL: 0
;PCODE: $0000241E VOL: 0
;PCODE: $0000241F VOL: 0
;PCODE: $00002420 VOL: 0
;PCODE: $00002421 VOL: 0
;PCODE: $00002422 VOL: 0
;					dj.fs->winsect = dsc++;
;PCODE: $00002423 VOL: 0
;PCODE: $00002424 VOL: 0
;PCODE: $00002425 VOL: 0
;PCODE: $00002426 VOL: 0
;PCODE: $00002427 VOL: 0
;PCODE: $00002428 VOL: 0
;					dj.fs->wflag = 1;
;PCODE: $00002429 VOL: 0
;PCODE: $0000242A VOL: 0
;PCODE: $0000242B VOL: 0
;PCODE: $0000242C VOL: 0
;					res = sync_window(dj.fs);
;PCODE: $0000242D VOL: 0
;PCODE: $0000242E VOL: 0
;PCODE: $0000242F VOL: 0
;					if (res != FR_OK) break;
;PCODE: $00002430 VOL: 0
;PCODE: $00002431 VOL: 0
;PCODE: $00002432 VOL: 0
;					mem_set(dir, 0, SS(dj.fs));
;PCODE: $00002433 VOL: 0
;PCODE: $00002434 VOL: 0
;PCODE: $00002435 VOL: 0
;PCODE: $00002436 VOL: 0
;PCODE: $00002437 VOL: 0
;PCODE: $00002438 VOL: 0
;				}
;PCODE: $00002439 VOL: 0
;PCODE: $0000243A VOL: 0
;PCODE: $0000243B VOL: 0
;PCODE: $0000243C VOL: 0
;PCODE: $0000243D VOL: 0
;			}
;			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
;PCODE: $0000243E VOL: 0
;PCODE: $0000243F VOL: 0
;PCODE: $00002440 VOL: 0
;PCODE: $00002441 VOL: 0
;PCODE: $00002442 VOL: 0
;PCODE: $00002443 VOL: 0
;			if (res != FR_OK) {
;PCODE: $00002444 VOL: 0
;PCODE: $00002445 VOL: 0
;PCODE: $00002446 VOL: 0
;				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
;PCODE: $00002447 VOL: 0
;PCODE: $00002448 VOL: 0
;PCODE: $00002449 VOL: 0
;PCODE: $0000244A VOL: 0
;			} else {
;PCODE: $0000244B VOL: 0
;PCODE: $0000244C VOL: 0
;				dir = dj.dir;
;PCODE: $0000244D VOL: 0
;PCODE: $0000244E VOL: 0
;				dir[DIR_Attr] = AM_DIR;				/* Attribute */
;PCODE: $0000244F VOL: 0
;PCODE: $00002450 VOL: 0
;PCODE: $00002451 VOL: 0
;PCODE: $00002452 VOL: 0
;				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
;PCODE: $00002453 VOL: 0
;PCODE: $00002454 VOL: 0
;PCODE: $00002455 VOL: 0
;PCODE: $00002456 VOL: 0
;PCODE: $00002457 VOL: 0
;PCODE: $00002458 VOL: 0
;PCODE: $00002459 VOL: 0
;PCODE: $0000245A VOL: 0
;PCODE: $0000245B VOL: 0
;PCODE: $0000245C VOL: 0
;PCODE: $0000245D VOL: 0
;PCODE: $0000245E VOL: 0
;PCODE: $0000245F VOL: 0
;PCODE: $00002460 VOL: 0
;PCODE: $00002461 VOL: 0
;				st_clust(dir, dcl);					/* Table start cluster */
;PCODE: $00002462 VOL: 0
;PCODE: $00002463 VOL: 0
;PCODE: $00002464 VOL: 0
;				dj.fs->wflag = 1;
;PCODE: $00002465 VOL: 0
;PCODE: $00002466 VOL: 0
;PCODE: $00002467 VOL: 0
;PCODE: $00002468 VOL: 0
;				res = sync_fs(dj.fs);
;PCODE: $00002469 VOL: 0
;PCODE: $0000246A VOL: 0
;PCODE: $0000246B VOL: 0
;			}
;PCODE: $0000246C VOL: 0
;		}
;		FREE_BUF();
;PCODE: $0000246D VOL: 0
;	}
;
;	LEAVE_FF(dj.fs, res);
;PCODE: $0000246E VOL: 0
;PCODE: $0000246F VOL: 0
;PCODE: $00002470 VOL: 0
;PCODE: $00002471 VOL: 0
;PCODE: $00002472 VOL: 0
;}
;PCODE: $00002473 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Change Attribute                                                      */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_chmod (
;	const TCHAR* path,	/* Pointer to the file path */
;	BYTE value,			/* Attribute bits */
;	BYTE mask			/* Attribute mask to change */
;)
;{
;PCODE: $00002474 VOL: 0
;PCODE: $00002475 VOL: 0
;	FRESULT res;
;	DIR dj;
;	BYTE *dir;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 1);
;PCODE: $00002476 VOL: 0
;PCODE: $00002477 VOL: 0
;PCODE: $00002478 VOL: 0
;	*path -> Y+40
;	value -> Y+39
;	mask -> Y+38
;	res -> R17
;	dj -> Y+16
;	*dir -> R18,R19
;	sfn -> Y+4
;PCODE: $00002479 VOL: 0
;PCODE: $0000247A VOL: 0
;PCODE: $0000247B VOL: 0
;PCODE: $0000247C VOL: 0
;PCODE: $0000247D VOL: 0
;PCODE: $0000247E VOL: 0
;PCODE: $0000247F VOL: 0
;	if (res == FR_OK) {
;PCODE: $00002480 VOL: 0
;PCODE: $00002481 VOL: 0
;		INIT_BUF(dj);
;PCODE: $00002482 VOL: 0
;PCODE: $00002483 VOL: 0
;		res = follow_path(&dj, path);		/* Follow the file path */
;PCODE: $00002484 VOL: 0
;PCODE: $00002485 VOL: 0
;PCODE: $00002486 VOL: 0
;PCODE: $00002487 VOL: 0
;PCODE: $00002488 VOL: 0
;		FREE_BUF();
;		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;PCODE: $00002489 VOL: 0
;PCODE: $0000248A VOL: 0
;PCODE: $0000248B VOL: 0
;PCODE: $0000248C VOL: 0
;PCODE: $0000248D VOL: 0
;PCODE: $0000248E VOL: 0
;PCODE: $0000248F VOL: 0
;PCODE: $00002490 VOL: 0
;PCODE: $00002491 VOL: 0
;PCODE: $00002492 VOL: 0
;PCODE: $00002493 VOL: 0
;PCODE: $00002494 VOL: 0
;PCODE: $00002495 VOL: 0
;			res = FR_INVALID_NAME;
;PCODE: $00002496 VOL: 0
;PCODE: $00002497 VOL: 0
;		if (res == FR_OK) {
;PCODE: $00002498 VOL: 0
;PCODE: $00002499 VOL: 0
;PCODE: $0000249A VOL: 0
;			dir = dj.dir;
;PCODE: $0000249B VOL: 0
;PCODE: $0000249C VOL: 0
;			if (!dir) {						/* Is it a root directory? */
;PCODE: $0000249D VOL: 0
;PCODE: $0000249E VOL: 0
;				res = FR_INVALID_NAME;
;PCODE: $0000249F VOL: 0
;PCODE: $000024A0 VOL: 0
;			} else {						/* File or sub directory */
;PCODE: $000024A1 VOL: 0
;PCODE: $000024A2 VOL: 0
;				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
;PCODE: $000024A3 VOL: 0
;PCODE: $000024A4 VOL: 0
;PCODE: $000024A5 VOL: 0
;				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
;PCODE: $000024A6 VOL: 0
;PCODE: $000024A7 VOL: 0
;PCODE: $000024A8 VOL: 0
;PCODE: $000024A9 VOL: 0
;PCODE: $000024AA VOL: 0
;PCODE: $000024AB VOL: 0
;PCODE: $000024AC VOL: 0
;PCODE: $000024AD VOL: 0
;PCODE: $000024AE VOL: 0
;PCODE: $000024AF VOL: 0
;PCODE: $000024B0 VOL: 0
;PCODE: $000024B1 VOL: 0
;				dj.fs->wflag = 1;
;PCODE: $000024B2 VOL: 0
;PCODE: $000024B3 VOL: 0
;PCODE: $000024B4 VOL: 0
;PCODE: $000024B5 VOL: 0
;				res = sync_fs(dj.fs);
;PCODE: $000024B6 VOL: 0
;PCODE: $000024B7 VOL: 0
;PCODE: $000024B8 VOL: 0
;			}
;PCODE: $000024B9 VOL: 0
;		}
;	}
;PCODE: $000024BA VOL: 0
;
;	LEAVE_FF(dj.fs, res);
;PCODE: $000024BB VOL: 0
;PCODE: $000024BC VOL: 0
;PCODE: $000024BD VOL: 0
;PCODE: $000024BE VOL: 0
;PCODE: $000024BF VOL: 0
;}
;PCODE: $000024C0 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Change Timestamp                                                      */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_utime (
;	const TCHAR* path,	/* Pointer to the file/directory name */
;	const FILINFO* fno	/* Pointer to the time stamp to be set */
;)
;{
;PCODE: $000024C1 VOL: 0
;PCODE: $000024C2 VOL: 0
;	FRESULT res;
;	DIR dj;
;	BYTE *dir;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 1);
;PCODE: $000024C3 VOL: 0
;PCODE: $000024C4 VOL: 0
;PCODE: $000024C5 VOL: 0
;	*path -> Y+40
;	*fno -> Y+38
;	res -> R17
;	dj -> Y+16
;	*dir -> R18,R19
;	sfn -> Y+4
;PCODE: $000024C6 VOL: 0
;PCODE: $000024C7 VOL: 0
;PCODE: $000024C8 VOL: 0
;PCODE: $000024C9 VOL: 0
;PCODE: $000024CA VOL: 0
;PCODE: $000024CB VOL: 0
;PCODE: $000024CC VOL: 0
;	if (res == FR_OK) {
;PCODE: $000024CD VOL: 0
;PCODE: $000024CE VOL: 0
;		INIT_BUF(dj);
;PCODE: $000024CF VOL: 0
;PCODE: $000024D0 VOL: 0
;		res = follow_path(&dj, path);	/* Follow the file path */
;PCODE: $000024D1 VOL: 0
;PCODE: $000024D2 VOL: 0
;PCODE: $000024D3 VOL: 0
;PCODE: $000024D4 VOL: 0
;PCODE: $000024D5 VOL: 0
;		FREE_BUF();
;		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;PCODE: $000024D6 VOL: 0
;PCODE: $000024D7 VOL: 0
;PCODE: $000024D8 VOL: 0
;PCODE: $000024D9 VOL: 0
;PCODE: $000024DA VOL: 0
;PCODE: $000024DB VOL: 0
;PCODE: $000024DC VOL: 0
;PCODE: $000024DD VOL: 0
;PCODE: $000024DE VOL: 0
;PCODE: $000024DF VOL: 0
;PCODE: $000024E0 VOL: 0
;PCODE: $000024E1 VOL: 0
;PCODE: $000024E2 VOL: 0
;			res = FR_INVALID_NAME;
;PCODE: $000024E3 VOL: 0
;PCODE: $000024E4 VOL: 0
;		if (res == FR_OK) {
;PCODE: $000024E5 VOL: 0
;PCODE: $000024E6 VOL: 0
;PCODE: $000024E7 VOL: 0
;			dir = dj.dir;
;PCODE: $000024E8 VOL: 0
;PCODE: $000024E9 VOL: 0
;			if (!dir) {					/* Root directory */
;PCODE: $000024EA VOL: 0
;PCODE: $000024EB VOL: 0
;				res = FR_INVALID_NAME;
;PCODE: $000024EC VOL: 0
;PCODE: $000024ED VOL: 0
;			} else {					/* File or sub-directory */
;PCODE: $000024EE VOL: 0
;PCODE: $000024EF VOL: 0
;				ST_WORD(dir+DIR_WrtTime, fno->ftime);
;PCODE: $000024F0 VOL: 0
;PCODE: $000024F1 VOL: 0
;PCODE: $000024F2 VOL: 0
;PCODE: $000024F3 VOL: 0
;PCODE: $000024F4 VOL: 0
;PCODE: $000024F5 VOL: 0
;PCODE: $000024F6 VOL: 0
;PCODE: $000024F7 VOL: 0
;PCODE: $000024F8 VOL: 0
;PCODE: $000024F9 VOL: 0
;				ST_WORD(dir+DIR_WrtDate, fno->fdate);
;PCODE: $000024FA VOL: 0
;PCODE: $000024FB VOL: 0
;PCODE: $000024FC VOL: 0
;PCODE: $000024FD VOL: 0
;PCODE: $000024FE VOL: 0
;PCODE: $000024FF VOL: 0
;PCODE: $00002500 VOL: 0
;PCODE: $00002501 VOL: 0
;PCODE: $00002502 VOL: 0
;PCODE: $00002503 VOL: 0
;				dj.fs->wflag = 1;
;PCODE: $00002504 VOL: 0
;PCODE: $00002505 VOL: 0
;PCODE: $00002506 VOL: 0
;PCODE: $00002507 VOL: 0
;				res = sync_fs(dj.fs);
;PCODE: $00002508 VOL: 0
;PCODE: $00002509 VOL: 0
;PCODE: $0000250A VOL: 0
;			}
;PCODE: $0000250B VOL: 0
;		}
;	}
;PCODE: $0000250C VOL: 0
;
;	LEAVE_FF(dj.fs, res);
;PCODE: $0000250D VOL: 0
;PCODE: $0000250E VOL: 0
;PCODE: $0000250F VOL: 0
;PCODE: $00002510 VOL: 0
;PCODE: $00002511 VOL: 0
;}
;PCODE: $00002512 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Rename File/Directory                                                 */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_rename (
;	const TCHAR* path_old,	/* Pointer to the old name */
;	const TCHAR* path_new	/* Pointer to the new name */
;)
;{
;PCODE: $00002513 VOL: 0
;PCODE: $00002514 VOL: 0
;	FRESULT res;
;	DIR djo, djn;
;	BYTE buf[21], *dir;
;	DWORD dw;
;	DEF_NAMEBUF;
;
;
;	/* Get logical drive number of the source object */
;	res = find_volume(&djo.fs, &path_old, 1);
;PCODE: $00002515 VOL: 0
;PCODE: $00002516 VOL: 0
;PCODE: $00002517 VOL: 0
;	*path_old -> Y+87
;	*path_new -> Y+85
;	res -> R17
;	djo -> Y+63
;	djn -> Y+41
;	buf -> Y+20
;	*dir -> R18,R19
;	dw -> Y+16
;	sfn -> Y+4
;PCODE: $00002518 VOL: 0
;PCODE: $00002519 VOL: 0
;PCODE: $0000251A VOL: 0
;PCODE: $0000251B VOL: 0
;PCODE: $0000251C VOL: 0
;PCODE: $0000251D VOL: 0
;PCODE: $0000251E VOL: 0
;	if (res == FR_OK) {
;PCODE: $0000251F VOL: 0
;PCODE: $00002520 VOL: 0
;		djn.fs = djo.fs;
;PCODE: $00002521 VOL: 0
;PCODE: $00002522 VOL: 0
;		INIT_BUF(djo);
;PCODE: $00002523 VOL: 0
;PCODE: $00002524 VOL: 0
;		res = follow_path(&djo, path_old);		/* Check old object */
;PCODE: $00002525 VOL: 0
;PCODE: $00002526 VOL: 0
;PCODE: $00002527 VOL: 0
;PCODE: $00002528 VOL: 0
;PCODE: $00002529 VOL: 0
;		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
;PCODE: $0000252A VOL: 0
;PCODE: $0000252B VOL: 0
;PCODE: $0000252C VOL: 0
;PCODE: $0000252D VOL: 0
;PCODE: $0000252E VOL: 0
;PCODE: $0000252F VOL: 0
;PCODE: $00002530 VOL: 0
;PCODE: $00002531 VOL: 0
;PCODE: $00002532 VOL: 0
;PCODE: $00002533 VOL: 0
;PCODE: $00002534 VOL: 0
;PCODE: $00002535 VOL: 0
;PCODE: $00002536 VOL: 0
;PCODE: $00002537 VOL: 0
;PCODE: $00002538 VOL: 0
;PCODE: $00002539 VOL: 0
;			res = FR_INVALID_NAME;
;PCODE: $0000253A VOL: 0
;PCODE: $0000253B VOL: 0
;#if _FS_LOCK
;		if (res == FR_OK) res = chk_lock(&djo, 2);
;#endif
;		if (res == FR_OK) {						/* Old object is found */
;PCODE: $0000253C VOL: 0
;PCODE: $0000253D VOL: 0
;PCODE: $0000253E VOL: 0
;			if (!djo.dir) {						/* Is root dir? */
;PCODE: $0000253F VOL: 0
;PCODE: $00002540 VOL: 0
;PCODE: $00002541 VOL: 0
;PCODE: $00002542 VOL: 0
;PCODE: $00002543 VOL: 0
;PCODE: $00002544 VOL: 0
;				res = FR_NO_FILE;
;PCODE: $00002545 VOL: 0
;PCODE: $00002546 VOL: 0
;			} else {
;PCODE: $00002547 VOL: 0
;PCODE: $00002548 VOL: 0
;				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
;PCODE: $00002549 VOL: 0
;PCODE: $0000254A VOL: 0
;PCODE: $0000254B VOL: 0
;PCODE: $0000254C VOL: 0
;PCODE: $0000254D VOL: 0
;PCODE: $0000254E VOL: 0
;PCODE: $0000254F VOL: 0
;PCODE: $00002550 VOL: 0
;PCODE: $00002551 VOL: 0
;PCODE: $00002552 VOL: 0
;PCODE: $00002553 VOL: 0
;				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
;PCODE: $00002554 VOL: 0
;PCODE: $00002555 VOL: 0
;PCODE: $00002556 VOL: 0
;PCODE: $00002557 VOL: 0
;PCODE: $00002558 VOL: 0
;PCODE: $00002559 VOL: 0
;PCODE: $0000255A VOL: 0
;				res = follow_path(&djn, path_new);
;PCODE: $0000255B VOL: 0
;PCODE: $0000255C VOL: 0
;PCODE: $0000255D VOL: 0
;PCODE: $0000255E VOL: 0
;PCODE: $0000255F VOL: 0
;				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
;PCODE: $00002560 VOL: 0
;PCODE: $00002561 VOL: 0
;PCODE: $00002562 VOL: 0
;PCODE: $00002563 VOL: 0
;				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
;PCODE: $00002564 VOL: 0
;PCODE: $00002565 VOL: 0
;PCODE: $00002566 VOL: 0
;PCODE: $00002567 VOL: 0
;/* Start critical section that any interruption can cause a cross-link */
;					res = dir_register(&djn);			/* Register the new entry */
;PCODE: $00002568 VOL: 0
;PCODE: $00002569 VOL: 0
;PCODE: $0000256A VOL: 0
;					if (res == FR_OK) {
;PCODE: $0000256B VOL: 0
;PCODE: $0000256C VOL: 0
;						dir = djn.dir;					/* Copy object information except for name */
;PCODE: $0000256D VOL: 0
;PCODE: $0000256E VOL: 0
;						mem_cpy(dir+13, buf+2, 19);
;PCODE: $0000256F VOL: 0
;PCODE: $00002570 VOL: 0
;PCODE: $00002571 VOL: 0
;PCODE: $00002572 VOL: 0
;PCODE: $00002573 VOL: 0
;PCODE: $00002574 VOL: 0
;PCODE: $00002575 VOL: 0
;PCODE: $00002576 VOL: 0
;						dir[DIR_Attr] = buf[0] | AM_ARC;
;PCODE: $00002577 VOL: 0
;PCODE: $00002578 VOL: 0
;PCODE: $00002579 VOL: 0
;PCODE: $0000257A VOL: 0
;						djo.fs->wflag = 1;
;PCODE: $0000257B VOL: 0
;PCODE: $0000257C VOL: 0
;PCODE: $0000257D VOL: 0
;PCODE: $0000257E VOL: 0
;						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
;PCODE: $0000257F VOL: 0
;PCODE: $00002580 VOL: 0
;PCODE: $00002581 VOL: 0
;PCODE: $00002582 VOL: 0
;PCODE: $00002583 VOL: 0
;PCODE: $00002584 VOL: 0
;PCODE: $00002585 VOL: 0
;PCODE: $00002586 VOL: 0
;PCODE: $00002587 VOL: 0
;PCODE: $00002588 VOL: 0
;PCODE: $00002589 VOL: 0
;PCODE: $0000258A VOL: 0
;PCODE: $0000258B VOL: 0
;PCODE: $0000258C VOL: 0
;PCODE: $0000258D VOL: 0
;PCODE: $0000258E VOL: 0
;							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
;PCODE: $0000258F VOL: 0
;PCODE: $00002590 VOL: 0
;PCODE: $00002591 VOL: 0
;PCODE: $00002592 VOL: 0
;PCODE: $00002593 VOL: 0
;PCODE: $00002594 VOL: 0
;PCODE: $00002595 VOL: 0
;PCODE: $00002596 VOL: 0
;PCODE: $00002597 VOL: 0
;							if (!dw) {
;PCODE: $00002598 VOL: 0
;PCODE: $00002599 VOL: 0
;PCODE: $0000259A VOL: 0
;								res = FR_INT_ERR;
;PCODE: $0000259B VOL: 0
;PCODE: $0000259C VOL: 0
;							} else {
;PCODE: $0000259D VOL: 0
;PCODE: $0000259E VOL: 0
;								res = move_window(djo.fs, dw);
;PCODE: $0000259F VOL: 0
;PCODE: $000025A0 VOL: 0
;PCODE: $000025A1 VOL: 0
;PCODE: $000025A2 VOL: 0
;PCODE: $000025A3 VOL: 0
;								dir = djo.fs->win+SZ_DIR;	/* .. entry */
;PCODE: $000025A4 VOL: 0
;PCODE: $000025A5 VOL: 0
;PCODE: $000025A6 VOL: 0
;								if (res == FR_OK && dir[1] == '.') {
;PCODE: $000025A7 VOL: 0
;PCODE: $000025A8 VOL: 0
;PCODE: $000025A9 VOL: 0
;PCODE: $000025AA VOL: 0
;PCODE: $000025AB VOL: 0
;PCODE: $000025AC VOL: 0
;PCODE: $000025AD VOL: 0
;PCODE: $000025AE VOL: 0
;PCODE: $000025AF VOL: 0
;PCODE: $000025B0 VOL: 0
;									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
;PCODE: $000025B1 VOL: 0
;PCODE: $000025B2 VOL: 0
;PCODE: $000025B3 VOL: 0
;PCODE: $000025B4 VOL: 0
;PCODE: $000025B5 VOL: 0
;PCODE: $000025B6 VOL: 0
;PCODE: $000025B7 VOL: 0
;PCODE: $000025B8 VOL: 0
;PCODE: $000025B9 VOL: 0
;PCODE: $000025BA VOL: 0
;PCODE: $000025BB VOL: 0
;PCODE: $000025BC VOL: 0
;PCODE: $000025BD VOL: 0
;PCODE: $000025BE VOL: 0
;PCODE: $000025BF VOL: 0
;PCODE: $000025C0 VOL: 0
;PCODE: $000025C1 VOL: 0
;PCODE: $000025C2 VOL: 0
;PCODE: $000025C3 VOL: 0
;PCODE: $000025C4 VOL: 0
;PCODE: $000025C5 VOL: 0
;PCODE: $000025C6 VOL: 0
;									st_clust(dir, dw);
;PCODE: $000025C7 VOL: 0
;PCODE: $000025C8 VOL: 0
;PCODE: $000025C9 VOL: 0
;									djo.fs->wflag = 1;
;PCODE: $000025CA VOL: 0
;PCODE: $000025CB VOL: 0
;PCODE: $000025CC VOL: 0
;PCODE: $000025CD VOL: 0
;								}
;							}
;PCODE: $000025CE VOL: 0
;PCODE: $000025CF VOL: 0
;						}
;						if (res == FR_OK) {
;PCODE: $000025D0 VOL: 0
;PCODE: $000025D1 VOL: 0
;PCODE: $000025D2 VOL: 0
;							res = dir_remove(&djo);		/* Remove old entry */
;PCODE: $000025D3 VOL: 0
;PCODE: $000025D4 VOL: 0
;PCODE: $000025D5 VOL: 0
;							if (res == FR_OK)
;PCODE: $000025D6 VOL: 0
;PCODE: $000025D7 VOL: 0
;								res = sync_fs(djo.fs);
;PCODE: $000025D8 VOL: 0
;PCODE: $000025D9 VOL: 0
;PCODE: $000025DA VOL: 0
;						}
;PCODE: $000025DB VOL: 0
;					}
;PCODE: $000025DC VOL: 0
;/* End critical section */
;				}
;PCODE: $000025DD VOL: 0
;			}
;PCODE: $000025DE VOL: 0
;PCODE: $000025DF VOL: 0
;		}
;		FREE_BUF();
;PCODE: $000025E0 VOL: 0
;	}
;
;	LEAVE_FF(djo.fs, res);
;PCODE: $000025E1 VOL: 0
;PCODE: $000025E2 VOL: 0
;PCODE: $000025E3 VOL: 0
;PCODE: $000025E4 VOL: 0
;PCODE: $000025E5 VOL: 0
;}
;PCODE: $000025E6 VOL: 0
;
;#endif /* !_FS_READONLY */
;#endif /* _FS_MINIMIZE == 0 */
;#endif /* _FS_MINIMIZE <= 1 */
;#endif /* _FS_MINIMIZE <= 2 */
;
;
;
;#if _USE_LABEL
;/*-----------------------------------------------------------------------*/
;/* Get volume label                                                      */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_getlabel (
;	const TCHAR* path,	/* Path name of the logical drive number */
;	TCHAR* label,		/* Pointer to a buffer to return the volume label */
;	DWORD* sn			/* Pointer to a variable to return the volume serial number */
;)
;{
;	FRESULT res;
;	DIR dj;
;	UINT i, j;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &path, 0);
;
;	/* Get volume label */
;	if (res == FR_OK && label) {
;		dj.sclust = 0;					/* Open root directory */
;		res = dir_sdi(&dj, 0);
;		if (res == FR_OK) {
;			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
;			if (res == FR_OK) {			/* A volume label is exist */
;#if _LFN_UNICODE
;				WCHAR w;
;				i = j = 0;
;				do {
;					w = (i < 11) ? dj.dir[i++] : ' ';
;					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
;						w = w << 8 | dj.dir[i++];
;					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
;				} while (j < 11);
;#else
;				mem_cpy(label, dj.dir, 11);
;#endif
;				j = 11;
;				do {
;					label[j] = 0;
;					if (!j) break;
;				} while (label[--j] == ' ');
;			}
;			if (res == FR_NO_FILE) {	/* No label, return nul string */
;				label[0] = 0;
;				res = FR_OK;
;			}
;		}
;	}
;
;	/* Get volume serial number */
;	if (res == FR_OK && sn) {
;		res = move_window(dj.fs, dj.fs->volbase);
;		if (res == FR_OK) {
;			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
;			*sn = LD_DWORD(&dj.fs->win[i]);
;		}
;	}
;
;	LEAVE_FF(dj.fs, res);
;}
;
;
;
;#if !_FS_READONLY
;/*-----------------------------------------------------------------------*/
;/* Set volume label                                                      */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_setlabel (
;	const TCHAR* label	/* Pointer to the volume label to set */
;)
;{
;	FRESULT res;
;	DIR dj;
;	BYTE vn[11];
;	UINT i, j, sl;
;	WCHAR w;
;	DWORD tm;
;
;
;	/* Get logical drive number */
;	res = find_volume(&dj.fs, &label, 1);
;	if (res) LEAVE_FF(dj.fs, res);
;
;	/* Create a volume label in directory form */
;	vn[0] = 0;
;	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
;	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
;	if (sl) {	/* Create volume label in directory form */
;		i = j = 0;
;		do {
;#if _LFN_UNICODE
;			w = ff_convert(ff_wtoupper(label[i++]), 0);
;#else
;			w = (BYTE)label[i++];
;			if (IsDBCS1(w))
;				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
;#if _USE_LFN
;			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
;#else
;			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
;#ifdef _EXCVT
;			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
;#else
;			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
;#endif
;#endif
;#endif
;			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for ...
;				LEAVE_FF(dj.fs, FR_INVALID_NAME);
;			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
;			vn[j++] = (BYTE)w;
;		} while (i < sl);
;		while (j < 11) vn[j++] = ' ';
;	}
;
;	/* Set volume label */
;	dj.sclust = 0;					/* Open root directory */
;	res = dir_sdi(&dj, 0);
;	if (res == FR_OK) {
;		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
;		if (res == FR_OK) {			/* A volume label is found */
;			if (vn[0]) {
;				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
;				tm = get_fattime();
;				ST_DWORD(dj.dir+DIR_WrtTime, tm);
;			} else {
;				dj.dir[0] = DDE;			/* Remove the volume label */
;			}
;			dj.fs->wflag = 1;
;			res = sync_fs(dj.fs);
;		} else {					/* No volume label is found or error */
;			if (res == FR_NO_FILE) {
;				res = FR_OK;
;				if (vn[0]) {				/* Create volume label as new */
;					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
;					if (res == FR_OK) {
;						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
;						mem_cpy(dj.dir, vn, 11);
;						dj.dir[DIR_Attr] = AM_VOL;
;						tm = get_fattime();
;						ST_DWORD(dj.dir+DIR_WrtTime, tm);
;						dj.fs->wflag = 1;
;						res = sync_fs(dj.fs);
;					}
;				}
;			}
;		}
;	}
;
;	LEAVE_FF(dj.fs, res);
;}
;
;#endif /* !_FS_READONLY */
;#endif /* _USE_LABEL */
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Forward data to the stream directly (available on only tiny cfg)      */
;/*-----------------------------------------------------------------------*/
;#if _USE_FORWARD && _FS_TINY
;
;FRESULT f_forward (
;	FIL* fp, 						/* Pointer to the file object */
;	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
;	UINT btf,						/* Number of bytes to forward */
;	UINT* bf						/* Pointer to number of bytes forwarded */
;)
;{
;	FRESULT res;
;	DWORD remain, clst, sect;
;	UINT rcnt;
;	BYTE csect;
;
;
;	*bf = 0;	/* Clear transfer byte counter */
;
;	res = validate(fp);								/* Check validity of the object */
;	if (res != FR_OK) LEAVE_FF(fp->fs, res);
;	if (fp->err)									/* Check error */
;		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;	if (!(fp->flag & FA_READ))						/* Check access mode */
;		LEAVE_FF(fp->fs, FR_DENIED);
;
;	remain = fp->fsize - fp->fptr;
;	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
;
;	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
;		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
;		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
;			if (!csect) {							/* On the cluster boundary? */
;				clst = (fp->fptr == 0) ?			/* On the top of the file? */
;					fp->sclust : get_fat(fp->fs, fp->clust);
;				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
;				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;				fp->clust = clst;					/* Update current cluster */
;			}
;		}
;		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
;		if (!sect) ABORT(fp->fs, FR_INT_ERR);
;		sect += csect;
;		if (move_window(fp->fs, sect))				/* Move sector window */
;			ABORT(fp->fs, FR_DISK_ERR);
;		fp->dsect = sect;
;		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
;		if (rcnt > btf) rcnt = btf;
;		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
;		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
;	}
;
;	LEAVE_FF(fp->fs, FR_OK);
;}
;#endif /* _USE_FORWARD */
;
;
;
;#if _USE_MKFS && !_FS_READONLY
;/*-----------------------------------------------------------------------*/
;/* Create File System on the Drive                                       */
;/*-----------------------------------------------------------------------*/
;#define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
;#define N_FATS		1		/* Number of FAT copies (1 or 2) */
;
;
;FRESULT f_mkfs (
;	const TCHAR* path,	/* Logical drive number */
;	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
;	UINT au				/* Allocation unit [bytes] */
;)
;{
;	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;	int vol;
;	BYTE fmt, md, sys, *tbl, pdrv, part;
;	DWORD n_clst, vs, n, wsect;
;	UINT i;
;	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;	FATFS *fs;
;	DSTATUS stat;
;
;
;	/* Check mounted drive and clear work area */
;	vol = get_ldnumber(&path);
;	if (vol < 0) return FR_INVALID_DRIVE;
;	if (sfd > 1) return FR_INVALID_PARAMETER;
;	if (au & (au - 1)) return FR_INVALID_PARAMETER;
;	fs = FatFs[vol];
;	if (!fs) return FR_NOT_ENABLED;
;	fs->fs_type = 0;
;	pdrv = LD2PD(vol);	/* Physical drive */
;	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;
;	/* Get disk statics */
;	stat = disk_initialize(pdrv);
;	if (stat & STA_NOINIT) return FR_NOT_READY;
;	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;#if _MAX_SS != 512					/* Get disk sector size */
;	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
;		return FR_DISK_ERR;
;#endif
;	if (_MULTI_PARTITION && part) {
;		/* Get partition information from partition table in the MBR */
;		if (disk_read(pdrv, fs->win, 0, 1)) return FR_DISK_ERR;
;		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
;		n_vol = LD_DWORD(tbl+12);	/* Volume size */
;	} else {
;		/* Create a partition in this function */
;		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;			return FR_DISK_ERR;
;		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;		n_vol -= b_vol;				/* Volume size */
;	}
;
;	if (!au) {				/* AU auto selection */
;		vs = n_vol / (2000 / (SS(fs) / 512));
;		for (i = 0; vs < vst[i]; i++) ;
;		au = cst[i];
;	}
;	au /= SS(fs);		/* Number of sectors per cluster */
;	if (au == 0) au = 1;
;	if (au > 128) au = 128;
;
;	/* Pre-compute number of clusters and FAT sub-type */
;	n_clst = n_vol / au;
;	fmt = FS_FAT12;
;	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;
;	/* Determine offset and size of FAT structure */
;	if (fmt == FS_FAT32) {
;		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;		n_rsv = 32;
;		n_dir = 0;
;	} else {
;		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;		n_rsv = 1;
;		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
;	}
;	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;	b_data = b_dir + n_dir;				/* Data area start sector */
;	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;
;	/* Align data start sector to erase block boundary (for flash memory media) */
;	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;	n = (n - b_data) / N_FATS;
;	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;		n_rsv += n;
;		b_fat += n;
;	} else {					/* FAT12/16: Expand FAT size */
;		n_fat += n;
;	}
;
;	/* Determine number of clusters and final check of validity of the FAT sub-type */
;	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;		return FR_MKFS_ABORTED;
;
;	/* Determine system ID in the partition table */
;	if (fmt == FS_FAT32) {
;		sys = 0x0C;		/* FAT32X */
;	} else {
;		if (fmt == FS_FAT12 && n_vol < 0x10000) {
;			sys = 0x01;	/* FAT12(<65536) */
;		} else {
;			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
;		}
;	}
;
;	if (_MULTI_PARTITION && part) {
;		/* Update system ID in the partition table */
;		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;		tbl[4] = sys;
;		if (disk_write(pdrv, fs->win, 0, 1))	/* Write it to teh MBR */
;			return FR_DISK_ERR;
;		md = 0xF8;
;	} else {
;		if (sfd) {	/* No partition table (SFD) */
;			md = 0xF0;
;		} else {	/* Create partition table (FDISK) */
;			mem_set(fs->win, 0, SS(fs));
;			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
;			tbl[1] = 1;						/* Partition start head */
;			tbl[2] = 1;						/* Partition start sector */
;			tbl[3] = 0;						/* Partition start cylinder */
;			tbl[4] = sys;					/* System type */
;			tbl[5] = 254;					/* Partition end head */
;			n = (b_vol + n_vol) / 63 / 255;
;			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
;			tbl[7] = (BYTE)n;				/* End cylinder */
;			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
;			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
;			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
;			if (disk_write(pdrv, fs->win, 0, 1))	/* Write it to the MBR */
;				return FR_DISK_ERR;
;			md = 0xF8;
;		}
;	}
;
;	/* Create BPB in the VBR */
;	tbl = fs->win;							/* Clear sector */
;	mem_set(tbl, 0, SS(fs));
;	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;	i = SS(fs);								/* Sector size */
;	ST_WORD(tbl+BPB_BytsPerSec, i);
;	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
;	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
;	ST_WORD(tbl+BPB_RootEntCnt, i);
;	if (n_vol < 0x10000) {					/* Number of total sectors */
;		ST_WORD(tbl+BPB_TotSec16, n_vol);
;	} else {
;		ST_DWORD(tbl+BPB_TotSec32, n_vol);
;	}
;	tbl[BPB_Media] = md;					/* Media descriptor */
;	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
;	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
;	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
;	n = get_fattime();						/* Use current time as VSN */
;	if (fmt == FS_FAT32) {
;		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
;		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
;		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSINFO record offset (VBR+1) */
;		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
;		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;	} else {
;		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
;		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;	}
;	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;	if (disk_write(pdrv, tbl, b_vol, 1))	/* Write it to the VBR sector */
;		return FR_DISK_ERR;
;	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR+6) */
;		disk_write(pdrv, tbl, b_vol + 6, 1);
;
;	/* Initialize FAT area */
;	wsect = b_fat;
;	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;		n = md;								/* Media descriptor byte */
;		if (fmt != FS_FAT32) {
;			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
;		} else {
;			n |= 0xFFFFFF00;
;			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
;			ST_DWORD(tbl+4, 0xFFFFFFFF);
;			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
;		}
;		if (disk_write(pdrv, tbl, wsect++, 1))
;			return FR_DISK_ERR;
;		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;			if (disk_write(pdrv, tbl, wsect++, 1))
;				return FR_DISK_ERR;
;		}
;	}
;
;	/* Initialize root directory */
;	i = (fmt == FS_FAT32) ? au : n_dir;
;	do {
;		if (disk_write(pdrv, tbl, wsect++, 1))
;			return FR_DISK_ERR;
;	} while (--i);
;
;#if _USE_ERASE	/* Erase data area if needed */
;	{
;		DWORD eb[2];
;
;		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
;	}
;#endif
;
;	/* Create FSINFO if needed */
;	if (fmt == FS_FAT32) {
;		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
;		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
;		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
;		ST_WORD(tbl+BS_55AA, 0xAA55);
;		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
;		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
;	}
;
;	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;}
;
;
;
;#if _MULTI_PARTITION
;/*-----------------------------------------------------------------------*/
;/* Divide Physical Drive                                                 */
;/*-----------------------------------------------------------------------*/
;
;FRESULT f_fdisk (
;	BYTE pdrv,			/* Physical drive number */
;	const DWORD szt[],	/* Pointer to the size table for each partitions */
;	void* work			/* Pointer to the working buffer */
;)
;{
;	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
;	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
;	DSTATUS stat;
;	DWORD sz_disk, sz_part, s_part;
;
;
;	stat = disk_initialize(pdrv);
;	if (stat & STA_NOINIT) return FR_NOT_READY;
;	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
;
;	/* Determine CHS in the table regardless of the drive geometry */
;	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
;	if (n == 256) n--;
;	e_hd = n - 1;
;	sz_cyl = 63 * n;
;	tot_cyl = sz_disk / sz_cyl;
;
;	/* Create partition table */
;	mem_set(buf, 0, _MAX_SS);
;	p = buf + MBR_Table; b_cyl = 0;
;	for (i = 0; i < 4; i++, p += SZ_PTE) {
;		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
;		if (!p_cyl) continue;
;		s_part = (DWORD)sz_cyl * b_cyl;
;		sz_part = (DWORD)sz_cyl * p_cyl;
;		if (i == 0) {	/* Exclude first track of cylinder 0 */
;			s_hd = 1;
;			s_part += 63; sz_part -= 63;
;		} else {
;			s_hd = 0;
;		}
;		e_cyl = b_cyl + p_cyl - 1;
;		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
;
;		/* Set partition table */
;		p[1] = s_hd;						/* Start head */
;		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
;		p[3] = (BYTE)b_cyl;					/* Start cylinder */
;		p[4] = 0x06;						/* System type (temporary setting) */
;		p[5] = e_hd;						/* End head */
;		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
;		p[7] = (BYTE)e_cyl;					/* End cylinder */
;		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
;		ST_DWORD(p + 12, sz_part);			/* Partition size */
;
;		/* Next partition */
;		b_cyl += p_cyl;
;	}
;	ST_WORD(p, 0xAA55);
;
;	/* Write it to the MBR */
;	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
;}
;
;
;#endif /* _MULTI_PARTITION */
;#endif /* _USE_MKFS && !_FS_READONLY */
;
;
;
;
;#if _USE_STRFUNC
;/*-----------------------------------------------------------------------*/
;/* Get a string from the file                                            */
;/*-----------------------------------------------------------------------*/
;
;TCHAR* f_gets (
;	TCHAR* buff,	/* Pointer to the string buffer to read */
;	int len,		/* Size of string buffer (characters) */
;	FIL* fp			/* Pointer to the file object */
;)
;{
;PCODE: $000025E7 VOL: 0
;PCODE: $000025E8 VOL: 0
;	int n = 0;
;	TCHAR c, *p = buff;
;	BYTE s[2];
;	UINT rc;
;
;
;	while (n < len - 1) {	/* Read characters until buffer gets filled */
;PCODE: $000025E9 VOL: 0
;PCODE: $000025EA VOL: 0
;PCODE: $000025EB VOL: 0
;	*buff -> Y+14
;	len -> Y+12
;	*fp -> Y+10
;	n -> R16,R17
;	c -> R19
;	*p -> R20,R21
;	s -> Y+8
;	rc -> Y+6
;PCODE: $000025EC VOL: 0
;PCODE: $000025ED VOL: 0
;PCODE: $000025EE VOL: 0
;PCODE: $000025EF VOL: 0
;PCODE: $000025F0 VOL: 0
;PCODE: $000025F1 VOL: 0
;PCODE: $000025F2 VOL: 0
;PCODE: $000025F3 VOL: 0
;PCODE: $000025F4 VOL: 0
;#if _LFN_UNICODE
;#if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
;		f_read(fp, s, 1, &rc);
;		if (rc != 1) break;
;		c = s[0];
;		if (c >= 0x80) {
;			if (c < 0xC0) continue;	/* Skip stray trailer */
;			if (c < 0xE0) {			/* Two-byte sequence */
;				f_read(fp, s, 1, &rc);
;				if (rc != 1) break;
;				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
;				if (c < 0x80) c = '?';
;			} else {
;				if (c < 0xF0) {		/* Three-byte sequence */
;					f_read(fp, s, 2, &rc);
;					if (rc != 2) break;
;					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
;					if (c < 0x800) c = '?';
;				} else {			/* Reject four-byte sequence */
;					c = '?';
;				}
;			}
;		}
;#elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
;		f_read(fp, s, 2, &rc);
;		if (rc != 2) break;
;		c = s[1] + (s[0] << 8);
;#elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
;		f_read(fp, s, 2, &rc);
;		if (rc != 2) break;
;		c = s[0] + (s[1] << 8);
;#else						/* Read a character in ANSI/OEM */
;		f_read(fp, s, 1, &rc);
;		if (rc != 1) break;
;		c = s[0];
;		if (IsDBCS1(c)) {
;			f_read(fp, s, 1, &rc);
;			if (rc != 1) break;
;			c = (c << 8) + s[0];
;		}
;		c = ff_convert(c, 1);	/* OEM -> Unicode */
;		if (!c) c = '?';
;#endif
;#else						/* Read a character without conversion */
;		f_read(fp, s, 1, &rc);
;PCODE: $000025F5 VOL: 0
;PCODE: $000025F6 VOL: 0
;PCODE: $000025F7 VOL: 0
;PCODE: $000025F8 VOL: 0
;PCODE: $000025F9 VOL: 0
;PCODE: $000025FA VOL: 0
;PCODE: $000025FB VOL: 0
;PCODE: $000025FC VOL: 0
;		if (rc != 1) break;
;PCODE: $000025FD VOL: 0
;PCODE: $000025FE VOL: 0
;PCODE: $000025FF VOL: 0
;PCODE: $00002600 VOL: 0
;		c = s[0];
;PCODE: $00002601 VOL: 0
;PCODE: $00002602 VOL: 0
;PCODE: $00002603 VOL: 0
;#endif
;		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
;PCODE: $00002604 VOL: 0
;PCODE: $00002605 VOL: 0
;PCODE: $00002606 VOL: 0
;PCODE: $00002607 VOL: 0
;PCODE: $00002608 VOL: 0
;PCODE: $00002609 VOL: 0
;PCODE: $0000260A VOL: 0
;PCODE: $0000260B VOL: 0
;PCODE: $0000260C VOL: 0
;PCODE: $0000260D VOL: 0
;PCODE: $0000260E VOL: 0
;		*p++ = c;
;PCODE: $0000260F VOL: 0
;PCODE: $00002610 VOL: 0
;PCODE: $00002611 VOL: 0
;PCODE: $00002612 VOL: 0
;PCODE: $00002613 VOL: 0
;PCODE: $00002614 VOL: 0
;PCODE: $00002615 VOL: 0
;		n++;
;PCODE: $00002616 VOL: 0
;PCODE: $00002617 VOL: 0
;		if (c == '\n') break;		/* Break on EOL */
;PCODE: $00002618 VOL: 0
;PCODE: $00002619 VOL: 0
;PCODE: $0000261A VOL: 0
;PCODE: $0000261B VOL: 0
;	}
;PCODE: $0000261C VOL: 0
;PCODE: $0000261D VOL: 0
;PCODE: $0000261E VOL: 0
;	*p = 0;
;PCODE: $0000261F VOL: 0
;PCODE: $00002620 VOL: 0
;PCODE: $00002621 VOL: 0
;	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
;PCODE: $00002622 VOL: 0
;PCODE: $00002623 VOL: 0
;PCODE: $00002624 VOL: 0
;PCODE: $00002625 VOL: 0
;PCODE: $00002626 VOL: 0
;PCODE: $00002627 VOL: 0
;PCODE: $00002628 VOL: 0
;PCODE: $00002629 VOL: 0
;PCODE: $0000262A VOL: 0
;PCODE: $0000262B VOL: 0
;PCODE: $0000262C VOL: 0
;}
;PCODE: $0000262D VOL: 0
;
;
;
;#if !_FS_READONLY
;#include <stdarg.h>
;/*-----------------------------------------------------------------------*/
;/* Put a character to the file                                           */
;/*-----------------------------------------------------------------------*/
;
;typedef struct {
;	FIL* fp;
;	int idx, nchr;
;	BYTE buf[64];
;} putbuff;
;
;
;static
;void putc_bfd (
;	putbuff* pb,
;	TCHAR c
;)
;{
;PCODE: $0000262E VOL: 0
;PCODE: $0000262F VOL: 0
;	UINT bw;
;	int i;
;
;
;	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
;PCODE: $00002630 VOL: 0
;PCODE: $00002631 VOL: 0
;	*pb -> Y+5
;	c -> Y+4
;	bw -> R16,R17
;	i -> R18,R19
;PCODE: $00002632 VOL: 0
;PCODE: $00002633 VOL: 0
;PCODE: $00002634 VOL: 0
;PCODE: $00002635 VOL: 0
;PCODE: $00002636 VOL: 0
;PCODE: $00002637 VOL: 0
;PCODE: $00002638 VOL: 0
;PCODE: $00002639 VOL: 0
;PCODE: $0000263A VOL: 0
;PCODE: $0000263B VOL: 0
;		putc_bfd(pb, '\r');
;PCODE: $0000263C VOL: 0
;PCODE: $0000263D VOL: 0
;PCODE: $0000263E VOL: 0
;PCODE: $0000263F VOL: 0
;
;	i = pb->idx;	/* Buffer write index (-1:error) */
;PCODE: $00002640 VOL: 0
;PCODE: $00002641 VOL: 0
;PCODE: $00002642 VOL: 0
;PCODE: $00002643 VOL: 0
;	if (i < 0) return;
;PCODE: $00002644 VOL: 0
;PCODE: $00002645 VOL: 0
;PCODE: $00002646 VOL: 0
;PCODE: $00002647 VOL: 0
;PCODE: $00002648 VOL: 0
;
;#if _LFN_UNICODE
;#if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
;	if (c < 0x80) {				/* 7-bit */
;		pb->buf[i++] = (BYTE)c;
;	} else {
;		if (c < 0x800) {		/* 11-bit */
;			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
;		} else {				/* 16-bit */
;			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
;			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
;		}
;		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
;	}
;#elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
;	pb->buf[i++] = (BYTE)(c >> 8);
;	pb->buf[i++] = (BYTE)c;
;#elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
;	pb->buf[i++] = (BYTE)c;
;	pb->buf[i++] = (BYTE)(c >> 8);
;#else							/* Write a character in ANSI/OEM */
;	c = ff_convert(c, 0);	/* Unicode -> OEM */
;	if (!c) c = '?';
;	if (c >= 0x100)
;		pb->buf[i++] = (BYTE)(c >> 8);
;	pb->buf[i++] = (BYTE)c;
;#endif
;#else							/* Write a character without conversion */
;	pb->buf[i++] = (BYTE)c;
;PCODE: $00002649 VOL: 0
;PCODE: $0000264A VOL: 0
;PCODE: $0000264B VOL: 0
;PCODE: $0000264C VOL: 0
;PCODE: $0000264D VOL: 0
;PCODE: $0000264E VOL: 0
;PCODE: $0000264F VOL: 0
;PCODE: $00002650 VOL: 0
;PCODE: $00002651 VOL: 0
;#endif
;
;	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
;PCODE: $00002652 VOL: 0
;PCODE: $00002653 VOL: 0
;PCODE: $00002654 VOL: 0
;		f_write(pb->fp, pb->buf, (UINT)i, &bw);
;PCODE: $00002655 VOL: 0
;PCODE: $00002656 VOL: 0
;PCODE: $00002657 VOL: 0
;PCODE: $00002658 VOL: 0
;PCODE: $00002659 VOL: 0
;PCODE: $0000265A VOL: 0
;PCODE: $0000265B VOL: 0
;PCODE: $0000265C VOL: 0
;PCODE: $0000265D VOL: 0
;PCODE: $0000265E VOL: 0
;PCODE: $0000265F VOL: 0
;PCODE: $00002660 VOL: 0
;PCODE: $00002661 VOL: 0
;PCODE: $00002662 VOL: 0
;		i = (bw == (UINT)i) ? 0 : -1;
;PCODE: $00002663 VOL: 0
;PCODE: $00002664 VOL: 0
;PCODE: $00002665 VOL: 0
;PCODE: $00002666 VOL: 0
;PCODE: $00002667 VOL: 0
;PCODE: $00002668 VOL: 0
;PCODE: $00002669 VOL: 0
;PCODE: $0000266A VOL: 0
;PCODE: $0000266B VOL: 0
;PCODE: $0000266C VOL: 0
;	}
;	pb->idx = i;
;PCODE: $0000266D VOL: 0
;PCODE: $0000266E VOL: 0
;PCODE: $0000266F VOL: 0
;PCODE: $00002670 VOL: 0
;	pb->nchr++;
;PCODE: $00002671 VOL: 0
;PCODE: $00002672 VOL: 0
;PCODE: $00002673 VOL: 0
;PCODE: $00002674 VOL: 0
;PCODE: $00002675 VOL: 0
;}
;PCODE: $00002676 VOL: 0
;PCODE: $00002677 VOL: 0
;PCODE: $00002678 VOL: 0
;PCODE: $00002679 VOL: 0
;
;
;
;int f_putc (
;	TCHAR c,	/* A character to be output */
;	FIL* fp		/* Pointer to the file object */
;)
;{
;PCODE: $0000267A VOL: 0
;PCODE: $0000267B VOL: 0
;	putbuff pb;
;	UINT nw;
;
;
;	pb.fp = fp;			/* Initialize output buffer */
;PCODE: $0000267C VOL: 0
;PCODE: $0000267D VOL: 0
;PCODE: $0000267E VOL: 0
;PCODE: $0000267F VOL: 0
;	c -> Y+74
;	*fp -> Y+72
;	pb -> Y+2
;	nw -> R16,R17
;PCODE: $00002680 VOL: 0
;PCODE: $00002681 VOL: 0
;	pb.nchr = pb.idx = 0;
;PCODE: $00002682 VOL: 0
;PCODE: $00002683 VOL: 0
;PCODE: $00002684 VOL: 0
;
;	putc_bfd(&pb, c);	/* Put a character */
;PCODE: $00002685 VOL: 0
;PCODE: $00002686 VOL: 0
;PCODE: $00002687 VOL: 0
;PCODE: $00002688 VOL: 0
;
;	if (   pb.idx >= 0	/* Flush buffered characters to the file */
;		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
;		&& (UINT)pb.idx == nw) return pb.nchr;
;PCODE: $00002689 VOL: 0
;PCODE: $0000268A VOL: 0
;PCODE: $0000268B VOL: 0
;PCODE: $0000268C VOL: 0
;PCODE: $0000268D VOL: 0
;PCODE: $0000268E VOL: 0
;PCODE: $0000268F VOL: 0
;PCODE: $00002690 VOL: 0
;PCODE: $00002691 VOL: 0
;PCODE: $00002692 VOL: 0
;PCODE: $00002693 VOL: 0
;PCODE: $00002694 VOL: 0
;PCODE: $00002695 VOL: 0
;PCODE: $00002696 VOL: 0
;PCODE: $00002697 VOL: 0
;PCODE: $00002698 VOL: 0
;PCODE: $00002699 VOL: 0
;PCODE: $0000269A VOL: 0
;PCODE: $0000269B VOL: 0
;PCODE: $0000269C VOL: 0
;PCODE: $0000269D VOL: 0
;PCODE: $0000269E VOL: 0
;PCODE: $0000269F VOL: 0
;PCODE: $000026A0 VOL: 0
;PCODE: $000026A1 VOL: 0
;PCODE: $000026A2 VOL: 0
;PCODE: $000026A3 VOL: 0
;PCODE: $000026A4 VOL: 0
;PCODE: $000026A5 VOL: 0
;PCODE: $000026A6 VOL: 0
;PCODE: $000026A7 VOL: 0
;PCODE: $000026A8 VOL: 0
;	return EOF;
;PCODE: $000026A9 VOL: 0
;PCODE: $000026AA VOL: 0
;PCODE: $000026AB VOL: 0
;PCODE: $000026AC VOL: 0
;PCODE: $000026AD VOL: 0
;PCODE: $000026AE VOL: 0
;PCODE: $000026AF VOL: 0
;PCODE: $000026B0 VOL: 0
;}
;PCODE: $000026B1 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Put a string to the file                                              */
;/*-----------------------------------------------------------------------*/
;
;int f_puts (
;	const TCHAR* str,	/* Pointer to the string to be output */
;	FIL* fp				/* Pointer to the file object */
;)
;{
;PCODE: $000026B2 VOL: 0
;PCODE: $000026B3 VOL: 0
;	putbuff pb;
;	UINT nw;
;
;
;	pb.fp = fp;				/* Initialize output buffer */
;PCODE: $000026B4 VOL: 0
;PCODE: $000026B5 VOL: 0
;PCODE: $000026B6 VOL: 0
;PCODE: $000026B7 VOL: 0
;	*str -> Y+74
;	*fp -> Y+72
;	pb -> Y+2
;	nw -> R16,R17
;PCODE: $000026B8 VOL: 0
;PCODE: $000026B9 VOL: 0
;	pb.nchr = pb.idx = 0;
;PCODE: $000026BA VOL: 0
;PCODE: $000026BB VOL: 0
;PCODE: $000026BC VOL: 0
;
;	while (*str)			/* Put the string */
;PCODE: $000026BD VOL: 0
;PCODE: $000026BE VOL: 0
;PCODE: $000026BF VOL: 0
;PCODE: $000026C0 VOL: 0
;PCODE: $000026C1 VOL: 0
;		putc_bfd(&pb, *str++);
;PCODE: $000026C2 VOL: 0
;PCODE: $000026C3 VOL: 0
;PCODE: $000026C4 VOL: 0
;PCODE: $000026C5 VOL: 0
;PCODE: $000026C6 VOL: 0
;PCODE: $000026C7 VOL: 0
;PCODE: $000026C8 VOL: 0
;PCODE: $000026C9 VOL: 0
;PCODE: $000026CA VOL: 0
;PCODE: $000026CB VOL: 0
;PCODE: $000026CC VOL: 0
;		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
;		&& (UINT)pb.idx == nw) return pb.nchr;
;PCODE: $000026CD VOL: 0
;PCODE: $000026CE VOL: 0
;PCODE: $000026CF VOL: 0
;PCODE: $000026D0 VOL: 0
;PCODE: $000026D1 VOL: 0
;PCODE: $000026D2 VOL: 0
;PCODE: $000026D3 VOL: 0
;PCODE: $000026D4 VOL: 0
;PCODE: $000026D5 VOL: 0
;PCODE: $000026D6 VOL: 0
;PCODE: $000026D7 VOL: 0
;PCODE: $000026D8 VOL: 0
;PCODE: $000026D9 VOL: 0
;PCODE: $000026DA VOL: 0
;PCODE: $000026DB VOL: 0
;PCODE: $000026DC VOL: 0
;PCODE: $000026DD VOL: 0
;PCODE: $000026DE VOL: 0
;PCODE: $000026DF VOL: 0
;PCODE: $000026E0 VOL: 0
;PCODE: $000026E1 VOL: 0
;PCODE: $000026E2 VOL: 0
;PCODE: $000026E3 VOL: 0
;PCODE: $000026E4 VOL: 0
;PCODE: $000026E5 VOL: 0
;PCODE: $000026E6 VOL: 0
;PCODE: $000026E7 VOL: 0
;PCODE: $000026E8 VOL: 0
;PCODE: $000026E9 VOL: 0
;PCODE: $000026EA VOL: 0
;PCODE: $000026EB VOL: 0
;PCODE: $000026EC VOL: 0
;	return EOF;
;PCODE: $000026ED VOL: 0
;PCODE: $000026EE VOL: 0
;PCODE: $000026EF VOL: 0
;PCODE: $000026F0 VOL: 0
;PCODE: $000026F1 VOL: 0
;PCODE: $000026F2 VOL: 0
;PCODE: $000026F3 VOL: 0
;PCODE: $000026F4 VOL: 0
;}
;PCODE: $000026F5 VOL: 0
;
;
;
;
;/*-----------------------------------------------------------------------*/
;/* Put a formatted string to the file                                    */
;/*-----------------------------------------------------------------------*/
;
;int f_printf (
;	FIL* fp,			/* Pointer to the file object */
;	const TCHAR* fmt,	/* Pointer to the format string */
;	...					/* Optional arguments... */
;)
;{
;PCODE: $000026F6 VOL: 0
;PCODE: $000026F7 VOL: 0
;PCODE: $000026F8 VOL: 0
;PCODE: $000026F9 VOL: 0
;	va_list arp;
;	BYTE f, r;
;	UINT nw, i, j, w;
;	DWORD v;
;	TCHAR c, d, s[16], *p;
;	putbuff pb;
;
;
;	pb.fp = fp;				/* Initialize output buffer */
;PCODE: $000026FA VOL: 0
;PCODE: $000026FB VOL: 0
;	*fp -> Y+108
;	*fmt -> Y+106
;	*arp -> R16,R17
;	f -> R19
;	r -> R18
;	nw -> R20,R21
;	i -> Y+104
;	j -> Y+102
;	w -> Y+100
;	v -> Y+96
;	c -> Y+95
;	d -> Y+94
;	s -> Y+78
;	*p -> Y+76
;	pb -> Y+6
;PCODE: $000026FC VOL: 0
;PCODE: $000026FD VOL: 0
;PCODE: $000026FE VOL: 0
;PCODE: $000026FF VOL: 0
;	pb.nchr = pb.idx = 0;
;PCODE: $00002700 VOL: 0
;PCODE: $00002701 VOL: 0
;PCODE: $00002702 VOL: 0
;
;	va_start(arp, fmt);
;PCODE: $00002703 VOL: 0
;PCODE: $00002704 VOL: 0
;PCODE: $00002705 VOL: 0
;
;	for (;;) {
;PCODE: $00002706 VOL: 0
;PCODE: $00002707 VOL: 0
;		c = *fmt++;
;PCODE: $00002708 VOL: 0
;PCODE: $00002709 VOL: 0
;PCODE: $0000270A VOL: 0
;PCODE: $0000270B VOL: 0
;PCODE: $0000270C VOL: 0
;PCODE: $0000270D VOL: 0
;PCODE: $0000270E VOL: 0
;PCODE: $0000270F VOL: 0
;		if (c == 0) break;			/* End of string */
;PCODE: $00002710 VOL: 0
;PCODE: $00002711 VOL: 0
;PCODE: $00002712 VOL: 0
;PCODE: $00002713 VOL: 0
;		if (c != '%') {				/* Non escape character */
;PCODE: $00002714 VOL: 0
;PCODE: $00002715 VOL: 0
;PCODE: $00002716 VOL: 0
;PCODE: $00002717 VOL: 0
;			putc_bfd(&pb, c);
;PCODE: $00002718 VOL: 0
;PCODE: $00002719 VOL: 0
;PCODE: $0000271A VOL: 0
;PCODE: $0000271B VOL: 0
;			continue;
;PCODE: $0000271C VOL: 0
;		}
;		w = f = 0;
;PCODE: $0000271D VOL: 0
;PCODE: $0000271E VOL: 0
;PCODE: $0000271F VOL: 0
;PCODE: $00002720 VOL: 0
;PCODE: $00002721 VOL: 0
;		c = *fmt++;
;PCODE: $00002722 VOL: 0
;PCODE: $00002723 VOL: 0
;PCODE: $00002724 VOL: 0
;PCODE: $00002725 VOL: 0
;PCODE: $00002726 VOL: 0
;PCODE: $00002727 VOL: 0
;PCODE: $00002728 VOL: 0
;PCODE: $00002729 VOL: 0
;		if (c == '0') {				/* Flag: '0' padding */
;PCODE: $0000272A VOL: 0
;PCODE: $0000272B VOL: 0
;PCODE: $0000272C VOL: 0
;			f = 1; c = *fmt++;
;PCODE: $0000272D VOL: 0
;PCODE: $0000272E VOL: 0
;PCODE: $0000272F VOL: 0
;PCODE: $00002730 VOL: 0
;PCODE: $00002731 VOL: 0
;PCODE: $00002732 VOL: 0
;PCODE: $00002733 VOL: 0
;PCODE: $00002734 VOL: 0
;PCODE: $00002735 VOL: 0
;PCODE: $00002736 VOL: 0
;		} else {
;PCODE: $00002737 VOL: 0
;PCODE: $00002738 VOL: 0
;			if (c == '-') {			/* Flag: left justified */
;PCODE: $00002739 VOL: 0
;PCODE: $0000273A VOL: 0
;PCODE: $0000273B VOL: 0
;				f = 2; c = *fmt++;
;PCODE: $0000273C VOL: 0
;PCODE: $0000273D VOL: 0
;PCODE: $0000273E VOL: 0
;PCODE: $0000273F VOL: 0
;PCODE: $00002740 VOL: 0
;PCODE: $00002741 VOL: 0
;PCODE: $00002742 VOL: 0
;PCODE: $00002743 VOL: 0
;PCODE: $00002744 VOL: 0
;PCODE: $00002745 VOL: 0
;			}
;		}
;PCODE: $00002746 VOL: 0
;PCODE: $00002747 VOL: 0
;		while (IsDigit(c)) {		/* Precision */
;PCODE: $00002748 VOL: 0
;PCODE: $00002749 VOL: 0
;PCODE: $0000274A VOL: 0
;PCODE: $0000274B VOL: 0
;PCODE: $0000274C VOL: 0
;PCODE: $0000274D VOL: 0
;PCODE: $0000274E VOL: 0
;PCODE: $0000274F VOL: 0
;PCODE: $00002750 VOL: 0
;PCODE: $00002751 VOL: 0
;PCODE: $00002752 VOL: 0
;			w = w * 10 + c - '0';
;PCODE: $00002753 VOL: 0
;PCODE: $00002754 VOL: 0
;PCODE: $00002755 VOL: 0
;PCODE: $00002756 VOL: 0
;PCODE: $00002757 VOL: 0
;PCODE: $00002758 VOL: 0
;PCODE: $00002759 VOL: 0
;PCODE: $0000275A VOL: 0
;PCODE: $0000275B VOL: 0
;			c = *fmt++;
;PCODE: $0000275C VOL: 0
;PCODE: $0000275D VOL: 0
;PCODE: $0000275E VOL: 0
;PCODE: $0000275F VOL: 0
;PCODE: $00002760 VOL: 0
;PCODE: $00002761 VOL: 0
;PCODE: $00002762 VOL: 0
;PCODE: $00002763 VOL: 0
;		}
;PCODE: $00002764 VOL: 0
;PCODE: $00002765 VOL: 0
;		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
;PCODE: $00002766 VOL: 0
;PCODE: $00002767 VOL: 0
;PCODE: $00002768 VOL: 0
;PCODE: $00002769 VOL: 0
;PCODE: $0000276A VOL: 0
;PCODE: $0000276B VOL: 0
;PCODE: $0000276C VOL: 0
;PCODE: $0000276D VOL: 0
;			f |= 4; c = *fmt++;
;PCODE: $0000276E VOL: 0
;PCODE: $0000276F VOL: 0
;PCODE: $00002770 VOL: 0
;PCODE: $00002771 VOL: 0
;PCODE: $00002772 VOL: 0
;PCODE: $00002773 VOL: 0
;PCODE: $00002774 VOL: 0
;PCODE: $00002775 VOL: 0
;PCODE: $00002776 VOL: 0
;PCODE: $00002777 VOL: 0
;		}
;		if (!c) break;
;PCODE: $00002778 VOL: 0
;PCODE: $00002779 VOL: 0
;PCODE: $0000277A VOL: 0
;PCODE: $0000277B VOL: 0
;PCODE: $0000277C VOL: 0
;		d = c;
;PCODE: $0000277D VOL: 0
;PCODE: $0000277E VOL: 0
;PCODE: $0000277F VOL: 0
;		if (IsLower(d)) d -= 0x20;
;PCODE: $00002780 VOL: 0
;PCODE: $00002781 VOL: 0
;PCODE: $00002782 VOL: 0
;PCODE: $00002783 VOL: 0
;PCODE: $00002784 VOL: 0
;PCODE: $00002785 VOL: 0
;PCODE: $00002786 VOL: 0
;PCODE: $00002787 VOL: 0
;PCODE: $00002788 VOL: 0
;PCODE: $00002789 VOL: 0
;PCODE: $0000278A VOL: 0
;PCODE: $0000278B VOL: 0
;PCODE: $0000278C VOL: 0
;		switch (d) {				/* Type is... */
;PCODE: $0000278D VOL: 0
;PCODE: $0000278E VOL: 0
;PCODE: $0000278F VOL: 0
;		case 'S' :					/* String */
;PCODE: $00002790 VOL: 0
;PCODE: $00002791 VOL: 0
;			p = va_arg(arp, TCHAR*);
;PCODE: $00002792 VOL: 0
;PCODE: $00002793 VOL: 0
;PCODE: $00002794 VOL: 0
;PCODE: $00002795 VOL: 0
;PCODE: $00002796 VOL: 0
;PCODE: $00002797 VOL: 0
;			for (j = 0; p[j]; j++) ;
;PCODE: $00002798 VOL: 0
;PCODE: $00002799 VOL: 0
;PCODE: $0000279A VOL: 0
;PCODE: $0000279B VOL: 0
;PCODE: $0000279C VOL: 0
;PCODE: $0000279D VOL: 0
;PCODE: $0000279E VOL: 0
;PCODE: $0000279F VOL: 0
;PCODE: $000027A0 VOL: 0
;PCODE: $000027A1 VOL: 0
;PCODE: $000027A2 VOL: 0
;PCODE: $000027A3 VOL: 0
;PCODE: $000027A4 VOL: 0
;PCODE: $000027A5 VOL: 0
;PCODE: $000027A6 VOL: 0
;PCODE: $000027A7 VOL: 0
;PCODE: $000027A8 VOL: 0
;PCODE: $000027A9 VOL: 0
;PCODE: $000027AA VOL: 0
;PCODE: $000027AB VOL: 0
;PCODE: $000027AC VOL: 0
;			if (!(f & 2)) {
;PCODE: $000027AD VOL: 0
;PCODE: $000027AE VOL: 0
;PCODE: $000027AF VOL: 0
;				while (j++ < w) putc_bfd(&pb, ' ');
;PCODE: $000027B0 VOL: 0
;PCODE: $000027B1 VOL: 0
;PCODE: $000027B2 VOL: 0
;PCODE: $000027B3 VOL: 0
;PCODE: $000027B4 VOL: 0
;PCODE: $000027B5 VOL: 0
;PCODE: $000027B6 VOL: 0
;PCODE: $000027B7 VOL: 0
;PCODE: $000027B8 VOL: 0
;PCODE: $000027B9 VOL: 0
;PCODE: $000027BA VOL: 0
;PCODE: $000027BB VOL: 0
;PCODE: $000027BC VOL: 0
;PCODE: $000027BD VOL: 0
;PCODE: $000027BE VOL: 0
;PCODE: $000027BF VOL: 0
;			while (*p) putc_bfd(&pb, *p++);
;PCODE: $000027C0 VOL: 0
;PCODE: $000027C1 VOL: 0
;PCODE: $000027C2 VOL: 0
;PCODE: $000027C3 VOL: 0
;PCODE: $000027C4 VOL: 0
;PCODE: $000027C5 VOL: 0
;PCODE: $000027C6 VOL: 0
;PCODE: $000027C7 VOL: 0
;PCODE: $000027C8 VOL: 0
;PCODE: $000027C9 VOL: 0
;PCODE: $000027CA VOL: 0
;PCODE: $000027CB VOL: 0
;PCODE: $000027CC VOL: 0
;PCODE: $000027CD VOL: 0
;PCODE: $000027CE VOL: 0
;PCODE: $000027CF VOL: 0
;PCODE: $000027D0 VOL: 0
;PCODE: $000027D1 VOL: 0
;PCODE: $000027D2 VOL: 0
;PCODE: $000027D3 VOL: 0
;PCODE: $000027D4 VOL: 0
;PCODE: $000027D5 VOL: 0
;PCODE: $000027D6 VOL: 0
;PCODE: $000027D7 VOL: 0
;PCODE: $000027D8 VOL: 0
;PCODE: $000027D9 VOL: 0
;PCODE: $000027DA VOL: 0
;PCODE: $000027DB VOL: 0
;PCODE: $000027DC VOL: 0
;PCODE: $000027DD VOL: 0
;PCODE: $000027DE VOL: 0
;PCODE: $000027DF VOL: 0
;PCODE: $000027E0 VOL: 0
;PCODE: $000027E1 VOL: 0
;		case 'C' :					/* Character */
;PCODE: $000027E2 VOL: 0
;PCODE: $000027E3 VOL: 0
;PCODE: $000027E4 VOL: 0
;PCODE: $000027E5 VOL: 0
;PCODE: $000027E6 VOL: 0
;			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
;PCODE: $000027E7 VOL: 0
;PCODE: $000027E8 VOL: 0
;PCODE: $000027E9 VOL: 0
;PCODE: $000027EA VOL: 0
;PCODE: $000027EB VOL: 0
;PCODE: $000027EC VOL: 0
;PCODE: $000027ED VOL: 0
;PCODE: $000027EE VOL: 0
;		case 'B' :					/* Binary */
;PCODE: $000027EF VOL: 0
;PCODE: $000027F0 VOL: 0
;PCODE: $000027F1 VOL: 0
;PCODE: $000027F2 VOL: 0
;PCODE: $000027F3 VOL: 0
;			r = 2; break;
;PCODE: $000027F4 VOL: 0
;PCODE: $000027F5 VOL: 0
;PCODE: $000027F6 VOL: 0
;		case 'O' :					/* Octal */
;PCODE: $000027F7 VOL: 0
;PCODE: $000027F8 VOL: 0
;PCODE: $000027F9 VOL: 0
;			r = 8; break;
;PCODE: $000027FA VOL: 0
;PCODE: $000027FB VOL: 0
;PCODE: $000027FC VOL: 0
;		case 'D' :					/* Signed decimal */
;PCODE: $000027FD VOL: 0
;PCODE: $000027FE VOL: 0
;PCODE: $000027FF VOL: 0
;		case 'U' :					/* Unsigned decimal */
;PCODE: $00002800 VOL: 0
;PCODE: $00002801 VOL: 0
;PCODE: $00002802 VOL: 0
;PCODE: $00002803 VOL: 0
;PCODE: $00002804 VOL: 0
;			r = 10; break;
;PCODE: $00002805 VOL: 0
;PCODE: $00002806 VOL: 0
;PCODE: $00002807 VOL: 0
;		case 'X' :					/* Hexdecimal */
;PCODE: $00002808 VOL: 0
;PCODE: $00002809 VOL: 0
;PCODE: $0000280A VOL: 0
;			r = 16; break;
;PCODE: $0000280B VOL: 0
;PCODE: $0000280C VOL: 0
;PCODE: $0000280D VOL: 0
;		default:					/* Unknown type (pass-through) */
;PCODE: $0000280E VOL: 0
;			putc_bfd(&pb, c); continue;
;PCODE: $0000280F VOL: 0
;PCODE: $00002810 VOL: 0
;PCODE: $00002811 VOL: 0
;PCODE: $00002812 VOL: 0
;PCODE: $00002813 VOL: 0
;		}
;PCODE: $00002814 VOL: 0
;
;		/* Get an argument and put it in numeral */
;		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int ...
;PCODE: $00002815 VOL: 0
;PCODE: $00002816 VOL: 0
;PCODE: $00002817 VOL: 0
;PCODE: $00002818 VOL: 0
;PCODE: $00002819 VOL: 0
;PCODE: $0000281A VOL: 0
;PCODE: $0000281B VOL: 0
;PCODE: $0000281C VOL: 0
;PCODE: $0000281D VOL: 0
;PCODE: $0000281E VOL: 0
;PCODE: $0000281F VOL: 0
;PCODE: $00002820 VOL: 0
;PCODE: $00002821 VOL: 0
;PCODE: $00002822 VOL: 0
;PCODE: $00002823 VOL: 0
;PCODE: $00002824 VOL: 0
;PCODE: $00002825 VOL: 0
;PCODE: $00002826 VOL: 0
;PCODE: $00002827 VOL: 0
;PCODE: $00002828 VOL: 0
;PCODE: $00002829 VOL: 0
;PCODE: $0000282A VOL: 0
;PCODE: $0000282B VOL: 0
;PCODE: $0000282C VOL: 0
;PCODE: $0000282D VOL: 0
;PCODE: $0000282E VOL: 0
;PCODE: $0000282F VOL: 0
;PCODE: $00002830 VOL: 0
;PCODE: $00002831 VOL: 0
;PCODE: $00002832 VOL: 0
;PCODE: $00002833 VOL: 0
;PCODE: $00002834 VOL: 0
;PCODE: $00002835 VOL: 0
;PCODE: $00002836 VOL: 0
;		if (d == 'D' && (v & 0x80000000)) {
;PCODE: $00002837 VOL: 0
;PCODE: $00002838 VOL: 0
;PCODE: $00002839 VOL: 0
;PCODE: $0000283A VOL: 0
;PCODE: $0000283B VOL: 0
;PCODE: $0000283C VOL: 0
;PCODE: $0000283D VOL: 0
;PCODE: $0000283E VOL: 0
;PCODE: $0000283F VOL: 0
;PCODE: $00002840 VOL: 0
;PCODE: $00002841 VOL: 0
;			v = 0 - v;
;PCODE: $00002842 VOL: 0
;PCODE: $00002843 VOL: 0
;PCODE: $00002844 VOL: 0
;PCODE: $00002845 VOL: 0
;			f |= 8;
;PCODE: $00002846 VOL: 0
;PCODE: $00002847 VOL: 0
;		}
;		i = 0;
;PCODE: $00002848 VOL: 0
;PCODE: $00002849 VOL: 0
;PCODE: $0000284A VOL: 0
;		do {
;PCODE: $0000284B VOL: 0
;			d = (TCHAR)(v % r); v /= r;
;PCODE: $0000284C VOL: 0
;PCODE: $0000284D VOL: 0
;PCODE: $0000284E VOL: 0
;PCODE: $0000284F VOL: 0
;PCODE: $00002850 VOL: 0
;PCODE: $00002851 VOL: 0
;PCODE: $00002852 VOL: 0
;PCODE: $00002853 VOL: 0
;PCODE: $00002854 VOL: 0
;PCODE: $00002855 VOL: 0
;PCODE: $00002856 VOL: 0
;PCODE: $00002857 VOL: 0
;			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
;PCODE: $00002858 VOL: 0
;PCODE: $00002859 VOL: 0
;PCODE: $0000285A VOL: 0
;PCODE: $0000285B VOL: 0
;PCODE: $0000285C VOL: 0
;PCODE: $0000285D VOL: 0
;PCODE: $0000285E VOL: 0
;PCODE: $0000285F VOL: 0
;PCODE: $00002860 VOL: 0
;PCODE: $00002861 VOL: 0
;PCODE: $00002862 VOL: 0
;PCODE: $00002863 VOL: 0
;PCODE: $00002864 VOL: 0
;PCODE: $00002865 VOL: 0
;PCODE: $00002866 VOL: 0
;			s[i++] = d + '0';
;PCODE: $00002867 VOL: 0
;PCODE: $00002868 VOL: 0
;PCODE: $00002869 VOL: 0
;PCODE: $0000286A VOL: 0
;PCODE: $0000286B VOL: 0
;PCODE: $0000286C VOL: 0
;PCODE: $0000286D VOL: 0
;PCODE: $0000286E VOL: 0
;PCODE: $0000286F VOL: 0
;PCODE: $00002870 VOL: 0
;PCODE: $00002871 VOL: 0
;		} while (v && i < sizeof s / sizeof s[0]);
;PCODE: $00002872 VOL: 0
;PCODE: $00002873 VOL: 0
;PCODE: $00002874 VOL: 0
;PCODE: $00002875 VOL: 0
;PCODE: $00002876 VOL: 0
;PCODE: $00002877 VOL: 0
;PCODE: $00002878 VOL: 0
;PCODE: $00002879 VOL: 0
;PCODE: $0000287A VOL: 0
;PCODE: $0000287B VOL: 0
;PCODE: $0000287C VOL: 0
;PCODE: $0000287D VOL: 0
;PCODE: $0000287E VOL: 0
;		if (f & 8) s[i++] = '-';
;PCODE: $0000287F VOL: 0
;PCODE: $00002880 VOL: 0
;PCODE: $00002881 VOL: 0
;PCODE: $00002882 VOL: 0
;PCODE: $00002883 VOL: 0
;PCODE: $00002884 VOL: 0
;PCODE: $00002885 VOL: 0
;PCODE: $00002886 VOL: 0
;PCODE: $00002887 VOL: 0
;PCODE: $00002888 VOL: 0
;PCODE: $00002889 VOL: 0
;PCODE: $0000288A VOL: 0
;		j = i; d = (f & 1) ? '0' : ' ';
;PCODE: $0000288B VOL: 0
;PCODE: $0000288C VOL: 0
;PCODE: $0000288D VOL: 0
;PCODE: $0000288E VOL: 0
;PCODE: $0000288F VOL: 0
;PCODE: $00002890 VOL: 0
;PCODE: $00002891 VOL: 0
;PCODE: $00002892 VOL: 0
;PCODE: $00002893 VOL: 0
;PCODE: $00002894 VOL: 0
;PCODE: $00002895 VOL: 0
;PCODE: $00002896 VOL: 0
;PCODE: $00002897 VOL: 0
;		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
;PCODE: $00002898 VOL: 0
;PCODE: $00002899 VOL: 0
;PCODE: $0000289A VOL: 0
;PCODE: $0000289B VOL: 0
;PCODE: $0000289C VOL: 0
;PCODE: $0000289D VOL: 0
;PCODE: $0000289E VOL: 0
;PCODE: $0000289F VOL: 0
;PCODE: $000028A0 VOL: 0
;PCODE: $000028A1 VOL: 0
;PCODE: $000028A2 VOL: 0
;PCODE: $000028A3 VOL: 0
;PCODE: $000028A4 VOL: 0
;PCODE: $000028A5 VOL: 0
;PCODE: $000028A6 VOL: 0
;PCODE: $000028A7 VOL: 0
;PCODE: $000028A8 VOL: 0
;PCODE: $000028A9 VOL: 0
;PCODE: $000028AA VOL: 0
;PCODE: $000028AB VOL: 0
;PCODE: $000028AC VOL: 0
;PCODE: $000028AD VOL: 0
;PCODE: $000028AE VOL: 0
;PCODE: $000028AF VOL: 0
;PCODE: $000028B0 VOL: 0
;PCODE: $000028B1 VOL: 0
;PCODE: $000028B2 VOL: 0
;PCODE: $000028B3 VOL: 0
;PCODE: $000028B4 VOL: 0
;PCODE: $000028B5 VOL: 0
;PCODE: $000028B6 VOL: 0
;PCODE: $000028B7 VOL: 0
;PCODE: $000028B8 VOL: 0
;PCODE: $000028B9 VOL: 0
;PCODE: $000028BA VOL: 0
;PCODE: $000028BB VOL: 0
;PCODE: $000028BC VOL: 0
;PCODE: $000028BD VOL: 0
;PCODE: $000028BE VOL: 0
;PCODE: $000028BF VOL: 0
;		while (j++ < w) putc_bfd(&pb, d);
;PCODE: $000028C0 VOL: 0
;PCODE: $000028C1 VOL: 0
;PCODE: $000028C2 VOL: 0
;PCODE: $000028C3 VOL: 0
;PCODE: $000028C4 VOL: 0
;PCODE: $000028C5 VOL: 0
;PCODE: $000028C6 VOL: 0
;PCODE: $000028C7 VOL: 0
;PCODE: $000028C8 VOL: 0
;PCODE: $000028C9 VOL: 0
;PCODE: $000028CA VOL: 0
;PCODE: $000028CB VOL: 0
;PCODE: $000028CC VOL: 0
;PCODE: $000028CD VOL: 0
;PCODE: $000028CE VOL: 0
;PCODE: $000028CF VOL: 0
;PCODE: $000028D0 VOL: 0
;PCODE: $000028D1 VOL: 0
;PCODE: $000028D2 VOL: 0
;
;	va_end(arp);
;
;	if (   pb.idx >= 0		/* Flush buffered characters to the file */
;		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
;		&& (UINT)pb.idx == nw) return pb.nchr;
;PCODE: $000028D3 VOL: 0
;PCODE: $000028D4 VOL: 0
;PCODE: $000028D5 VOL: 0
;PCODE: $000028D6 VOL: 0
;PCODE: $000028D7 VOL: 0
;PCODE: $000028D8 VOL: 0
;PCODE: $000028D9 VOL: 0
;PCODE: $000028DA VOL: 0
;PCODE: $000028DB VOL: 0
;PCODE: $000028DC VOL: 0
;PCODE: $000028DD VOL: 0
;PCODE: $000028DE VOL: 0
;PCODE: $000028DF VOL: 0
;PCODE: $000028E0 VOL: 0
;PCODE: $000028E1 VOL: 0
;PCODE: $000028E2 VOL: 0
;PCODE: $000028E3 VOL: 0
;PCODE: $000028E4 VOL: 0
;PCODE: $000028E5 VOL: 0
;PCODE: $000028E6 VOL: 0
;PCODE: $000028E7 VOL: 0
;PCODE: $000028E8 VOL: 0
;PCODE: $000028E9 VOL: 0
;PCODE: $000028EA VOL: 0
;PCODE: $000028EB VOL: 0
;PCODE: $000028EC VOL: 0
;PCODE: $000028ED VOL: 0
;PCODE: $000028EE VOL: 0
;PCODE: $000028EF VOL: 0
;	return EOF;
;PCODE: $000028F0 VOL: 0
;PCODE: $000028F1 VOL: 0
;PCODE: $000028F2 VOL: 0
;PCODE: $000028F3 VOL: 0
;PCODE: $000028F4 VOL: 0
;}
;PCODE: $000028F5 VOL: 0
;
;#endif /* !_FS_READONLY */
;#endif /* _USE_STRFUNC */
;#include "menu.h"
;//#include "dataflash/df.c"
;
;#define DS1307_ADR    104
;
;#define MAX_FN_STR    320
;
;#define CS_KEYS_SET  PORTC.0 = 1;
;#define CS_KEYS_RESET  PORTC.0 = 0;
;#define CLK_KEYS_SET  PORTC.2 = 1;
;#define CLK_KEYS_RESET  PORTC.2 = 0;
;#define KEYS_INIT   DDRC.0 = 1; DDRC.2 = 1; DDRD.7 = 0;
;
;///KEYBOARD KEYS
;#define FORWARD  247
;#define BACKWARD 251
;#define PAUSE    253
;#define PLAY     254
;
;#define PWM_PORT PORTB
;#define PWM_DIR DDRB
;#define PWM_PIN 3
;
;#define BUF_SIZE 256
;#define HALF_BUF ((BUF_SIZE)/2)
;
;struct CFileInfo
;{
;unsigned char * szFileName;
;int nFileDate;
;int nFileSize;
;}g_FileInfo[32];
;
; DWORD get_fattime ()
;{
;PCODE: $000028F6 VOL: 0
;PCODE: $000028F7 VOL: 0
;    /* Pack date and time into a DWORD variable */
;   return    ((DWORD)(/*rtc.year*/2010 - 1980) << 25)
;         | ((DWORD)/*rtc.month*/10 << 21)
;         | ((DWORD)/*rtc.mday*/7 << 16)
;          | ((DWORD)/*rtc.hour*/1 << 11)
;          | ((DWORD)/*rtc.min*/26 << 5)
;          | ((DWORD)/*rtc.sec*/6 >> 1);
;PCODE: $000028F8 VOL: 0
;PCODE: $000028F9 VOL: 0
;}
;PCODE: $000028FA VOL: 0
;
;//******************************************************************************
;// Функции браузера плеера
;//******************************************************************************
;FIL file;
;FIL simple_file;
;    BYTE bIsfOpened = 0;
;    unsigned char fn16_str[13];    // ТОЛЬКО ДЛЯ ФОРМАТА 8.3 !!!
;    unsigned char rootpath[32];
;    unsigned char tempstr[32];
;    unsigned char audiobuf[64];
;    int select_file_index = 0;
;    int select_file_option_index = 0;
;    unsigned int nNofDirFiles = 0;
;    int nKey;
;    int nAudioBufferIndex = 0;
;    BYTE bSelect = 0;
;    BYTE bFileInfoWindow = 0;
;    BYTE bFormatAlert = 0;
;    BYTE bTextReader = 0;
;    BYTE bMusicPlayer = 0;
;    BYTE bImageViever = 0;
;    int scroll_index = 0;
;    UINT state = 0;
;    BYTE bMusicFOpened = 0;
;
;enum FILE_OPTION_MENU {OPEN=0,DELETE,INFO}fOption;
;
;BYTE GetKeysStatus()      //функция чтения данных   74HC165
;{
;PCODE: $000028FB VOL: 0
;PCODE: $000028FC VOL: 0
;  unsigned int i=0;
;  BYTE keydata;
;
;     CS_KEYS_RESET;         //защёлкиваем входные данные
;PCODE: $000028FD VOL: 0
;	i -> R16,R17
;	keydata -> R19
;PCODE: $000028FE VOL: 0
;PCODE: $000028FF VOL: 0
;PCODE: $00002900 VOL: 0
;PCODE: $00002901 VOL: 0
;     //delay_us(1);
;     CS_KEYS_SET;
;PCODE: $00002902 VOL: 0
;PCODE: $00002903 VOL: 0
;      CLK_KEYS_SET;
;PCODE: $00002904 VOL: 0
;PCODE: $00002905 VOL: 0
;
;   for( i=0; i<7; i++ )
;PCODE: $00002906 VOL: 0
;PCODE: $00002907 VOL: 0
;PCODE: $00002908 VOL: 0
;PCODE: $00002909 VOL: 0
;PCODE: $0000290A VOL: 0
;PCODE: $0000290B VOL: 0
;PCODE: $0000290C VOL: 0
;PCODE: $0000290D VOL: 0
;PCODE: $0000290E VOL: 0
;   {
;     keydata |= PIND.7;
;PCODE: $0000290F VOL: 0
;PCODE: $00002910 VOL: 0
;PCODE: $00002911 VOL: 0
;PCODE: $00002912 VOL: 0
;     keydata <<= 1;
;PCODE: $00002913 VOL: 0
;      CLK_KEYS_RESET;            //сдвигаем данные
;PCODE: $00002914 VOL: 0
;PCODE: $00002915 VOL: 0
;      //delay_us(1);
;      CLK_KEYS_SET;
;PCODE: $00002916 VOL: 0
;PCODE: $00002917 VOL: 0
;   }
;PCODE: $00002918 VOL: 0
;PCODE: $00002919 VOL: 0
;PCODE: $0000291A VOL: 0
;PCODE: $0000291B VOL: 0
;PCODE: $0000291C VOL: 0
;  keydata |= PIND.7;
;PCODE: $0000291D VOL: 0
;PCODE: $0000291E VOL: 0
;PCODE: $0000291F VOL: 0
;PCODE: $00002920 VOL: 0
;   return keydata;
;PCODE: $00002921 VOL: 0
;PCODE: $00002922 VOL: 0
;PCODE: $00002923 VOL: 0
;PCODE: $00002924 VOL: 0
;}
;PCODE: $00002925 VOL: 0
;
;ISR(TIM0_OVF)
;{
;PCODE: $00002926 VOL: 0
;PCODE: $00002927 VOL: 0
;  OCR0A = audiobuf[nAudioBufferIndex];
;PCODE: $00002928 VOL: 0
;PCODE: $00002929 VOL: 0
;PCODE: $0000292A VOL: 0
;PCODE: $0000292B VOL: 0
;  nAudioBufferIndex++;
;PCODE: $0000292C VOL: 0
;PCODE: $0000292D VOL: 0
;PCODE: $0000292E VOL: 0
;}
;PCODE: $0000292F VOL: 0
;PCODE: $00002930 VOL: 0
;PCODE: $00002931 VOL: 0
;
;ISR(EXT_INT0)
;{
;PCODE: $00002932 VOL: 0
;PCODE: $00002933 VOL: 0
;delay_ms(100);
;PCODE: $00002934 VOL: 0
;PCODE: $00002935 VOL: 0
;PCODE: $00002936 VOL: 0
;nKey = GetKeysStatus();
;PCODE: $00002937 VOL: 0
;PCODE: $00002938 VOL: 0
;PCODE: $00002939 VOL: 0
;}
;PCODE: $0000293A VOL: 0
;PCODE: $0000293B VOL: 0
;PCODE: $0000293C VOL: 0
;
;
;FRESULT browser_scan_files (char* path) // Scan Files in the root directory
;{
;PCODE: $0000293D VOL: 0
;PCODE: $0000293E VOL: 0
;    FRESULT res;
;    FILINFO fno;
;    DIR dir;
;    unsigned char * szFileMenuList[3] = {"Open","Delete","Info"};
;    int pos_index = 0;
;    int i = 0,nf_index = 0;
;    int j = 0;
;    int tempselindex = 0;
;    nlcd_Clear(WHITE);
;PCODE: $0000293F VOL: 0
;PCODE: $00002940 VOL: 0
;PCODE: $00002941 VOL: 0
;PCODE: $00002942 VOL: 0
;PCODE: $00002943 VOL: 0
;PCODE: $00002944 VOL: 0
;PCODE: $00002945 VOL: 0
;	*path -> Y+62
;	res -> R17
;	fno -> Y+40
;	dir -> Y+18
;	szFileMenuList -> Y+12
;	pos_index -> R18,R19
;	i -> R20,R21
;	nf_index -> Y+10
;	j -> Y+8
;	tempselindex -> Y+6
;PCODE: $00002946 VOL: 0
;PCODE: $00002947 VOL: 0
;PCODE: $00002948 VOL: 0
;PCODE: $00002949 VOL: 0
;PCODE: $0000294A VOL: 0
;PCODE: $0000294B VOL: 0
;    if(!bIsfOpened)
;PCODE: $0000294C VOL: 0
;PCODE: $0000294D VOL: 0
;    {
;    res = f_opendir(&dir, path);
;PCODE: $0000294E VOL: 0
;PCODE: $0000294F VOL: 0
;PCODE: $00002950 VOL: 0
;PCODE: $00002951 VOL: 0
;PCODE: $00002952 VOL: 0
;    }
;    if (res == FR_OK)
;PCODE: $00002953 VOL: 0
;PCODE: $00002954 VOL: 0
;PCODE: $00002955 VOL: 0
;    {
;    if(!bIsfOpened)
;PCODE: $00002956 VOL: 0
;PCODE: $00002957 VOL: 0
;    {
;    f_open(&file, "0:LOG/SPISOKF.txt", FA_OPEN_ALWAYS  | FA_WRITE);
;PCODE: $00002958 VOL: 0
;PCODE: $00002959 VOL: 0
;PCODE: $0000295A VOL: 0
;PCODE: $0000295B VOL: 0
;PCODE: $0000295C VOL: 0
;PCODE: $0000295D VOL: 0
;PCODE: $0000295E VOL: 0
;    f_lseek(&file,0);
;PCODE: $0000295F VOL: 0
;PCODE: $00002960 VOL: 0
;PCODE: $00002961 VOL: 0
;PCODE: $00002962 VOL: 0
;    f_puts("Это список текущих файлов, просто лог, менять и удалять смысла нет\n\n",&file);
;PCODE: $00002963 VOL: 0
;PCODE: $00002964 VOL: 0
;PCODE: $00002965 VOL: 0
;PCODE: $00002966 VOL: 0
;PCODE: $00002967 VOL: 0
;    select_file_index = 0;
;PCODE: $00002968 VOL: 0
;    }
;       for (nf_index = 0;;nf_index++) {
;PCODE: $00002969 VOL: 0
;PCODE: $0000296A VOL: 0
;PCODE: $0000296B VOL: 0
;PCODE: $0000296C VOL: 0
;PCODE: $0000296D VOL: 0
;PCODE: $0000296E VOL: 0
;PCODE: $0000296F VOL: 0
;PCODE: $00002970 VOL: 0
;            if(!bIsfOpened)
;PCODE: $00002971 VOL: 0
;PCODE: $00002972 VOL: 0
;            {
;            res = f_readdir(&dir, &fno);
;PCODE: $00002973 VOL: 0
;PCODE: $00002974 VOL: 0
;PCODE: $00002975 VOL: 0
;PCODE: $00002976 VOL: 0
;PCODE: $00002977 VOL: 0
;            if (res != FR_OK || fno.fname[0] == 0) break;
;PCODE: $00002978 VOL: 0
;PCODE: $00002979 VOL: 0
;PCODE: $0000297A VOL: 0
;PCODE: $0000297B VOL: 0
;PCODE: $0000297C VOL: 0
;PCODE: $0000297D VOL: 0
;PCODE: $0000297E VOL: 0
;PCODE: $0000297F VOL: 0
;            g_FileInfo[nf_index].szFileName = (unsigned char*)malloc(strlen(fno.fname)+1);
;PCODE: $00002980 VOL: 0
;PCODE: $00002981 VOL: 0
;PCODE: $00002982 VOL: 0
;PCODE: $00002983 VOL: 0
;PCODE: $00002984 VOL: 0
;PCODE: $00002985 VOL: 0
;PCODE: $00002986 VOL: 0
;PCODE: $00002987 VOL: 0
;PCODE: $00002988 VOL: 0
;PCODE: $00002989 VOL: 0
;PCODE: $0000298A VOL: 0
;PCODE: $0000298B VOL: 0
;PCODE: $0000298C VOL: 0
;            sprintf(g_FileInfo[nf_index].szFileName,"%s", fno.fname);
;PCODE: $0000298D VOL: 0
;PCODE: $0000298E VOL: 0
;PCODE: $0000298F VOL: 0
;PCODE: $00002990 VOL: 0
;PCODE: $00002991 VOL: 0
;PCODE: $00002992 VOL: 0
;PCODE: $00002993 VOL: 0
;PCODE: $00002994 VOL: 0
;PCODE: $00002995 VOL: 0
;PCODE: $00002996 VOL: 0
;PCODE: $00002997 VOL: 0
;PCODE: $00002998 VOL: 0
;PCODE: $00002999 VOL: 0
;PCODE: $0000299A VOL: 0
;PCODE: $0000299B VOL: 0
;PCODE: $0000299C VOL: 0
;PCODE: $0000299D VOL: 0
;            g_FileInfo[nf_index].nFileSize = fno.fsize;
;PCODE: $0000299E VOL: 0
;PCODE: $0000299F VOL: 0
;PCODE: $000029A0 VOL: 0
;PCODE: $000029A1 VOL: 0
;PCODE: $000029A2 VOL: 0
;PCODE: $000029A3 VOL: 0
;PCODE: $000029A4 VOL: 0
;            g_FileInfo[nf_index].nFileDate = fno.fdate;
;PCODE: $000029A5 VOL: 0
;PCODE: $000029A6 VOL: 0
;PCODE: $000029A7 VOL: 0
;PCODE: $000029A8 VOL: 0
;PCODE: $000029A9 VOL: 0
;PCODE: $000029AA VOL: 0
;PCODE: $000029AB VOL: 0
;            strcpy(fn16_str,fno.fname);
;PCODE: $000029AC VOL: 0
;PCODE: $000029AD VOL: 0
;PCODE: $000029AE VOL: 0
;PCODE: $000029AF VOL: 0
;            strcat(fn16_str,"\n");
;PCODE: $000029B0 VOL: 0
;PCODE: $000029B1 VOL: 0
;PCODE: $000029B2 VOL: 0
;PCODE: $000029B3 VOL: 0
;PCODE: $000029B4 VOL: 0
;            f_puts(fn16_str,&file);
;PCODE: $000029B5 VOL: 0
;PCODE: $000029B6 VOL: 0
;PCODE: $000029B7 VOL: 0
;PCODE: $000029B8 VOL: 0
;            nNofDirFiles = nf_index+1;
;PCODE: $000029B9 VOL: 0
;PCODE: $000029BA VOL: 0
;PCODE: $000029BB VOL: 0
;            }
;            if(g_FileInfo[nf_index].szFileName[0] == 0)break;
;PCODE: $000029BC VOL: 0
;PCODE: $000029BD VOL: 0
;PCODE: $000029BE VOL: 0
;PCODE: $000029BF VOL: 0
;PCODE: $000029C0 VOL: 0
;PCODE: $000029C1 VOL: 0
;PCODE: $000029C2 VOL: 0
;PCODE: $000029C3 VOL: 0
;PCODE: $000029C4 VOL: 0
;PCODE: $000029C5 VOL: 0
;PCODE: $000029C6 VOL: 0
;            if((select_file_index+1 > nNofDirFiles) && (select_file_index+1 > 0))select_file_index = 0;
;PCODE: $000029C7 VOL: 0
;PCODE: $000029C8 VOL: 0
;PCODE: $000029C9 VOL: 0
;PCODE: $000029CA VOL: 0
;PCODE: $000029CB VOL: 0
;PCODE: $000029CC VOL: 0
;PCODE: $000029CD VOL: 0
;PCODE: $000029CE VOL: 0
;PCODE: $000029CF VOL: 0
;PCODE: $000029D0 VOL: 0
;PCODE: $000029D1 VOL: 0
;PCODE: $000029D2 VOL: 0
;PCODE: $000029D3 VOL: 0
;PCODE: $000029D4 VOL: 0
;            if(select_file_index+1 <= 0)select_file_index = nNofDirFiles-1;
;PCODE: $000029D5 VOL: 0
;PCODE: $000029D6 VOL: 0
;PCODE: $000029D7 VOL: 0
;PCODE: $000029D8 VOL: 0
;PCODE: $000029D9 VOL: 0
;PCODE: $000029DA VOL: 0
;PCODE: $000029DB VOL: 0
;PCODE: $000029DC VOL: 0
;                if(nf_index == select_file_index)
;PCODE: $000029DD VOL: 0
;PCODE: $000029DE VOL: 0
;PCODE: $000029DF VOL: 0
;PCODE: $000029E0 VOL: 0
;                {
;                nlcd_Box(0,29+i,132,34+i,1,GREEN,0);
;PCODE: $000029E1 VOL: 0
;PCODE: $000029E2 VOL: 0
;PCODE: $000029E3 VOL: 0
;PCODE: $000029E4 VOL: 0
;PCODE: $000029E5 VOL: 0
;PCODE: $000029E6 VOL: 0
;PCODE: $000029E7 VOL: 0
;PCODE: $000029E8 VOL: 0
;PCODE: $000029E9 VOL: 0
;PCODE: $000029EA VOL: 0
;PCODE: $000029EB VOL: 0
;PCODE: $000029EC VOL: 0
;PCODE: $000029ED VOL: 0
;PCODE: $000029EE VOL: 0
;PCODE: $000029EF VOL: 0
;PCODE: $000029F0 VOL: 0
;PCODE: $000029F1 VOL: 0
;                nlcd_String(g_FileInfo[nf_index].szFileName,30+i,10,WHITE,GREEN);
;PCODE: $000029F2 VOL: 0
;PCODE: $000029F3 VOL: 0
;PCODE: $000029F4 VOL: 0
;PCODE: $000029F5 VOL: 0
;PCODE: $000029F6 VOL: 0
;PCODE: $000029F7 VOL: 0
;PCODE: $000029F8 VOL: 0
;PCODE: $000029F9 VOL: 0
;PCODE: $000029FA VOL: 0
;PCODE: $000029FB VOL: 0
;PCODE: $000029FC VOL: 0
;PCODE: $000029FD VOL: 0
;PCODE: $000029FE VOL: 0
;PCODE: $000029FF VOL: 0
;PCODE: $00002A00 VOL: 0
;PCODE: $00002A01 VOL: 0
;PCODE: $00002A02 VOL: 0
;                pos_index = i;
;PCODE: $00002A03 VOL: 0
;PCODE: $00002A04 VOL: 0
;                }
;                else
;PCODE: $00002A05 VOL: 0
;PCODE: $00002A06 VOL: 0
;                {
;                nlcd_String(g_FileInfo[nf_index].szFileName,30+i,10,BLACK,WHITE);
;PCODE: $00002A07 VOL: 0
;PCODE: $00002A08 VOL: 0
;PCODE: $00002A09 VOL: 0
;PCODE: $00002A0A VOL: 0
;PCODE: $00002A0B VOL: 0
;PCODE: $00002A0C VOL: 0
;PCODE: $00002A0D VOL: 0
;PCODE: $00002A0E VOL: 0
;PCODE: $00002A0F VOL: 0
;PCODE: $00002A10 VOL: 0
;PCODE: $00002A11 VOL: 0
;PCODE: $00002A12 VOL: 0
;PCODE: $00002A13 VOL: 0
;PCODE: $00002A14 VOL: 0
;PCODE: $00002A15 VOL: 0
;PCODE: $00002A16 VOL: 0
;                }
;PCODE: $00002A17 VOL: 0
;            i+=10;
;PCODE: $00002A18 VOL: 0
;PCODE: $00002A19 VOL: 0
;        }
;PCODE: $00002A1A VOL: 0
;PCODE: $00002A1B VOL: 0
;PCODE: $00002A1C VOL: 0
;PCODE: $00002A1D VOL: 0
;PCODE: $00002A1E VOL: 0
;PCODE: $00002A1F VOL: 0
;        if(bSelect)
;PCODE: $00002A20 VOL: 0
;PCODE: $00002A21 VOL: 0
;        {
;        nlcd_Box(10,32+pos_index,58,90+pos_index,2,WHITE,GREEN);
;PCODE: $00002A22 VOL: 0
;PCODE: $00002A23 VOL: 0
;PCODE: $00002A24 VOL: 0
;PCODE: $00002A25 VOL: 0
;PCODE: $00002A26 VOL: 0
;PCODE: $00002A27 VOL: 0
;PCODE: $00002A28 VOL: 0
;PCODE: $00002A29 VOL: 0
;PCODE: $00002A2A VOL: 0
;PCODE: $00002A2B VOL: 0
;PCODE: $00002A2C VOL: 0
;PCODE: $00002A2D VOL: 0
;PCODE: $00002A2E VOL: 0
;PCODE: $00002A2F VOL: 0
;PCODE: $00002A30 VOL: 0
;PCODE: $00002A31 VOL: 0
;PCODE: $00002A32 VOL: 0
;        for(i = 0;i<3;i++)
;PCODE: $00002A33 VOL: 0
;PCODE: $00002A34 VOL: 0
;PCODE: $00002A35 VOL: 0
;PCODE: $00002A36 VOL: 0
;PCODE: $00002A37 VOL: 0
;PCODE: $00002A38 VOL: 0
;PCODE: $00002A39 VOL: 0
;PCODE: $00002A3A VOL: 0
;PCODE: $00002A3B VOL: 0
;        {
;        if(select_file_option_index > 2) select_file_option_index = 0;
;PCODE: $00002A3C VOL: 0
;PCODE: $00002A3D VOL: 0
;PCODE: $00002A3E VOL: 0
;PCODE: $00002A3F VOL: 0
;        if(select_file_option_index < 0) select_file_option_index = 2;
;PCODE: $00002A40 VOL: 0
;PCODE: $00002A41 VOL: 0
;PCODE: $00002A42 VOL: 0
;PCODE: $00002A43 VOL: 0
;PCODE: $00002A44 VOL: 0
;        if(i == select_file_option_index)
;PCODE: $00002A45 VOL: 0
;PCODE: $00002A46 VOL: 0
;PCODE: $00002A47 VOL: 0
;PCODE: $00002A48 VOL: 0
;        {
;        nlcd_String(szFileMenuList[i],36+j+pos_index,25,WHITE,GREEN);
;PCODE: $00002A49 VOL: 0
;PCODE: $00002A4A VOL: 0
;PCODE: $00002A4B VOL: 0
;PCODE: $00002A4C VOL: 0
;PCODE: $00002A4D VOL: 0
;PCODE: $00002A4E VOL: 0
;PCODE: $00002A4F VOL: 0
;PCODE: $00002A50 VOL: 0
;PCODE: $00002A51 VOL: 0
;PCODE: $00002A52 VOL: 0
;PCODE: $00002A53 VOL: 0
;PCODE: $00002A54 VOL: 0
;PCODE: $00002A55 VOL: 0
;PCODE: $00002A56 VOL: 0
;PCODE: $00002A57 VOL: 0
;PCODE: $00002A58 VOL: 0
;PCODE: $00002A59 VOL: 0
;        }
;        else
;PCODE: $00002A5A VOL: 0
;PCODE: $00002A5B VOL: 0
;        {
;        nlcd_String(szFileMenuList[i],36+j+pos_index,25,BLACK,WHITE);
;PCODE: $00002A5C VOL: 0
;PCODE: $00002A5D VOL: 0
;PCODE: $00002A5E VOL: 0
;PCODE: $00002A5F VOL: 0
;PCODE: $00002A60 VOL: 0
;PCODE: $00002A61 VOL: 0
;PCODE: $00002A62 VOL: 0
;PCODE: $00002A63 VOL: 0
;PCODE: $00002A64 VOL: 0
;PCODE: $00002A65 VOL: 0
;PCODE: $00002A66 VOL: 0
;PCODE: $00002A67 VOL: 0
;PCODE: $00002A68 VOL: 0
;PCODE: $00002A69 VOL: 0
;PCODE: $00002A6A VOL: 0
;PCODE: $00002A6B VOL: 0
;        }
;PCODE: $00002A6C VOL: 0
;        j+=10;
;PCODE: $00002A6D VOL: 0
;PCODE: $00002A6E VOL: 0
;PCODE: $00002A6F VOL: 0
;        }
;PCODE: $00002A70 VOL: 0
;PCODE: $00002A71 VOL: 0
;PCODE: $00002A72 VOL: 0
;PCODE: $00002A73 VOL: 0
;PCODE: $00002A74 VOL: 0
;        }
;        if(!bIsfOpened)
;PCODE: $00002A75 VOL: 0
;PCODE: $00002A76 VOL: 0
;PCODE: $00002A77 VOL: 0
;        f_close(&file);
;PCODE: $00002A78 VOL: 0
;PCODE: $00002A79 VOL: 0
;    }
;PCODE: $00002A7A VOL: 0
;    if((path[0] == '') || (path[0] == ' '))
;PCODE: $00002A7B VOL: 0
;PCODE: $00002A7C VOL: 0
;PCODE: $00002A7D VOL: 0
;PCODE: $00002A7E VOL: 0
;PCODE: $00002A7F VOL: 0
;PCODE: $00002A80 VOL: 0
;PCODE: $00002A81 VOL: 0
;PCODE: $00002A82 VOL: 0
;PCODE: $00002A83 VOL: 0
;PCODE: $00002A84 VOL: 0
;PCODE: $00002A85 VOL: 0
;    {
;    nlcd_String("Root",18,5,BLACK,WHITE);
;PCODE: $00002A86 VOL: 0
;PCODE: $00002A87 VOL: 0
;PCODE: $00002A88 VOL: 0
;PCODE: $00002A89 VOL: 0
;PCODE: $00002A8A VOL: 0
;PCODE: $00002A8B VOL: 0
;PCODE: $00002A8C VOL: 0
;PCODE: $00002A8D VOL: 0
;PCODE: $00002A8E VOL: 0
;PCODE: $00002A8F VOL: 0
;PCODE: $00002A90 VOL: 0
;    }
;    else
;PCODE: $00002A91 VOL: 0
;PCODE: $00002A92 VOL: 0
;    {
;    sprintf(&rootpath[0],"Root/%s", &path[0]);
;PCODE: $00002A93 VOL: 0
;PCODE: $00002A94 VOL: 0
;PCODE: $00002A95 VOL: 0
;PCODE: $00002A96 VOL: 0
;PCODE: $00002A97 VOL: 0
;PCODE: $00002A98 VOL: 0
;PCODE: $00002A99 VOL: 0
;PCODE: $00002A9A VOL: 0
;PCODE: $00002A9B VOL: 0
;PCODE: $00002A9C VOL: 0
;PCODE: $00002A9D VOL: 0
;PCODE: $00002A9E VOL: 0
;    nlcd_String(&rootpath[0],18,5,BLACK,WHITE);
;PCODE: $00002A9F VOL: 0
;PCODE: $00002AA0 VOL: 0
;PCODE: $00002AA1 VOL: 0
;PCODE: $00002AA2 VOL: 0
;PCODE: $00002AA3 VOL: 0
;PCODE: $00002AA4 VOL: 0
;PCODE: $00002AA5 VOL: 0
;PCODE: $00002AA6 VOL: 0
;PCODE: $00002AA7 VOL: 0
;PCODE: $00002AA8 VOL: 0
;    }
;PCODE: $00002AA9 VOL: 0
;    return res;
;PCODE: $00002AAA VOL: 0
;PCODE: $00002AAB VOL: 0
;PCODE: $00002AAC VOL: 0
;PCODE: $00002AAD VOL: 0
;}
;PCODE: $00002AAE VOL: 0

	.DSEG
_0x455:
	.BYTE 0x6F
;
;
;void fileinfo_window(int nFileInfoIndex)
;{

	.CSEG
;PCODE: $00002AAF VOL: 0
;PCODE: $00002AB0 VOL: 0
;unsigned char szfinfo[10];
;nlcd_Clear(WHITE);
;PCODE: $00002AB1 VOL: 0
;PCODE: $00002AB2 VOL: 0
;	nFileInfoIndex -> Y+10
;	szfinfo -> Y+0
;PCODE: $00002AB3 VOL: 0
;PCODE: $00002AB4 VOL: 0
;nlcd_String("***File Info***",5,5,RED,WHITE);
;PCODE: $00002AB5 VOL: 0
;PCODE: $00002AB6 VOL: 0
;PCODE: $00002AB7 VOL: 0
;PCODE: $00002AB8 VOL: 0
;PCODE: $00002AB9 VOL: 0
;PCODE: $00002ABA VOL: 0
;PCODE: $00002ABB VOL: 0
;PCODE: $00002ABC VOL: 0
;PCODE: $00002ABD VOL: 0
;PCODE: $00002ABE VOL: 0
;PCODE: $00002ABF VOL: 0
;nlcd_String(g_FileInfo[nFileInfoIndex].szFileName,15,10,BLUE,WHITE);
;PCODE: $00002AC0 VOL: 0
;PCODE: $00002AC1 VOL: 0
;PCODE: $00002AC2 VOL: 0
;PCODE: $00002AC3 VOL: 0
;PCODE: $00002AC4 VOL: 0
;PCODE: $00002AC5 VOL: 0
;PCODE: $00002AC6 VOL: 0
;PCODE: $00002AC7 VOL: 0
;PCODE: $00002AC8 VOL: 0
;PCODE: $00002AC9 VOL: 0
;PCODE: $00002ACA VOL: 0
;PCODE: $00002ACB VOL: 0
;PCODE: $00002ACC VOL: 0
;PCODE: $00002ACD VOL: 0
;PCODE: $00002ACE VOL: 0
;nlcd_String("File Size",25,20,GREEN,WHITE);
;PCODE: $00002ACF VOL: 0
;PCODE: $00002AD0 VOL: 0
;PCODE: $00002AD1 VOL: 0
;PCODE: $00002AD2 VOL: 0
;PCODE: $00002AD3 VOL: 0
;PCODE: $00002AD4 VOL: 0
;PCODE: $00002AD5 VOL: 0
;PCODE: $00002AD6 VOL: 0
;PCODE: $00002AD7 VOL: 0
;PCODE: $00002AD8 VOL: 0
;PCODE: $00002AD9 VOL: 0
;sprintf(&szfinfo[0],"%i B", g_FileInfo[nFileInfoIndex].nFileSize);
;PCODE: $00002ADA VOL: 0
;PCODE: $00002ADB VOL: 0
;PCODE: $00002ADC VOL: 0
;PCODE: $00002ADD VOL: 0
;PCODE: $00002ADE VOL: 0
;PCODE: $00002ADF VOL: 0
;PCODE: $00002AE0 VOL: 0
;PCODE: $00002AE1 VOL: 0
;PCODE: $00002AE2 VOL: 0
;PCODE: $00002AE3 VOL: 0
;PCODE: $00002AE4 VOL: 0
;PCODE: $00002AE5 VOL: 0
;PCODE: $00002AE6 VOL: 0
;PCODE: $00002AE7 VOL: 0
;PCODE: $00002AE8 VOL: 0
;PCODE: $00002AE9 VOL: 0
;PCODE: $00002AEA VOL: 0
;PCODE: $00002AEB VOL: 0
;nlcd_String(szfinfo,35,20,BLACK,WHITE);
;PCODE: $00002AEC VOL: 0
;PCODE: $00002AED VOL: 0
;PCODE: $00002AEE VOL: 0
;PCODE: $00002AEF VOL: 0
;PCODE: $00002AF0 VOL: 0
;PCODE: $00002AF1 VOL: 0
;PCODE: $00002AF2 VOL: 0
;PCODE: $00002AF3 VOL: 0
;PCODE: $00002AF4 VOL: 0
;PCODE: $00002AF5 VOL: 0
;nlcd_String("Changing Date",45,20,GREEN,WHITE);
;PCODE: $00002AF6 VOL: 0
;PCODE: $00002AF7 VOL: 0
;PCODE: $00002AF8 VOL: 0
;PCODE: $00002AF9 VOL: 0
;PCODE: $00002AFA VOL: 0
;PCODE: $00002AFB VOL: 0
;PCODE: $00002AFC VOL: 0
;PCODE: $00002AFD VOL: 0
;PCODE: $00002AFE VOL: 0
;PCODE: $00002AFF VOL: 0
;PCODE: $00002B00 VOL: 0
;sprintf(&szfinfo[0],"%i", g_FileInfo[nFileInfoIndex].nFileDate);
;PCODE: $00002B01 VOL: 0
;PCODE: $00002B02 VOL: 0
;PCODE: $00002B03 VOL: 0
;PCODE: $00002B04 VOL: 0
;PCODE: $00002B05 VOL: 0
;PCODE: $00002B06 VOL: 0
;PCODE: $00002B07 VOL: 0
;PCODE: $00002B08 VOL: 0
;PCODE: $00002B09 VOL: 0
;PCODE: $00002B0A VOL: 0
;PCODE: $00002B0B VOL: 0
;PCODE: $00002B0C VOL: 0
;PCODE: $00002B0D VOL: 0
;PCODE: $00002B0E VOL: 0
;PCODE: $00002B0F VOL: 0
;PCODE: $00002B10 VOL: 0
;PCODE: $00002B11 VOL: 0
;PCODE: $00002B12 VOL: 0
;nlcd_String(szfinfo,55,20,BLACK,WHITE);
;PCODE: $00002B13 VOL: 0
;PCODE: $00002B14 VOL: 0
;PCODE: $00002B15 VOL: 0
;PCODE: $00002B16 VOL: 0
;PCODE: $00002B17 VOL: 0
;PCODE: $00002B18 VOL: 0
;PCODE: $00002B19 VOL: 0
;PCODE: $00002B1A VOL: 0
;PCODE: $00002B1B VOL: 0
;PCODE: $00002B1C VOL: 0
;}
;PCODE: $00002B1D VOL: 0
;PCODE: $00002B1E VOL: 0
;PCODE: $00002B1F VOL: 0

	.DSEG
_0x475:
	.BYTE 0x28
;
;unsigned char error[10];
;void browser_init()
;{

	.CSEG
;PCODE: $00002B20 VOL: 0
;PCODE: $00002B21 VOL: 0
;FRESULT res;
;FATFS fs;
;UINT br, bw,i;
;if(!f_mount(&fs,"0",1))
;PCODE: $00002B22 VOL: 0
;PCODE: $00002B23 VOL: 0
;	res -> R17
;	fs -> Y+8
;	br -> R18,R19
;	bw -> R20,R21
;	i -> Y+6
;PCODE: $00002B24 VOL: 0
;PCODE: $00002B25 VOL: 0
;PCODE: $00002B26 VOL: 0
;PCODE: $00002B27 VOL: 0
;PCODE: $00002B28 VOL: 0
;PCODE: $00002B29 VOL: 0
;PCODE: $00002B2A VOL: 0
;PCODE: $00002B2B VOL: 0
;PCODE: $00002B2C VOL: 0
;{
;//PORTD.0 = 1;
;if(bFileInfoWindow && !bTextReader && !bMusicPlayer)
;PCODE: $00002B2D VOL: 0
;PCODE: $00002B2E VOL: 0
;PCODE: $00002B2F VOL: 0
;PCODE: $00002B30 VOL: 0
;PCODE: $00002B31 VOL: 0
;PCODE: $00002B32 VOL: 0
;PCODE: $00002B33 VOL: 0
;PCODE: $00002B34 VOL: 0
;PCODE: $00002B35 VOL: 0
;PCODE: $00002B36 VOL: 0
;PCODE: $00002B37 VOL: 0
;PCODE: $00002B38 VOL: 0
;PCODE: $00002B39 VOL: 0
;{
;fileinfo_window(select_file_index);
;PCODE: $00002B3A VOL: 0
;PCODE: $00002B3B VOL: 0
;}
;if(!bFileInfoWindow && !bTextReader && bMusicPlayer)
;PCODE: $00002B3C VOL: 0
;PCODE: $00002B3D VOL: 0
;PCODE: $00002B3E VOL: 0
;PCODE: $00002B3F VOL: 0
;PCODE: $00002B40 VOL: 0
;PCODE: $00002B41 VOL: 0
;PCODE: $00002B42 VOL: 0
;PCODE: $00002B43 VOL: 0
;PCODE: $00002B44 VOL: 0
;PCODE: $00002B45 VOL: 0
;PCODE: $00002B46 VOL: 0
;PCODE: $00002B47 VOL: 0
;PCODE: $00002B48 VOL: 0
;PCODE: $00002B49 VOL: 0
;{
;music_player_init(select_file_index);
;PCODE: $00002B4A VOL: 0
;PCODE: $00002B4B VOL: 0
;}
;if(!bFileInfoWindow && bTextReader)
;PCODE: $00002B4C VOL: 0
;PCODE: $00002B4D VOL: 0
;PCODE: $00002B4E VOL: 0
;PCODE: $00002B4F VOL: 0
;PCODE: $00002B50 VOL: 0
;PCODE: $00002B51 VOL: 0
;PCODE: $00002B52 VOL: 0
;PCODE: $00002B53 VOL: 0
;PCODE: $00002B54 VOL: 0
;PCODE: $00002B55 VOL: 0
;PCODE: $00002B56 VOL: 0
;{
;text_reader_init(select_file_index);
;PCODE: $00002B57 VOL: 0
;PCODE: $00002B58 VOL: 0
;}
;else
;PCODE: $00002B59 VOL: 0
;PCODE: $00002B5A VOL: 0
;{
;bMusicFOpened = 0;
;PCODE: $00002B5B VOL: 0
;PCODE: $00002B5C VOL: 0
;browser_scan_files("");
;PCODE: $00002B5D VOL: 0
;PCODE: $00002B5E VOL: 0
;PCODE: $00002B5F VOL: 0
;}
;PCODE: $00002B60 VOL: 0
;switch(nKey)
;PCODE: $00002B61 VOL: 0
;{
;case FORWARD:
;PCODE: $00002B62 VOL: 0
;PCODE: $00002B63 VOL: 0
;if(bTextReader)
;PCODE: $00002B64 VOL: 0
;PCODE: $00002B65 VOL: 0
;PCODE: $00002B66 VOL: 0
;scroll_index+=16;
;PCODE: $00002B67 VOL: 0
;PCODE: $00002B68 VOL: 0
;PCODE: $00002B69 VOL: 0
;if(bSelect)
;PCODE: $00002B6A VOL: 0
;PCODE: $00002B6B VOL: 0
;PCODE: $00002B6C VOL: 0
;select_file_option_index++;
;PCODE: $00002B6D VOL: 0
;PCODE: $00002B6E VOL: 0
;PCODE: $00002B6F VOL: 0
;else
;PCODE: $00002B70 VOL: 0
;PCODE: $00002B71 VOL: 0
;select_file_index++;
;PCODE: $00002B72 VOL: 0
;PCODE: $00002B73 VOL: 0
;PCODE: $00002B74 VOL: 0
;break;
;PCODE: $00002B75 VOL: 0
;PCODE: $00002B76 VOL: 0
;case BACKWARD:
;PCODE: $00002B77 VOL: 0
;PCODE: $00002B78 VOL: 0
;PCODE: $00002B79 VOL: 0
;if(bTextReader)
;PCODE: $00002B7A VOL: 0
;PCODE: $00002B7B VOL: 0
;PCODE: $00002B7C VOL: 0
;scroll_index-=16;
;PCODE: $00002B7D VOL: 0
;PCODE: $00002B7E VOL: 0
;PCODE: $00002B7F VOL: 0
;if(bSelect)
;PCODE: $00002B80 VOL: 0
;PCODE: $00002B81 VOL: 0
;PCODE: $00002B82 VOL: 0
;select_file_option_index--;
;PCODE: $00002B83 VOL: 0
;PCODE: $00002B84 VOL: 0
;PCODE: $00002B85 VOL: 0
;else
;PCODE: $00002B86 VOL: 0
;PCODE: $00002B87 VOL: 0
;select_file_index--;
;PCODE: $00002B88 VOL: 0
;PCODE: $00002B89 VOL: 0
;PCODE: $00002B8A VOL: 0
;break;
;PCODE: $00002B8B VOL: 0
;PCODE: $00002B8C VOL: 0
;case PAUSE:
;PCODE: $00002B8D VOL: 0
;PCODE: $00002B8E VOL: 0
;PCODE: $00002B8F VOL: 0
;bTextReader = 0;
;PCODE: $00002B90 VOL: 0
;PCODE: $00002B91 VOL: 0
;bMusicPlayer = 0;
;PCODE: $00002B92 VOL: 0
;PCODE: $00002B93 VOL: 0
;bSelect = 0;
;PCODE: $00002B94 VOL: 0
;bFileInfoWindow = 0;
;PCODE: $00002B95 VOL: 0
;PCODE: $00002B96 VOL: 0
;break;
;PCODE: $00002B97 VOL: 0
;case PLAY:
;PCODE: $00002B98 VOL: 0
;PCODE: $00002B99 VOL: 0
;PCODE: $00002B9A VOL: 0
;if(bSelect)
;PCODE: $00002B9B VOL: 0
;PCODE: $00002B9C VOL: 0
;{
;switch(select_file_option_index)
;PCODE: $00002B9D VOL: 0
;{
;case OPEN:
;PCODE: $00002B9E VOL: 0
;PCODE: $00002B9F VOL: 0
;if(!strcmp(&g_FileInfo[select_file_index].szFileName[8],".TXT") || !strcmp(&g_FileInfo[select_file_index].szFileName[8], ...
;PCODE: $00002BA0 VOL: 0
;PCODE: $00002BA1 VOL: 0
;PCODE: $00002BA2 VOL: 0
;PCODE: $00002BA3 VOL: 0
;PCODE: $00002BA4 VOL: 0
;PCODE: $00002BA5 VOL: 0
;PCODE: $00002BA6 VOL: 0
;PCODE: $00002BA7 VOL: 0
;PCODE: $00002BA8 VOL: 0
;PCODE: $00002BA9 VOL: 0
;PCODE: $00002BAA VOL: 0
;PCODE: $00002BAB VOL: 0
;PCODE: $00002BAC VOL: 0
;PCODE: $00002BAD VOL: 0
;PCODE: $00002BAE VOL: 0
;PCODE: $00002BAF VOL: 0
;PCODE: $00002BB0 VOL: 0
;PCODE: $00002BB1 VOL: 0
;PCODE: $00002BB2 VOL: 0
;PCODE: $00002BB3 VOL: 0
;PCODE: $00002BB4 VOL: 0
;PCODE: $00002BB5 VOL: 0
;PCODE: $00002BB6 VOL: 0
;PCODE: $00002BB7 VOL: 0
;PCODE: $00002BB8 VOL: 0
;PCODE: $00002BB9 VOL: 0
;PCODE: $00002BBA VOL: 0
;PCODE: $00002BBB VOL: 0
;{
;bTextReader = 1;
;PCODE: $00002BBC VOL: 0
;PCODE: $00002BBD VOL: 0
;}
;if(!strcmp(&g_FileInfo[select_file_index].szFileName[8],".WAV") || !strcmp(&g_FileInfo[select_file_index].szFileName[8], ...
;PCODE: $00002BBE VOL: 0
;PCODE: $00002BBF VOL: 0
;PCODE: $00002BC0 VOL: 0
;PCODE: $00002BC1 VOL: 0
;PCODE: $00002BC2 VOL: 0
;PCODE: $00002BC3 VOL: 0
;PCODE: $00002BC4 VOL: 0
;PCODE: $00002BC5 VOL: 0
;PCODE: $00002BC6 VOL: 0
;PCODE: $00002BC7 VOL: 0
;PCODE: $00002BC8 VOL: 0
;PCODE: $00002BC9 VOL: 0
;PCODE: $00002BCA VOL: 0
;PCODE: $00002BCB VOL: 0
;PCODE: $00002BCC VOL: 0
;PCODE: $00002BCD VOL: 0
;PCODE: $00002BCE VOL: 0
;PCODE: $00002BCF VOL: 0
;PCODE: $00002BD0 VOL: 0
;PCODE: $00002BD1 VOL: 0
;PCODE: $00002BD2 VOL: 0
;PCODE: $00002BD3 VOL: 0
;PCODE: $00002BD4 VOL: 0
;PCODE: $00002BD5 VOL: 0
;PCODE: $00002BD6 VOL: 0
;PCODE: $00002BD7 VOL: 0
;PCODE: $00002BD8 VOL: 0
;PCODE: $00002BD9 VOL: 0
;PCODE: $00002BDA VOL: 0
;{
;bMusicPlayer = 1;
;PCODE: $00002BDB VOL: 0
;PCODE: $00002BDC VOL: 0
;}
;else
;PCODE: $00002BDD VOL: 0
;PCODE: $00002BDE VOL: 0
;{
;bFormatAlert = 1;
;PCODE: $00002BDF VOL: 0
;PCODE: $00002BE0 VOL: 0
;}
;PCODE: $00002BE1 VOL: 0
;break;
;PCODE: $00002BE2 VOL: 0
;case DELETE:
;PCODE: $00002BE3 VOL: 0
;PCODE: $00002BE4 VOL: 0
;PCODE: $00002BE5 VOL: 0
;if(!f_unlink(g_FileInfo[select_file_index].szFileName))
;PCODE: $00002BE6 VOL: 0
;PCODE: $00002BE7 VOL: 0
;PCODE: $00002BE8 VOL: 0
;PCODE: $00002BE9 VOL: 0
;PCODE: $00002BEA VOL: 0
;PCODE: $00002BEB VOL: 0
;PCODE: $00002BEC VOL: 0
;PCODE: $00002BED VOL: 0
;PCODE: $00002BEE VOL: 0
;PCODE: $00002BEF VOL: 0
;{
;bSelect = 0;
;PCODE: $00002BF0 VOL: 0
;bIsfOpened = 0;
;PCODE: $00002BF1 VOL: 0
;select_file_option_index = 0;
;PCODE: $00002BF2 VOL: 0
;select_file_index = 0;
;PCODE: $00002BF3 VOL: 0
;for(i = 0;i<nNofDirFiles;i++)
;PCODE: $00002BF4 VOL: 0
;PCODE: $00002BF5 VOL: 0
;PCODE: $00002BF6 VOL: 0
;PCODE: $00002BF7 VOL: 0
;PCODE: $00002BF8 VOL: 0
;PCODE: $00002BF9 VOL: 0
;PCODE: $00002BFA VOL: 0
;PCODE: $00002BFB VOL: 0
;PCODE: $00002BFC VOL: 0
;PCODE: $00002BFD VOL: 0
;{
;if(g_FileInfo[i].szFileName)
;PCODE: $00002BFE VOL: 0
;PCODE: $00002BFF VOL: 0
;PCODE: $00002C00 VOL: 0
;PCODE: $00002C01 VOL: 0
;PCODE: $00002C02 VOL: 0
;PCODE: $00002C03 VOL: 0
;PCODE: $00002C04 VOL: 0
;PCODE: $00002C05 VOL: 0
;memset((void*)g_FileInfo[i].szFileName,0,32);
;PCODE: $00002C06 VOL: 0
;PCODE: $00002C07 VOL: 0
;PCODE: $00002C08 VOL: 0
;PCODE: $00002C09 VOL: 0
;PCODE: $00002C0A VOL: 0
;PCODE: $00002C0B VOL: 0
;PCODE: $00002C0C VOL: 0
;PCODE: $00002C0D VOL: 0
;PCODE: $00002C0E VOL: 0
;PCODE: $00002C0F VOL: 0
;PCODE: $00002C10 VOL: 0
;PCODE: $00002C11 VOL: 0
;free(g_FileInfo[i].szFileName);
;PCODE: $00002C12 VOL: 0
;PCODE: $00002C13 VOL: 0
;PCODE: $00002C14 VOL: 0
;PCODE: $00002C15 VOL: 0
;PCODE: $00002C16 VOL: 0
;PCODE: $00002C17 VOL: 0
;PCODE: $00002C18 VOL: 0
;PCODE: $00002C19 VOL: 0
;PCODE: $00002C1A VOL: 0
;g_FileInfo[i].szFileName = 0;
;PCODE: $00002C1B VOL: 0
;PCODE: $00002C1C VOL: 0
;PCODE: $00002C1D VOL: 0
;PCODE: $00002C1E VOL: 0
;PCODE: $00002C1F VOL: 0
;PCODE: $00002C20 VOL: 0
;}
;PCODE: $00002C21 VOL: 0
;PCODE: $00002C22 VOL: 0
;PCODE: $00002C23 VOL: 0
;PCODE: $00002C24 VOL: 0
;PCODE: $00002C25 VOL: 0
;PCODE: $00002C26 VOL: 0
;nKey = 0;
;PCODE: $00002C27 VOL: 0
;}
;break;
;PCODE: $00002C28 VOL: 0
;PCODE: $00002C29 VOL: 0
;case INFO:
;PCODE: $00002C2A VOL: 0
;PCODE: $00002C2B VOL: 0
;PCODE: $00002C2C VOL: 0
;bFileInfoWindow = 1;
;PCODE: $00002C2D VOL: 0
;PCODE: $00002C2E VOL: 0
;break;
;PCODE: $00002C2F VOL: 0
;}
;PCODE: $00002C30 VOL: 0
;}
;bSelect = 1;
;PCODE: $00002C31 VOL: 0
;PCODE: $00002C32 VOL: 0
;PCODE: $00002C33 VOL: 0
;break;
;PCODE: $00002C34 VOL: 0
;}
;PCODE: $00002C35 VOL: 0
;if(!bIsfOpened)
;PCODE: $00002C36 VOL: 0
;PCODE: $00002C37 VOL: 0
;f_mkdir("LOG");
;PCODE: $00002C38 VOL: 0
;PCODE: $00002C39 VOL: 0
;PCODE: $00002C3A VOL: 0
;if(bFormatAlert)
;PCODE: $00002C3B VOL: 0
;PCODE: $00002C3C VOL: 0
;PCODE: $00002C3D VOL: 0
;PCODE: $00002C3E VOL: 0
;{
;nlcd_Box(10,32,58,80,2,WHITE,GREEN);
;PCODE: $00002C3F VOL: 0
;PCODE: $00002C40 VOL: 0
;PCODE: $00002C41 VOL: 0
;PCODE: $00002C42 VOL: 0
;PCODE: $00002C43 VOL: 0
;PCODE: $00002C44 VOL: 0
;PCODE: $00002C45 VOL: 0
;PCODE: $00002C46 VOL: 0
;PCODE: $00002C47 VOL: 0
;PCODE: $00002C48 VOL: 0
;PCODE: $00002C49 VOL: 0
;PCODE: $00002C4A VOL: 0
;PCODE: $00002C4B VOL: 0
;PCODE: $00002C4C VOL: 0
;PCODE: $00002C4D VOL: 0
;nlcd_String("Not Supported",45,20,RED,WHITE);
;PCODE: $00002C4E VOL: 0
;PCODE: $00002C4F VOL: 0
;PCODE: $00002C50 VOL: 0
;PCODE: $00002C51 VOL: 0
;PCODE: $00002C52 VOL: 0
;PCODE: $00002C53 VOL: 0
;PCODE: $00002C54 VOL: 0
;PCODE: $00002C55 VOL: 0
;PCODE: $00002C56 VOL: 0
;PCODE: $00002C57 VOL: 0
;PCODE: $00002C58 VOL: 0
;delay_ms(1000);
;PCODE: $00002C59 VOL: 0
;PCODE: $00002C5A VOL: 0
;bFormatAlert = 0;
;PCODE: $00002C5B VOL: 0
;PCODE: $00002C5C VOL: 0
;}
;     // надо проверять готовность порта с помощью wait_ready, чтобы на MISO было 0xFF, иначе придется отрубать питание S ...
;bIsfOpened = 1;
;PCODE: $00002C5D VOL: 0
;PCODE: $00002C5E VOL: 0
;PCODE: $00002C5F VOL: 0
;nKey = 0;
;PCODE: $00002C60 VOL: 0
;}
;else //if(res == FR_NOT_READY)
;PCODE: $00002C61 VOL: 0
;PCODE: $00002C62 VOL: 0
;{
;//bBrowserInit = 1;
;f_mount(0,"0",1);
;PCODE: $00002C63 VOL: 0
;PCODE: $00002C64 VOL: 0
;PCODE: $00002C65 VOL: 0
;PCODE: $00002C66 VOL: 0
;PCODE: $00002C67 VOL: 0
;PCODE: $00002C68 VOL: 0
;PCODE: $00002C69 VOL: 0
;bIsfOpened = 0;
;PCODE: $00002C6A VOL: 0
;bSelect = 0;
;PCODE: $00002C6B VOL: 0
;select_file_index = 0;
;PCODE: $00002C6C VOL: 0
;select_file_option_index = 0;
;PCODE: $00002C6D VOL: 0
;for(i = 0;i<nNofDirFiles;i++)
;PCODE: $00002C6E VOL: 0
;PCODE: $00002C6F VOL: 0
;PCODE: $00002C70 VOL: 0
;PCODE: $00002C71 VOL: 0
;PCODE: $00002C72 VOL: 0
;PCODE: $00002C73 VOL: 0
;PCODE: $00002C74 VOL: 0
;PCODE: $00002C75 VOL: 0
;PCODE: $00002C76 VOL: 0
;PCODE: $00002C77 VOL: 0
;{
;if(g_FileInfo[i].szFileName)
;PCODE: $00002C78 VOL: 0
;PCODE: $00002C79 VOL: 0
;PCODE: $00002C7A VOL: 0
;PCODE: $00002C7B VOL: 0
;PCODE: $00002C7C VOL: 0
;PCODE: $00002C7D VOL: 0
;PCODE: $00002C7E VOL: 0
;PCODE: $00002C7F VOL: 0
;memset((void*)g_FileInfo[i].szFileName,0,32);
;PCODE: $00002C80 VOL: 0
;PCODE: $00002C81 VOL: 0
;PCODE: $00002C82 VOL: 0
;PCODE: $00002C83 VOL: 0
;PCODE: $00002C84 VOL: 0
;PCODE: $00002C85 VOL: 0
;PCODE: $00002C86 VOL: 0
;PCODE: $00002C87 VOL: 0
;PCODE: $00002C88 VOL: 0
;PCODE: $00002C89 VOL: 0
;PCODE: $00002C8A VOL: 0
;PCODE: $00002C8B VOL: 0
;free(g_FileInfo[i].szFileName);
;PCODE: $00002C8C VOL: 0
;PCODE: $00002C8D VOL: 0
;PCODE: $00002C8E VOL: 0
;PCODE: $00002C8F VOL: 0
;PCODE: $00002C90 VOL: 0
;PCODE: $00002C91 VOL: 0
;PCODE: $00002C92 VOL: 0
;PCODE: $00002C93 VOL: 0
;PCODE: $00002C94 VOL: 0
;}
;PCODE: $00002C95 VOL: 0
;PCODE: $00002C96 VOL: 0
;PCODE: $00002C97 VOL: 0
;PCODE: $00002C98 VOL: 0
;PCODE: $00002C99 VOL: 0
;PCODE: $00002C9A VOL: 0
;nlcd_String("<Slot Empty>",30,20,BLACK,WHITE);
;PCODE: $00002C9B VOL: 0
;PCODE: $00002C9C VOL: 0
;PCODE: $00002C9D VOL: 0
;PCODE: $00002C9E VOL: 0
;PCODE: $00002C9F VOL: 0
;PCODE: $00002CA0 VOL: 0
;PCODE: $00002CA1 VOL: 0
;PCODE: $00002CA2 VOL: 0
;PCODE: $00002CA3 VOL: 0
;PCODE: $00002CA4 VOL: 0
;PCODE: $00002CA5 VOL: 0
;nlcd_String("No Card",18,5,BLACK,WHITE);
;PCODE: $00002CA6 VOL: 0
;PCODE: $00002CA7 VOL: 0
;PCODE: $00002CA8 VOL: 0
;PCODE: $00002CA9 VOL: 0
;PCODE: $00002CAA VOL: 0
;PCODE: $00002CAB VOL: 0
;PCODE: $00002CAC VOL: 0
;PCODE: $00002CAD VOL: 0
;PCODE: $00002CAE VOL: 0
;PCODE: $00002CAF VOL: 0
;PCODE: $00002CB0 VOL: 0
;}
;PCODE: $00002CB1 VOL: 0
;if(!bFileInfoWindow && !bTextReader)
;PCODE: $00002CB2 VOL: 0
;PCODE: $00002CB3 VOL: 0
;PCODE: $00002CB4 VOL: 0
;PCODE: $00002CB5 VOL: 0
;PCODE: $00002CB6 VOL: 0
;PCODE: $00002CB7 VOL: 0
;PCODE: $00002CB8 VOL: 0
;PCODE: $00002CB9 VOL: 0
;PCODE: $00002CBA VOL: 0
;PCODE: $00002CBB VOL: 0
;{
;nlcd_String("Browser",5,40,WHITE,BLUE);
;PCODE: $00002CBC VOL: 0
;PCODE: $00002CBD VOL: 0
;PCODE: $00002CBE VOL: 0
;PCODE: $00002CBF VOL: 0
;PCODE: $00002CC0 VOL: 0
;PCODE: $00002CC1 VOL: 0
;PCODE: $00002CC2 VOL: 0
;PCODE: $00002CC3 VOL: 0
;PCODE: $00002CC4 VOL: 0
;PCODE: $00002CC5 VOL: 0
;PCODE: $00002CC6 VOL: 0
;PCODE: $00002CC7 VOL: 0
;nlcd_HorizontalLine(27,BLACK);
;PCODE: $00002CC8 VOL: 0
;PCODE: $00002CC9 VOL: 0
;PCODE: $00002CCA VOL: 0
;PCODE: $00002CCB VOL: 0
;PCODE: $00002CCC VOL: 0
;nlcd_HorizontalLine(15,BLACK);
;PCODE: $00002CCD VOL: 0
;PCODE: $00002CCE VOL: 0
;PCODE: $00002CCF VOL: 0
;PCODE: $00002CD0 VOL: 0
;PCODE: $00002CD1 VOL: 0
;for(i = 0;i<15;i++)
;PCODE: $00002CD2 VOL: 0
;PCODE: $00002CD3 VOL: 0
;PCODE: $00002CD4 VOL: 0
;PCODE: $00002CD5 VOL: 0
;PCODE: $00002CD6 VOL: 0
;PCODE: $00002CD7 VOL: 0
;PCODE: $00002CD8 VOL: 0
;PCODE: $00002CD9 VOL: 0
;PCODE: $00002CDA VOL: 0
;PCODE: $00002CDB VOL: 0
;{
;nlcd_PixelLine2x1(30,i,WHITE,BLACK);
;PCODE: $00002CDC VOL: 0
;PCODE: $00002CDD VOL: 0
;PCODE: $00002CDE VOL: 0
;PCODE: $00002CDF VOL: 0
;PCODE: $00002CE0 VOL: 0
;PCODE: $00002CE1 VOL: 0
;PCODE: $00002CE2 VOL: 0
;PCODE: $00002CE3 VOL: 0
;PCODE: $00002CE4 VOL: 0
;nlcd_PixelLine2x1(100,i,WHITE,BLACK);
;PCODE: $00002CE5 VOL: 0
;PCODE: $00002CE6 VOL: 0
;PCODE: $00002CE7 VOL: 0
;PCODE: $00002CE8 VOL: 0
;PCODE: $00002CE9 VOL: 0
;PCODE: $00002CEA VOL: 0
;PCODE: $00002CEB VOL: 0
;PCODE: $00002CEC VOL: 0
;PCODE: $00002CED VOL: 0
;}
;PCODE: $00002CEE VOL: 0
;PCODE: $00002CEF VOL: 0
;PCODE: $00002CF0 VOL: 0
;PCODE: $00002CF1 VOL: 0
;PCODE: $00002CF2 VOL: 0
;PCODE: $00002CF3 VOL: 0
;}
;nlcd_HorizontalLine(120,BLACK);
;PCODE: $00002CF4 VOL: 0
;PCODE: $00002CF5 VOL: 0
;PCODE: $00002CF6 VOL: 0
;PCODE: $00002CF7 VOL: 0
;PCODE: $00002CF8 VOL: 0
;PCODE: $00002CF9 VOL: 0
;for(i = 121;i<131;i++)
;PCODE: $00002CFA VOL: 0
;PCODE: $00002CFB VOL: 0
;PCODE: $00002CFC VOL: 0
;PCODE: $00002CFD VOL: 0
;PCODE: $00002CFE VOL: 0
;PCODE: $00002CFF VOL: 0
;PCODE: $00002D00 VOL: 0
;PCODE: $00002D01 VOL: 0
;PCODE: $00002D02 VOL: 0
;PCODE: $00002D03 VOL: 0
;{
;nlcd_PixelLine2x1(50,i,WHITE,BLACK);
;PCODE: $00002D04 VOL: 0
;PCODE: $00002D05 VOL: 0
;PCODE: $00002D06 VOL: 0
;PCODE: $00002D07 VOL: 0
;PCODE: $00002D08 VOL: 0
;PCODE: $00002D09 VOL: 0
;PCODE: $00002D0A VOL: 0
;PCODE: $00002D0B VOL: 0
;PCODE: $00002D0C VOL: 0
;nlcd_PixelLine2x1(95,i,WHITE,BLACK);
;PCODE: $00002D0D VOL: 0
;PCODE: $00002D0E VOL: 0
;PCODE: $00002D0F VOL: 0
;PCODE: $00002D10 VOL: 0
;PCODE: $00002D11 VOL: 0
;PCODE: $00002D12 VOL: 0
;PCODE: $00002D13 VOL: 0
;PCODE: $00002D14 VOL: 0
;PCODE: $00002D15 VOL: 0
;}
;PCODE: $00002D16 VOL: 0
;PCODE: $00002D17 VOL: 0
;PCODE: $00002D18 VOL: 0
;PCODE: $00002D19 VOL: 0
;PCODE: $00002D1A VOL: 0
;PCODE: $00002D1B VOL: 0
;}
;PCODE: $00002D1C VOL: 0
;PCODE: $00002D1D VOL: 0
;PCODE: $00002D1E VOL: 0
;PCODE: $00002D1F VOL: 0

	.DSEG
_0x477:
	.BYTE 0x48
;
;///////////////////////////////IMAGE VIEWER////////////////////////////////////////
;void image_viewer_init()
;{

	.CSEG
;PCODE: $00002D20 VOL: 0
;PCODE: $00002D21 VOL: 0
;
;}
;PCODE: $00002D22 VOL: 0
;PCODE: $00002D23 VOL: 0
;
;///////////////////////////////TEXT READER/////////////////////////////////////////
;void text_reader_init(int nFileIndex)
;{
;PCODE: $00002D24 VOL: 0
;PCODE: $00002D25 VOL: 0
;/*unsigned char sznotestring[16];
;UINT bw;
;int i;
;   nlcd_String("***Note Pad***",5,5,RED,WHITE);
;   if(!f_open(&file,g_FileInfo[nFileIndex].szFileName,FA_OPEN_ALWAYS | FA_READ))
;   {
;   f_lseek(&file,scroll_index);
;   memset((void*)sznotestring,0,16);
;   for(i = 0;i<12;i++)
;   {
;   f_read(&file,sznotestring,16,&bw);
;   nlcd_String(sznotestring,15 + i*10,5,BLACK,WHITE);
;   f_lseek(&file,scroll_index+(i+1)*16);
;   memset((void*)sznotestring,0,16);
;   }
;   }      */
;}
;PCODE: $00002D26 VOL: 0
;PCODE: $00002D27 VOL: 0
;
;////////////////////////////////////MUSIC PLAYER//////////////////////////////////
;void music_player_init(int nFileIndex)
;{
;PCODE: $00002D28 VOL: 0
;PCODE: $00002D29 VOL: 0
;UINT bw;
;unsigned char sznotestring[8];
;int nNumChannels = 0;
;nlcd_String("***Music Player***",5,1,RED,WHITE);
;PCODE: $00002D2A VOL: 0
;PCODE: $00002D2B VOL: 0
;PCODE: $00002D2C VOL: 0
;	nFileIndex -> Y+12
;	bw -> R16,R17
;	sznotestring -> Y+4
;	nNumChannels -> R18,R19
;PCODE: $00002D2D VOL: 0
;PCODE: $00002D2E VOL: 0
;PCODE: $00002D2F VOL: 0
;PCODE: $00002D30 VOL: 0
;PCODE: $00002D31 VOL: 0
;PCODE: $00002D32 VOL: 0
;PCODE: $00002D33 VOL: 0
;PCODE: $00002D34 VOL: 0
;PCODE: $00002D35 VOL: 0
;PCODE: $00002D36 VOL: 0
;PCODE: $00002D37 VOL: 0
;PCODE: $00002D38 VOL: 0
;PCODE: $00002D39 VOL: 0
;nlcd_String(g_FileInfo[nFileIndex].szFileName,15,1,RED,WHITE);
;PCODE: $00002D3A VOL: 0
;PCODE: $00002D3B VOL: 0
;PCODE: $00002D3C VOL: 0
;PCODE: $00002D3D VOL: 0
;PCODE: $00002D3E VOL: 0
;PCODE: $00002D3F VOL: 0
;PCODE: $00002D40 VOL: 0
;PCODE: $00002D41 VOL: 0
;PCODE: $00002D42 VOL: 0
;PCODE: $00002D43 VOL: 0
;PCODE: $00002D44 VOL: 0
;PCODE: $00002D45 VOL: 0
;PCODE: $00002D46 VOL: 0
;PCODE: $00002D47 VOL: 0
;PCODE: $00002D48 VOL: 0
;//f_lseek(&file,22);
;//f_read(&file,sznotestring,2,&bw);
;//nNumChannels = atoi(sznotestring);
;if(!bMusicFOpened)
;PCODE: $00002D49 VOL: 0
;PCODE: $00002D4A VOL: 0
;PCODE: $00002D4B VOL: 0
;{
;   if(!f_open(&file,g_FileInfo[nFileIndex].szFileName,FA_OPEN_ALWAYS | FA_READ))
;PCODE: $00002D4C VOL: 0
;PCODE: $00002D4D VOL: 0
;PCODE: $00002D4E VOL: 0
;PCODE: $00002D4F VOL: 0
;PCODE: $00002D50 VOL: 0
;PCODE: $00002D51 VOL: 0
;PCODE: $00002D52 VOL: 0
;PCODE: $00002D53 VOL: 0
;PCODE: $00002D54 VOL: 0
;PCODE: $00002D55 VOL: 0
;PCODE: $00002D56 VOL: 0
;PCODE: $00002D57 VOL: 0
;PCODE: $00002D58 VOL: 0
;   {
;TCCR0A=(0<<COM0A1) | (1<<COM0A0) | (0<<COM0B1) | (0<<COM0B0) | (1<<WGM01) | (1<<WGM00);
;PCODE: $00002D59 VOL: 0
;PCODE: $00002D5A VOL: 0
;TCCR0B=(0<<WGM02) | (0<<CS02) | (0<<CS01) | (1<<CS00);
;PCODE: $00002D5B VOL: 0
;PCODE: $00002D5C VOL: 0
;TCNT0=0x00;
;PCODE: $00002D5D VOL: 0
;PCODE: $00002D5E VOL: 0
;OCR0A=0x00;
;PCODE: $00002D5F VOL: 0
;PCODE: $00002D60 VOL: 0
;OCR0B=0x00;
;PCODE: $00002D61 VOL: 0
;PCODE: $00002D62 VOL: 0
;bMusicFOpened = 1;
;PCODE: $00002D63 VOL: 0
;PCODE: $00002D64 VOL: 0
;f_lseek(&file,44);
;PCODE: $00002D65 VOL: 0
;PCODE: $00002D66 VOL: 0
;PCODE: $00002D67 VOL: 0
;PCODE: $00002D68 VOL: 0
;}
;}
;PCODE: $00002D69 VOL: 0
;switch (state)
;PCODE: $00002D6A VOL: 0
;PCODE: $00002D6B VOL: 0
;{
; case 0:
;PCODE: $00002D6C VOL: 0
;PCODE: $00002D6D VOL: 0
; if (nAudioBufferIndex >= HALF_BUF)
;PCODE: $00002D6E VOL: 0
;PCODE: $00002D6F VOL: 0
;PCODE: $00002D70 VOL: 0
; {
;   f_read(&file,sznotestring, HALF_BUF, &bw);
;PCODE: $00002D71 VOL: 0
;PCODE: $00002D72 VOL: 0
;PCODE: $00002D73 VOL: 0
;PCODE: $00002D74 VOL: 0
;PCODE: $00002D75 VOL: 0
;PCODE: $00002D76 VOL: 0
;PCODE: $00002D77 VOL: 0
;PCODE: $00002D78 VOL: 0
;PCODE: $00002D79 VOL: 0
;PCODE: $00002D7A VOL: 0
;PCODE: $00002D7B VOL: 0
;PCODE: $00002D7C VOL: 0
;PCODE: $00002D7D VOL: 0
;   if (bw > HALF_BUF)
;PCODE: $00002D7E VOL: 0
;PCODE: $00002D7F VOL: 0
;PCODE: $00002D80 VOL: 0
;   {
;      state = 1;
;PCODE: $00002D81 VOL: 0
;PCODE: $00002D82 VOL: 0
;   }
; }
;PCODE: $00002D83 VOL: 0
; break;
;PCODE: $00002D84 VOL: 0
;PCODE: $00002D85 VOL: 0
;
; case 1:
;PCODE: $00002D86 VOL: 0
;PCODE: $00002D87 VOL: 0
;PCODE: $00002D88 VOL: 0
; if (nAudioBufferIndex < HALF_BUF)
;PCODE: $00002D89 VOL: 0
;PCODE: $00002D8A VOL: 0
;PCODE: $00002D8B VOL: 0
; {
;   f_read(&file,&sznotestring[HALF_BUF], HALF_BUF, &bw);
;PCODE: $00002D8C VOL: 0
;PCODE: $00002D8D VOL: 0
;PCODE: $00002D8E VOL: 0
;PCODE: $00002D8F VOL: 0
;PCODE: $00002D90 VOL: 0
;PCODE: $00002D91 VOL: 0
;PCODE: $00002D92 VOL: 0
;PCODE: $00002D93 VOL: 0
;PCODE: $00002D94 VOL: 0
;PCODE: $00002D95 VOL: 0
;PCODE: $00002D96 VOL: 0
;PCODE: $00002D97 VOL: 0
;PCODE: $00002D98 VOL: 0
;PCODE: $00002D99 VOL: 0
;   if (bw > HALF_BUF)
;PCODE: $00002D9A VOL: 0
;PCODE: $00002D9B VOL: 0
;PCODE: $00002D9C VOL: 0
;   {
;      state = 0;
;PCODE: $00002D9D VOL: 0
;PCODE: $00002D9E VOL: 0
;   }
; }
;PCODE: $00002D9F VOL: 0
; break;
;PCODE: $00002DA0 VOL: 0
;PCODE: $00002DA1 VOL: 0
; }
;PCODE: $00002DA2 VOL: 0
;}
;PCODE: $00002DA3 VOL: 0
;PCODE: $00002DA4 VOL: 0
;PCODE: $00002DA5 VOL: 0
;PCODE: $00002DA6 VOL: 0

	.DSEG
_0x4B2:
	.BYTE 0x13
;#include <sleep.h>
;
;unsigned int vcc = 0;//variable to hold the value of Vcc
;
;
;
;void ADC_Init(){
; 0000 0013 void ADC_Init(){

	.CSEG
;PCODE: $00002DA7 VOL: 0
;PCODE: $00002DA8 VOL: 0
; 0000 0014 ADCSRA=(1<<ADEN) | (0<<ADSC) | (0<<ADATE) | (0<<ADIF) | (0<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (0<<ADPS0);
;PCODE: $00002DA9 VOL: 0
;PCODE: $00002DAA VOL: 0
; 0000 0015 ADCSRB=(0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0);
;PCODE: $00002DAB VOL: 0
;PCODE: $00002DAC VOL: 0
; 0000 0016 ADMUX = (0 << REFS1)|(0 << REFS0) |(1 << MUX0)|(1 << MUX1)|(1 << MUX2)|(0 << MUX3);
;PCODE: $00002DAD VOL: 0
;PCODE: $00002DAE VOL: 0
; 0000 0017 }
;PCODE: $00002DAF VOL: 0
;PCODE: $00002DB0 VOL: 0
;
;
;unsigned int ReadADC(unsigned char ref_channel){
; 0000 001A unsigned int ReadADC(unsigned char ref_channel){
;PCODE: $00002DB1 VOL: 0
;PCODE: $00002DB2 VOL: 0
; 0000 001B   //ADMUX = ref_channel; //выбираем канал и источник опорного напряжения. Из соображений качества кода лучше бы разделит ...
; 0000 001C  int i;
; 0000 001D  for(i = 0;i<8;i++)
;PCODE: $00002DB3 VOL: 0
;PCODE: $00002DB4 VOL: 0
;PCODE: $00002DB5 VOL: 0
;	ref_channel -> Y+2
;	i -> R16,R17
;PCODE: $00002DB6 VOL: 0
;PCODE: $00002DB7 VOL: 0
;PCODE: $00002DB8 VOL: 0
;PCODE: $00002DB9 VOL: 0
;PCODE: $00002DBA VOL: 0
;PCODE: $00002DBB VOL: 0
;PCODE: $00002DBC VOL: 0
;PCODE: $00002DBD VOL: 0
;PCODE: $00002DBE VOL: 0
; 0000 001E  {
; 0000 001F  ADCSRA |= (1<<ADSC); //запускаем преобразование
;PCODE: $00002DBF VOL: 0
;PCODE: $00002DC0 VOL: 0
;PCODE: $00002DC1 VOL: 0
; 0000 0020   while(! (ADCSRA & (1<<ADIF)) ){} //ждем пока преобразование не закончится
;PCODE: $00002DC2 VOL: 0
;PCODE: $00002DC3 VOL: 0
;PCODE: $00002DC4 VOL: 0
;PCODE: $00002DC5 VOL: 0
;PCODE: $00002DC6 VOL: 0
;PCODE: $00002DC7 VOL: 0
; 0000 0021   }
;PCODE: $00002DC8 VOL: 0
;PCODE: $00002DC9 VOL: 0
;PCODE: $00002DCA VOL: 0
;PCODE: $00002DCB VOL: 0
;PCODE: $00002DCC VOL: 0
; 0000 0022   ADCSRA |= (1<<ADIF); //сбрасываем флаг прерывания
;PCODE: $00002DCD VOL: 0
;PCODE: $00002DCE VOL: 0
;PCODE: $00002DCF VOL: 0
; 0000 0023   return ADCW;
;PCODE: $00002DD0 VOL: 0
;PCODE: $00002DD1 VOL: 0
;PCODE: $00002DD2 VOL: 0
;PCODE: $00002DD3 VOL: 0
;PCODE: $00002DD4 VOL: 0
;PCODE: $00002DD5 VOL: 0
;PCODE: $00002DD6 VOL: 0
; 0000 0024 }
;PCODE: $00002DD7 VOL: 0
;
;void main(void) //При использовании буффера (RAM памяти) и 12-битной графики двигать графические объекты и рисовать отде ...
; 0000 0027 {               // т.е. 1 пиксель = 2 пикселям идущим подряд
;PCODE: $00002DD8 VOL: 0
; 0000 0028 int i = 0;
; 0000 0029 unsigned char bCardCheck = 0;
; 0000 002A unsigned char str1[32];
; 0000 002B unsigned int adc_data;
; 0000 002C unsigned char adcstr[32];
; 0000 002D unsigned char pBuffer[10];
; 0000 002E unsigned char pBufferstr[10];
; 0000 002F unsigned char adstr[32];
; 0000 0030 unsigned int adc_data2;
; 0000 0031 uint8_t timebuf[8];
; 0000 0032 uint8_t hour;
; 0000 0033 uint8_t min;
; 0000 0034 uint8_t sec;
; 0000 0035 unsigned char timestr[32];
; 0000 0036 CS_LCD_SET;
;PCODE: $00002DD9 VOL: 0
;	i -> R16,R17
;	bCardCheck -> R19
;	str1 -> Y+128
;	adc_data -> R20,R21
;	adcstr -> Y+96
;	pBuffer -> Y+86
;	pBufferstr -> Y+76
;	adstr -> Y+44
;	adc_data2 -> Y+42
;	timebuf -> Y+34
;	hour -> R18
;	min -> Y+33
;	sec -> Y+32
;	timestr -> Y+0
;PCODE: $00002DDA VOL: 0
;PCODE: $00002DDB VOL: 0
;PCODE: $00002DDC VOL: 0
;PCODE: $00002DDD VOL: 0
;PCODE: $00002DDE VOL: 0
;PCODE: $00002DDF VOL: 0
; 0000 0037 CS_SRAM_SET;
;PCODE: $00002DE0 VOL: 0
;PCODE: $00002DE1 VOL: 0
; 0000 0038 SRAM_HOLD_SET;
;PCODE: $00002DE2 VOL: 0
;PCODE: $00002DE3 VOL: 0
; 0000 0039 DDRC = 0xFF;
;PCODE: $00002DE4 VOL: 0
;PCODE: $00002DE5 VOL: 0
; 0000 003A PORTC = 0xFF;
;PCODE: $00002DE6 VOL: 0
;PCODE: $00002DE7 VOL: 0
; 0000 003B DDRD = 0xFF;
;PCODE: $00002DE8 VOL: 0
;PCODE: $00002DE9 VOL: 0
; 0000 003C DDRD.2 = 0;
;PCODE: $00002DEA VOL: 0
;PCODE: $00002DEB VOL: 0
; 0000 003D PORTD.0 = 0;
;PCODE: $00002DEC VOL: 0
;PCODE: $00002DED VOL: 0
; 0000 003E nlcd_InitSPI();
;PCODE: $00002DEE VOL: 0
; 0000 003F nlcd_InitPixelBuffer(1);
;PCODE: $00002DEF VOL: 0
;PCODE: $00002DF0 VOL: 0
;PCODE: $00002DF1 VOL: 0
; 0000 0040 nlcd_Init();
;PCODE: $00002DF2 VOL: 0
; 0000 0041 delay_ms(20);
;PCODE: $00002DF3 VOL: 0
;PCODE: $00002DF4 VOL: 0
;PCODE: $00002DF5 VOL: 0
; 0000 0042 TWI_MasterInit(100);
;PCODE: $00002DF6 VOL: 0
;PCODE: $00002DF7 VOL: 0
;PCODE: $00002DF8 VOL: 0
; 0000 0043    /*подготавливаем сообщение*/
; 0000 0044   timebuf[0] = (DS1307_ADR<<1)|0;  //адресный пакет
;PCODE: $00002DF9 VOL: 0
;PCODE: $00002DFA VOL: 0
; 0000 0045   timebuf[1] = 0;                  //адрес регистра
;PCODE: $00002DFB VOL: 0
;PCODE: $00002DFC VOL: 0
; 0000 0046   timebuf[2] = (5<<4)|5;           //значение секунд
;PCODE: $00002DFD VOL: 0
;PCODE: $00002DFE VOL: 0
; 0000 0047   timebuf[3] = (5<<4)|9;           //значение минут
;PCODE: $00002DFF VOL: 0
;PCODE: $00002E00 VOL: 0
; 0000 0048   timebuf[4] = 0;                  //значение часов
;PCODE: $00002E01 VOL: 0
;PCODE: $00002E02 VOL: 0
; 0000 0049   TWI_SendData(timebuf, 5);
;PCODE: $00002E03 VOL: 0
;PCODE: $00002E04 VOL: 0
;PCODE: $00002E05 VOL: 0
;PCODE: $00002E06 VOL: 0
; 0000 004A //смонтировать диск
; 0000 004B //df_Memory_Erase();
; 0000 004C /*pBuffer[0] = 10;
; 0000 004D pBuffer[1] = 2;
; 0000 004E pBuffer[2] = 3;
; 0000 004F pBuffer[3] = 4;
; 0000 0050 pBuffer[4] = 5;
; 0000 0051 //df_Memory_Write_Buffer(0xA74,0x0E,&pBuffer[0],4,1);
; 0000 0052 pBuffer[0] = 0;
; 0000 0053 pBuffer[1] = 0;
; 0000 0054 pBuffer[2] = 0;
; 0000 0055 pBuffer[3] = 0;
; 0000 0056 pBuffer[4] = 0;
; 0000 0057 df_Memory_Read_Buffer(0xA74,0x0E,&pBuffer[0],4,1);
; 0000 0058 sprintf(pBufferstr,"%i,%i,%i,%i",pBuffer[0],pBuffer[1],pBuffer[2],pBuffer[3]);  */
; 0000 0059 ADC_Init();
;PCODE: $00002E07 VOL: 0
; 0000 005A DDRD.2 = 0;
;PCODE: $00002E08 VOL: 0
;PCODE: $00002E09 VOL: 0
; 0000 005B EICRA=(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);
;PCODE: $00002E0A VOL: 0
;PCODE: $00002E0B VOL: 0
; 0000 005C EIMSK=(0<<INT1) | (1<<INT0);
;PCODE: $00002E0C VOL: 0
;PCODE: $00002E0D VOL: 0
; 0000 005D EIFR=(0<<INTF1) | (1<<INTF0);
;PCODE: $00002E0E VOL: 0
;PCODE: $00002E0F VOL: 0
; 0000 005E PCICR=(0<<PCIE2) | (0<<PCIE1) | (0<<PCIE0);
;PCODE: $00002E10 VOL: 0
;PCODE: $00002E11 VOL: 0
; 0000 005F KEYS_INIT;
;PCODE: $00002E12 VOL: 0
;PCODE: $00002E13 VOL: 0
;PCODE: $00002E14 VOL: 0
;PCODE: $00002E15 VOL: 0
;PCODE: $00002E16 VOL: 0
;PCODE: $00002E17 VOL: 0
; 0000 0060 CS_KEYS_SET;
;PCODE: $00002E18 VOL: 0
;PCODE: $00002E19 VOL: 0
; 0000 0061 #asm("sei");
;PCODE: $00002E1A VOL: 0
	sei
;PCODE: $00002E1B VOL: 0
; 0000 0062 while(1)
;PCODE: $00002E1C VOL: 0
; 0000 0063     {
; 0000 0064 nlcd_Clear(WHITE);
;PCODE: $00002E1D VOL: 0
;PCODE: $00002E1E VOL: 0
; 0000 0065 //nlcd_String(&pBufferstr[0],90,52,MAGENTA,WHITE);
; 0000 0066 CS_LCD_SET;
;PCODE: $00002E1F VOL: 0
;PCODE: $00002E20 VOL: 0
; 0000 0067 CS_SRAM_SET;
;PCODE: $00002E21 VOL: 0
;PCODE: $00002E22 VOL: 0
; 0000 0068 browser_init();
;PCODE: $00002E23 VOL: 0
; 0000 0069 PORTD.0 = 0;
;PCODE: $00002E24 VOL: 0
;PCODE: $00002E25 VOL: 0
; 0000 006A ///ADC Vref 1.1V
; 0000 006B adc_data = ReadADC(14);
;PCODE: $00002E26 VOL: 0
;PCODE: $00002E27 VOL: 0
;PCODE: $00002E28 VOL: 0
; 0000 006C vcc = 110 * 1024 / adc_data/3.3;     //// Для точности откалибровать !!! 1.2 - 1.3В бандгап
;PCODE: $00002E29 VOL: 0
;PCODE: $00002E2A VOL: 0
;PCODE: $00002E2B VOL: 0
;PCODE: $00002E2C VOL: 0
;PCODE: $00002E2D VOL: 0
;PCODE: $00002E2E VOL: 0
;PCODE: $00002E2F VOL: 0
;PCODE: $00002E30 VOL: 0
;PCODE: $00002E31 VOL: 0
;PCODE: $00002E32 VOL: 0
;PCODE: $00002E33 VOL: 0
; 0000 006D sprintf(&adcstr[0],"B:%i", vcc);
;PCODE: $00002E34 VOL: 0
;PCODE: $00002E35 VOL: 0
;PCODE: $00002E36 VOL: 0
;PCODE: $00002E37 VOL: 0
;PCODE: $00002E38 VOL: 0
;PCODE: $00002E39 VOL: 0
;PCODE: $00002E3A VOL: 0
;PCODE: $00002E3B VOL: 0
;PCODE: $00002E3C VOL: 0
;PCODE: $00002E3D VOL: 0
;PCODE: $00002E3E VOL: 0
;PCODE: $00002E3F VOL: 0
; 0000 006E strcat(&adcstr[0],"%");
;PCODE: $00002E40 VOL: 0
;PCODE: $00002E41 VOL: 0
;PCODE: $00002E42 VOL: 0
;PCODE: $00002E43 VOL: 0
;PCODE: $00002E44 VOL: 0
; 0000 006F nlcd_String(&adcstr[0],122,2,GREEN,WHITE);
;PCODE: $00002E45 VOL: 0
;PCODE: $00002E46 VOL: 0
;PCODE: $00002E47 VOL: 0
;PCODE: $00002E48 VOL: 0
;PCODE: $00002E49 VOL: 0
;PCODE: $00002E4A VOL: 0
;PCODE: $00002E4B VOL: 0
;PCODE: $00002E4C VOL: 0
;PCODE: $00002E4D VOL: 0
;PCODE: $00002E4E VOL: 0
; 0000 0070        /*устанавливаем указатель DS1307
; 0000 0071        на нулевой адрес*/
; 0000 0072       timebuf[0] = (DS1307_ADR<<1)|0; //адресный пакет
;PCODE: $00002E4F VOL: 0
;PCODE: $00002E50 VOL: 0
; 0000 0073       timebuf[1] = 0;                 //адрес регистра
;PCODE: $00002E51 VOL: 0
;PCODE: $00002E52 VOL: 0
; 0000 0074       TWI_SendData(timebuf, 2);
;PCODE: $00002E53 VOL: 0
;PCODE: $00002E54 VOL: 0
;PCODE: $00002E55 VOL: 0
;PCODE: $00002E56 VOL: 0
; 0000 0075       /*считываем время с DS1307*/
; 0000 0076       timebuf[0] = (DS1307_ADR<<1)|1;
;PCODE: $00002E57 VOL: 0
;PCODE: $00002E58 VOL: 0
; 0000 0077       TWI_SendData(timebuf, 5);
;PCODE: $00002E59 VOL: 0
;PCODE: $00002E5A VOL: 0
;PCODE: $00002E5B VOL: 0
;PCODE: $00002E5C VOL: 0
; 0000 0078       /*переписываем данные буфера
; 0000 0079       драйвера в свой буфер*/
; 0000 007A       TWI_GetData(timebuf, 5);
;PCODE: $00002E5D VOL: 0
;PCODE: $00002E5E VOL: 0
;PCODE: $00002E5F VOL: 0
;PCODE: $00002E60 VOL: 0
; 0000 007B       sec = timebuf[1];
;PCODE: $00002E61 VOL: 0
;PCODE: $00002E62 VOL: 0
; 0000 007C       min  = timebuf[2];
;PCODE: $00002E63 VOL: 0
;PCODE: $00002E64 VOL: 0
; 0000 007D       hour = timebuf[3];
;PCODE: $00002E65 VOL: 0
;PCODE: $00002E66 VOL: 0
; 0000 007E sprintf(&timestr[0],"%i%i:%i%i:%i%i",(hour>>4),(hour&0xf),(min>>4),(min&0xf),(sec>>4),(sec&0xf));
;PCODE: $00002E67 VOL: 0
;PCODE: $00002E68 VOL: 0
;PCODE: $00002E69 VOL: 0
;PCODE: $00002E6A VOL: 0
;PCODE: $00002E6B VOL: 0
;PCODE: $00002E6C VOL: 0
;PCODE: $00002E6D VOL: 0
;PCODE: $00002E6E VOL: 0
;PCODE: $00002E6F VOL: 0
;PCODE: $00002E70 VOL: 0
;PCODE: $00002E71 VOL: 0
;PCODE: $00002E72 VOL: 0
;PCODE: $00002E73 VOL: 0
;PCODE: $00002E74 VOL: 0
;PCODE: $00002E75 VOL: 0
;PCODE: $00002E76 VOL: 0
;PCODE: $00002E77 VOL: 0
;PCODE: $00002E78 VOL: 0
;PCODE: $00002E79 VOL: 0
;PCODE: $00002E7A VOL: 0
;PCODE: $00002E7B VOL: 0
;PCODE: $00002E7C VOL: 0
;PCODE: $00002E7D VOL: 0
;PCODE: $00002E7E VOL: 0
;PCODE: $00002E7F VOL: 0
;PCODE: $00002E80 VOL: 0
;PCODE: $00002E81 VOL: 0
;PCODE: $00002E82 VOL: 0
;PCODE: $00002E83 VOL: 0
;PCODE: $00002E84 VOL: 0
;PCODE: $00002E85 VOL: 0
;PCODE: $00002E86 VOL: 0
;PCODE: $00002E87 VOL: 0
;PCODE: $00002E88 VOL: 0
;PCODE: $00002E89 VOL: 0
;PCODE: $00002E8A VOL: 0
; 0000 007F nlcd_String(&timestr[0],122,52,MAGENTA,WHITE);
;PCODE: $00002E8B VOL: 0
;PCODE: $00002E8C VOL: 0
;PCODE: $00002E8D VOL: 0
;PCODE: $00002E8E VOL: 0
;PCODE: $00002E8F VOL: 0
;PCODE: $00002E90 VOL: 0
;PCODE: $00002E91 VOL: 0
;PCODE: $00002E92 VOL: 0
;PCODE: $00002E93 VOL: 0
;PCODE: $00002E94 VOL: 0
; 0000 0080 nlcd_RenderPixelBuffer();
;PCODE: $00002E95 VOL: 0
; 0000 0081    }
;PCODE: $00002E96 VOL: 0
;PCODE: $00002E97 VOL: 0
; 0000 0082 }
;PCODE: $00002E98 VOL: 0
;PCODE: $00002E99 VOL: 0
;PCODE: $00002E9A VOL: 0
;PCODE: $00002E9B VOL: 0

	.DSEG
_0x4D7:
	.BYTE 0x2
